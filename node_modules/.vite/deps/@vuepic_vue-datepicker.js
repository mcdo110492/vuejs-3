import {
  add,
  addDays,
  addMonths,
  addYears,
  differenceInCalendarDays,
  eachDayOfInterval,
  endOfWeek,
  format,
  getDay,
  getHours,
  getISOWeek,
  getMinutes,
  getMonth,
  getSeconds,
  getWeek,
  getYear,
  isAfter,
  isBefore,
  isDate,
  isEqual,
  isValid,
  parse,
  parseISO,
  set,
  setHours,
  setMilliseconds,
  setMinutes,
  setMonth,
  setSeconds,
  setYear,
  startOfWeek,
  sub,
  subMonths,
  subYears
} from "./chunk-IJGLHGY2.js";
import {
  Fragment,
  Teleport,
  Transition,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createSlots,
  createTextVNode,
  createVNode,
  defineComponent,
  getCurrentScope,
  guardReactiveProps,
  h,
  isRef,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onBeforeUpdate,
  onMounted,
  onScopeDispose,
  onUnmounted,
  openBlock,
  reactive,
  ref,
  render,
  renderList,
  renderSlot,
  resolveDynamicComponent,
  toDisplayString,
  toRef,
  unref,
  useSlots,
  vShow,
  watch,
  withCtx,
  withDirectives,
  withKeys,
  withModifiers
} from "./chunk-J6475X5X.js";

// node_modules/@vuepic/vue-datepicker/dist/vue-datepicker.js
function Yt() {
  return openBlock(), createElementBlock(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      createBaseVNode("path", {
        d: "M29.333 8c0-2.208-1.792-4-4-4h-18.667c-2.208 0-4 1.792-4 4v18.667c0 2.208 1.792 4 4 4h18.667c2.208 0 4-1.792 4-4v-18.667zM26.667 8v18.667c0 0.736-0.597 1.333-1.333 1.333 0 0-18.667 0-18.667 0-0.736 0-1.333-0.597-1.333-1.333 0 0 0-18.667 0-18.667 0-0.736 0.597-1.333 1.333-1.333 0 0 18.667 0 18.667 0 0.736 0 1.333 0.597 1.333 1.333z"
      }),
      createBaseVNode("path", {
        d: "M20 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      }),
      createBaseVNode("path", {
        d: "M9.333 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      }),
      createBaseVNode("path", {
        d: "M4 14.667h24c0.736 0 1.333-0.597 1.333-1.333s-0.597-1.333-1.333-1.333h-24c-0.736 0-1.333 0.597-1.333 1.333s0.597 1.333 1.333 1.333z"
      })
    ]
  );
}
Yt.compatConfig = {
  MODE: 3
};
function pa() {
  return openBlock(), createElementBlock(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      createBaseVNode("path", {
        d: "M23.057 7.057l-16 16c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l16-16c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0z"
      }),
      createBaseVNode("path", {
        d: "M7.057 8.943l16 16c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885l-16-16c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
      })
    ]
  );
}
pa.compatConfig = {
  MODE: 3
};
function Rn() {
  return openBlock(), createElementBlock(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      createBaseVNode("path", {
        d: "M20.943 23.057l-7.057-7.057c0 0 7.057-7.057 7.057-7.057 0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-8 8c-0.521 0.521-0.521 1.365 0 1.885l8 8c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
      })
    ]
  );
}
Rn.compatConfig = {
  MODE: 3
};
function Nn() {
  return openBlock(), createElementBlock(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      createBaseVNode("path", {
        d: "M12.943 24.943l8-8c0.521-0.521 0.521-1.365 0-1.885l-8-8c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885l7.057 7.057c0 0-7.057 7.057-7.057 7.057-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0z"
      })
    ]
  );
}
Nn.compatConfig = {
  MODE: 3
};
function On() {
  return openBlock(), createElementBlock(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      createBaseVNode("path", {
        d: "M16 1.333c-8.095 0-14.667 6.572-14.667 14.667s6.572 14.667 14.667 14.667c8.095 0 14.667-6.572 14.667-14.667s-6.572-14.667-14.667-14.667zM16 4c6.623 0 12 5.377 12 12s-5.377 12-12 12c-6.623 0-12-5.377-12-12s5.377-12 12-12z"
      }),
      createBaseVNode("path", {
        d: "M14.667 8v8c0 0.505 0.285 0.967 0.737 1.193l5.333 2.667c0.658 0.329 1.46 0.062 1.789-0.596s0.062-1.46-0.596-1.789l-4.596-2.298c0 0 0-7.176 0-7.176 0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      })
    ]
  );
}
On.compatConfig = {
  MODE: 3
};
function In() {
  return openBlock(), createElementBlock(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      createBaseVNode("path", {
        d: "M24.943 19.057l-8-8c-0.521-0.521-1.365-0.521-1.885 0l-8 8c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l7.057-7.057c0 0 7.057 7.057 7.057 7.057 0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
      })
    ]
  );
}
In.compatConfig = {
  MODE: 3
};
function Yn() {
  return openBlock(), createElementBlock(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      createBaseVNode("path", {
        d: "M7.057 12.943l8 8c0.521 0.521 1.365 0.521 1.885 0l8-8c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-7.057 7.057c0 0-7.057-7.057-7.057-7.057-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
      })
    ]
  );
}
Yn.compatConfig = {
  MODE: 3
};
function Bn(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var ba = { exports: {} };
(function(e) {
  function n(a) {
    return a && a.__esModule ? a : {
      default: a
    };
  }
  e.exports = n, e.exports.__esModule = true, e.exports.default = e.exports;
})(ba);
var Ja = ba.exports;
var wn = { exports: {} };
(function(e, n) {
  Object.defineProperty(n, "__esModule", {
    value: true
  }), n.default = a;
  function a(t) {
    if (t === null || t === true || t === false)
      return NaN;
    var o = Number(t);
    return isNaN(o) ? o : o < 0 ? Math.ceil(o) : Math.floor(o);
  }
  e.exports = n.default;
})(wn, wn.exports);
var Xa = wn.exports;
var xa = Bn(Xa);
var Dn = { exports: {} };
(function(e, n) {
  Object.defineProperty(n, "__esModule", {
    value: true
  }), n.default = a;
  function a(t) {
    var o = new Date(Date.UTC(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours(), t.getMinutes(), t.getSeconds(), t.getMilliseconds()));
    return o.setUTCFullYear(t.getFullYear()), t.getTime() - o.getTime();
  }
  e.exports = n.default;
})(Dn, Dn.exports);
var Qa = Dn.exports;
var Kn = Bn(Qa);
function er(e, n) {
  var a = rr(n);
  return a.formatToParts ? nr(a, e) : ar(a, e);
}
var tr = {
  year: 0,
  month: 1,
  day: 2,
  hour: 3,
  minute: 4,
  second: 5
};
function nr(e, n) {
  try {
    for (var a = e.formatToParts(n), t = [], o = 0; o < a.length; o++) {
      var l = tr[a[o].type];
      l >= 0 && (t[l] = parseInt(a[o].value, 10));
    }
    return t;
  } catch (d) {
    if (d instanceof RangeError)
      return [NaN];
    throw d;
  }
}
function ar(e, n) {
  var a = e.format(n).replace(/\u200E/g, ""), t = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(a);
  return [t[3], t[1], t[2], t[4], t[5], t[6]];
}
var sn = {};
function rr(e) {
  if (!sn[e]) {
    var n = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: "America/New_York",
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    }).format(/* @__PURE__ */ new Date("2014-06-25T04:00:00.123Z")), a = n === "06/25/2014, 00:00:00" || n === "‎06‎/‎25‎/‎2014‎ ‎00‎:‎00‎:‎00";
    sn[e] = a ? new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: e,
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    }) : new Intl.DateTimeFormat("en-US", {
      hourCycle: "h23",
      timeZone: e,
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
  }
  return sn[e];
}
function En(e, n, a, t, o, l, d) {
  var M = /* @__PURE__ */ new Date(0);
  return M.setUTCFullYear(e, n, a), M.setUTCHours(t, o, l, d), M;
}
var Gn = 36e5;
var lr = 6e4;
var un = {
  timezone: /([Z+-].*)$/,
  timezoneZ: /^(Z)$/,
  timezoneHH: /^([+-]\d{2})$/,
  timezoneHHMM: /^([+-]\d{2}):?(\d{2})$/
};
function Fn(e, n, a) {
  var t, o;
  if (!e || (t = un.timezoneZ.exec(e), t))
    return 0;
  var l;
  if (t = un.timezoneHH.exec(e), t)
    return l = parseInt(t[1], 10), Zn(l) ? -(l * Gn) : NaN;
  if (t = un.timezoneHHMM.exec(e), t) {
    l = parseInt(t[1], 10);
    var d = parseInt(t[2], 10);
    return Zn(l, d) ? (o = Math.abs(l) * Gn + d * lr, l > 0 ? -o : o) : NaN;
  }
  if (ur(e)) {
    n = new Date(n || Date.now());
    var M = a ? n : or(n), p = Mn(M, e), $ = a ? p : sr(n, p, e);
    return -$;
  }
  return NaN;
}
function or(e) {
  return En(
    e.getFullYear(),
    e.getMonth(),
    e.getDate(),
    e.getHours(),
    e.getMinutes(),
    e.getSeconds(),
    e.getMilliseconds()
  );
}
function Mn(e, n) {
  var a = er(e, n), t = En(
    a[0],
    a[1] - 1,
    a[2],
    a[3] % 24,
    a[4],
    a[5],
    0
  ).getTime(), o = e.getTime(), l = o % 1e3;
  return o -= l >= 0 ? l : 1e3 + l, t - o;
}
function sr(e, n, a) {
  var t = e.getTime(), o = t - n, l = Mn(new Date(o), a);
  if (n === l)
    return n;
  o -= l - n;
  var d = Mn(new Date(o), a);
  return l === d ? l : Math.max(l, d);
}
function Zn(e, n) {
  return -23 <= e && e <= 23 && (n == null || 0 <= n && n <= 59);
}
var qn = {};
function ur(e) {
  if (qn[e])
    return true;
  try {
    return new Intl.DateTimeFormat(void 0, { timeZone: e }), qn[e] = true, true;
  } catch {
    return false;
  }
}
var ka = /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/;
var dn = 36e5;
var Jn = 6e4;
var ir = 2;
var Ye = {
  dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
  datePattern: /^([0-9W+-]+)(.*)/,
  plainTime: /:/,
  // year tokens
  YY: /^(\d{2})$/,
  YYY: [
    /^([+-]\d{2})$/,
    // 0 additional digits
    /^([+-]\d{3})$/,
    // 1 additional digit
    /^([+-]\d{4})$/
    // 2 additional digits
  ],
  YYYY: /^(\d{4})/,
  YYYYY: [
    /^([+-]\d{4})/,
    // 0 additional digits
    /^([+-]\d{5})/,
    // 1 additional digit
    /^([+-]\d{6})/
    // 2 additional digits
  ],
  // date tokens
  MM: /^-(\d{2})$/,
  DDD: /^-?(\d{3})$/,
  MMDD: /^-?(\d{2})-?(\d{2})$/,
  Www: /^-?W(\d{2})$/,
  WwwD: /^-?W(\d{2})-?(\d{1})$/,
  HH: /^(\d{2}([.,]\d*)?)$/,
  HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
  HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
  // time zone tokens (to identify the presence of a tz)
  timeZone: ka
};
function $n(e, n) {
  if (arguments.length < 1)
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  if (e === null)
    return /* @__PURE__ */ new Date(NaN);
  var a = n || {}, t = a.additionalDigits == null ? ir : xa(a.additionalDigits);
  if (t !== 2 && t !== 1 && t !== 0)
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  if (e instanceof Date || typeof e == "object" && Object.prototype.toString.call(e) === "[object Date]")
    return new Date(e.getTime());
  if (typeof e == "number" || Object.prototype.toString.call(e) === "[object Number]")
    return new Date(e);
  if (!(typeof e == "string" || Object.prototype.toString.call(e) === "[object String]"))
    return /* @__PURE__ */ new Date(NaN);
  var o = dr(e), l = cr(o.date, t), d = l.year, M = l.restDateString, p = fr(M, d);
  if (isNaN(p))
    return /* @__PURE__ */ new Date(NaN);
  if (p) {
    var $ = p.getTime(), h2 = 0, S;
    if (o.time && (h2 = vr(o.time), isNaN(h2)))
      return /* @__PURE__ */ new Date(NaN);
    if (o.timeZone || a.timeZone) {
      if (S = Fn(o.timeZone || a.timeZone, new Date($ + h2)), isNaN(S))
        return /* @__PURE__ */ new Date(NaN);
    } else
      S = Kn(new Date($ + h2)), S = Kn(new Date($ + h2 + S));
    return new Date($ + h2 + S);
  } else
    return /* @__PURE__ */ new Date(NaN);
}
function dr(e) {
  var n = {}, a = Ye.dateTimePattern.exec(e), t;
  if (a ? (n.date = a[1], t = a[3]) : (a = Ye.datePattern.exec(e), a ? (n.date = a[1], t = a[2]) : (n.date = null, t = e)), t) {
    var o = Ye.timeZone.exec(t);
    o ? (n.time = t.replace(o[1], ""), n.timeZone = o[1].trim()) : n.time = t;
  }
  return n;
}
function cr(e, n) {
  var a = Ye.YYY[n], t = Ye.YYYYY[n], o;
  if (o = Ye.YYYY.exec(e) || t.exec(e), o) {
    var l = o[1];
    return {
      year: parseInt(l, 10),
      restDateString: e.slice(l.length)
    };
  }
  if (o = Ye.YY.exec(e) || a.exec(e), o) {
    var d = o[1];
    return {
      year: parseInt(d, 10) * 100,
      restDateString: e.slice(d.length)
    };
  }
  return {
    year: null
  };
}
function fr(e, n) {
  if (n === null)
    return null;
  var a, t, o, l;
  if (e.length === 0)
    return t = /* @__PURE__ */ new Date(0), t.setUTCFullYear(n), t;
  if (a = Ye.MM.exec(e), a)
    return t = /* @__PURE__ */ new Date(0), o = parseInt(a[1], 10) - 1, xn(n, o) ? (t.setUTCFullYear(n, o), t) : /* @__PURE__ */ new Date(NaN);
  if (a = Ye.DDD.exec(e), a) {
    t = /* @__PURE__ */ new Date(0);
    var d = parseInt(a[1], 10);
    return yr(n, d) ? (t.setUTCFullYear(n, 0, d), t) : /* @__PURE__ */ new Date(NaN);
  }
  if (a = Ye.MMDD.exec(e), a) {
    t = /* @__PURE__ */ new Date(0), o = parseInt(a[1], 10) - 1;
    var M = parseInt(a[2], 10);
    return xn(n, o, M) ? (t.setUTCFullYear(n, o, M), t) : /* @__PURE__ */ new Date(NaN);
  }
  if (a = Ye.Www.exec(e), a)
    return l = parseInt(a[1], 10) - 1, Qn(n, l) ? Xn(n, l) : /* @__PURE__ */ new Date(NaN);
  if (a = Ye.WwwD.exec(e), a) {
    l = parseInt(a[1], 10) - 1;
    var p = parseInt(a[2], 10) - 1;
    return Qn(n, l, p) ? Xn(n, l, p) : /* @__PURE__ */ new Date(NaN);
  }
  return null;
}
function vr(e) {
  var n, a, t;
  if (n = Ye.HH.exec(e), n)
    return a = parseFloat(n[1].replace(",", ".")), cn(a) ? a % 24 * dn : NaN;
  if (n = Ye.HHMM.exec(e), n)
    return a = parseInt(n[1], 10), t = parseFloat(n[2].replace(",", ".")), cn(a, t) ? a % 24 * dn + t * Jn : NaN;
  if (n = Ye.HHMMSS.exec(e), n) {
    a = parseInt(n[1], 10), t = parseInt(n[2], 10);
    var o = parseFloat(n[3].replace(",", "."));
    return cn(a, t, o) ? a % 24 * dn + t * Jn + o * 1e3 : NaN;
  }
  return null;
}
function Xn(e, n, a) {
  n = n || 0, a = a || 0;
  var t = /* @__PURE__ */ new Date(0);
  t.setUTCFullYear(e, 0, 4);
  var o = t.getUTCDay() || 7, l = n * 7 + a + 1 - o;
  return t.setUTCDate(t.getUTCDate() + l), t;
}
var mr = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var gr = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function wa(e) {
  return e % 400 === 0 || e % 4 === 0 && e % 100 !== 0;
}
function xn(e, n, a) {
  if (n < 0 || n > 11)
    return false;
  if (a != null) {
    if (a < 1)
      return false;
    var t = wa(e);
    if (t && a > gr[n] || !t && a > mr[n])
      return false;
  }
  return true;
}
function yr(e, n) {
  if (n < 1)
    return false;
  var a = wa(e);
  return !(a && n > 366 || !a && n > 365);
}
function Qn(e, n, a) {
  return !(n < 0 || n > 52 || a != null && (a < 0 || a > 6));
}
function cn(e, n, a) {
  return !(e != null && (e < 0 || e >= 25) || n != null && (n < 0 || n >= 60) || a != null && (a < 0 || a >= 60));
}
var Tn = { exports: {} };
var An = { exports: {} };
(function(e, n) {
  Object.defineProperty(n, "__esModule", {
    value: true
  }), n.default = a;
  function a(t, o) {
    if (t == null)
      throw new TypeError("assign requires that input parameter not be null or undefined");
    for (var l in o)
      Object.prototype.hasOwnProperty.call(o, l) && (t[l] = o[l]);
    return t;
  }
  e.exports = n.default;
})(An, An.exports);
var hr = An.exports;
(function(e, n) {
  var a = Ja.default;
  Object.defineProperty(n, "__esModule", {
    value: true
  }), n.default = o;
  var t = a(hr);
  function o(l) {
    return (0, t.default)({}, l);
  }
  e.exports = n.default;
})(Tn, Tn.exports);
var pr = Tn.exports;
var br = Bn(pr);
function kr(e, n, a) {
  var t = $n(e, a), o = Fn(n, t, true), l = new Date(t.getTime() - o), d = /* @__PURE__ */ new Date(0);
  return d.setFullYear(l.getUTCFullYear(), l.getUTCMonth(), l.getUTCDate()), d.setHours(l.getUTCHours(), l.getUTCMinutes(), l.getUTCSeconds(), l.getUTCMilliseconds()), d;
}
function wr(e, n, a) {
  if (typeof e == "string" && !e.match(ka)) {
    var t = br(a);
    return t.timeZone = n, $n(e, t);
  }
  var o = $n(e, a), l = En(
    o.getFullYear(),
    o.getMonth(),
    o.getDate(),
    o.getHours(),
    o.getMinutes(),
    o.getSeconds(),
    o.getMilliseconds()
  ).getTime(), d = Fn(n, new Date(l));
  return new Date(l + d);
}
function ea(e) {
  return (n) => new Intl.DateTimeFormat(e, { weekday: "short", timeZone: "UTC" }).format(/* @__PURE__ */ new Date(`2017-01-0${n}T00:00:00+00:00`)).slice(0, 2);
}
function Dr(e) {
  return (n) => format(/* @__PURE__ */ new Date(`2017-01-0${n}T00:00:00+00:00`), "EEEEEE", { locale: e });
}
var Mr = (e, n, a) => {
  const t = [1, 2, 3, 4, 5, 6, 7];
  let o;
  if (e !== null)
    try {
      o = t.map(Dr(e));
    } catch {
      o = t.map(ea(n));
    }
  else
    o = t.map(ea(n));
  const l = o.slice(0, a), d = o.slice(a + 1, o.length);
  return [o[a]].concat(...d).concat(...l);
};
var Vn = (e, n) => {
  const a = [];
  for (let t = +e[0]; t <= +e[1]; t++)
    a.push({ value: +t, text: `${t}` });
  return n ? a.reverse() : a;
};
var Da = (e, n, a) => {
  const t = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map((l) => {
    const d = l < 10 ? `0${l}` : l;
    return /* @__PURE__ */ new Date(`2017-${d}-01T00:00:00+00:00`);
  });
  if (e !== null)
    try {
      const l = a === "long" ? "MMMM" : "MMM";
      return t.map((d, M) => {
        const p = format(d, l, { locale: e });
        return {
          text: p.charAt(0).toUpperCase() + p.substring(1),
          value: M
        };
      });
    } catch {
    }
  const o = new Intl.DateTimeFormat(n, { month: a, timeZone: "UTC" });
  return t.map((l, d) => {
    const M = o.format(l);
    return {
      text: M.charAt(0).toUpperCase() + M.substring(1),
      value: d
    };
  });
};
var $r = (e) => [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11][e];
var Ae = (e) => {
  const n = unref(e);
  return n != null && n.$el ? n == null ? void 0 : n.$el : n;
};
var Tr = (e) => Object.assign({ type: "dot" }, e);
var Ma = (e) => Array.isArray(e) ? !!e[0] && !!e[1] : false;
var Zt = {
  prop: (e) => `"${e}" prop must be enabled!`,
  dateArr: (e) => `You need to use array as "model-value" binding in order to support "${e}"`
};
var Te = (e) => e;
var ta = (e) => e === 0 ? e : !e || isNaN(+e) ? null : +e;
var na = (e) => e === null;
var Ar = (e) => {
  if (e)
    return [...e.querySelectorAll("input, button, select, textarea, a[href]")][0];
};
var Sr = (e) => {
  const n = [], a = (t) => t.filter((o) => o);
  for (let t = 0; t < e.length; t += 3) {
    const o = [e[t], e[t + 1], e[t + 2]];
    n.push(a(o));
  }
  return n;
};
var Rt = (e, n, a) => {
  const t = a ?? a === 0, o = n ?? n === 0;
  if (!t && !o)
    return false;
  const l = +a, d = +n;
  return t && o ? +e > l || +e < d : t ? +e > l : o ? +e < d : false;
};
var kt = (e, n) => Sr(e).map((a) => a.map((t) => {
  const { active: o, disabled: l, isBetween: d } = n(t);
  return {
    ...t,
    active: o,
    disabled: l,
    className: {
      dp__overlay_cell_active: o,
      dp__overlay_cell: !o,
      dp__overlay_cell_disabled: l,
      dp__overlay_cell_pad: true,
      dp__overlay_cell_active_disabled: l && o,
      dp__cell_in_between: d
    }
  };
}));
var aa = (e, n, a, t, o) => {
  const l = parse(e, n.slice(0, e.length), /* @__PURE__ */ new Date());
  return isValid(l) && isDate(l) ? t || o ? l : set(l, {
    hours: +a.hours,
    minutes: +(a == null ? void 0 : a.minutes),
    seconds: +(a == null ? void 0 : a.seconds),
    milliseconds: 0
  }) : null;
};
var _r = (e, n, a, t, o) => {
  const l = Array.isArray(a) ? a[0] : a;
  if (typeof n == "string")
    return aa(e, n, l, t, o);
  if (Array.isArray(n)) {
    let d = null;
    for (const M of n)
      if (d = aa(e, M, l, t, o), d)
        break;
    return d;
  }
  return typeof n == "function" ? n(e) : null;
};
var P = (e) => e ? new Date(e) : /* @__PURE__ */ new Date();
var Pr = (e, n, a) => {
  if (n) {
    const o = (e.getMonth() + 1).toString().padStart(2, "0"), l = e.getDate().toString().padStart(2, "0"), d = e.getHours().toString().padStart(2, "0"), M = e.getMinutes().toString().padStart(2, "0"), p = a ? e.getSeconds().toString().padStart(2, "0") : "00";
    return `${e.getFullYear()}-${o}-${l}T${d}:${M}:${p}.000Z`;
  }
  const t = Date.UTC(
    e.getUTCFullYear(),
    e.getUTCMonth(),
    e.getUTCDate(),
    e.getUTCHours(),
    e.getUTCMinutes(),
    e.getUTCSeconds()
  );
  return new Date(t).toISOString();
};
var Le = (e) => {
  let n = P(JSON.parse(JSON.stringify(e)));
  return n = setHours(n, 0), n = setMinutes(n, 0), n = setSeconds(n, 0), n = setMilliseconds(n, 0), n;
};
var nt = (e, n, a, t) => {
  let o = e ? P(e) : P();
  return (n || n === 0) && (o = setHours(o, +n)), (a || a === 0) && (o = setMinutes(o, +a)), (t || t === 0) && (o = setSeconds(o, +t)), setMilliseconds(o, 0);
};
var Pe = (e, n) => !e || !n ? false : isBefore(Le(e), Le(n));
var ye = (e, n) => !e || !n ? false : isEqual(Le(e), Le(n));
var Ne = (e, n) => !e || !n ? false : isAfter(Le(e), Le(n));
var Hn = (e, n, a) => e != null && e[0] && (e != null && e[1]) ? Ne(a, e[0]) && Pe(a, e[1]) : e != null && e[0] && n ? Ne(a, e[0]) && Pe(a, n) || Pe(a, e[0]) && Ne(a, n) : false;
var ze = (e) => {
  const n = set(new Date(e), { date: 1 });
  return Le(n);
};
var fn = (e, n, a) => n && (a || a === 0) ? Object.fromEntries(
  ["hours", "minutes", "seconds"].map((t) => t === n ? [t, a] : [t, isNaN(+e[t]) ? void 0 : +e[t]])
) : {
  hours: isNaN(+e.hours) ? void 0 : +e.hours,
  minutes: isNaN(+e.minutes) ? void 0 : +e.minutes,
  seconds: isNaN(+e.seconds) ? void 0 : +e.seconds
};
var vt = (e) => ({
  hours: getHours(e),
  minutes: getMinutes(e),
  seconds: getSeconds(e)
});
var $a = (e, n) => {
  if (n) {
    const a = getYear(P(n));
    if (a > e)
      return 12;
    if (a === e)
      return getMonth(P(n));
  }
};
var Ta = (e, n) => {
  if (n) {
    const a = getYear(P(n));
    return a < e ? -1 : a === e ? getMonth(P(n)) : void 0;
  }
};
var wt = (e) => {
  if (e)
    return getYear(P(e));
};
var Ze = (e, n) => n ? kr(e, n) : e;
var Cr = (e, n) => n ? wr(e, n) : e;
var ra = (e) => e instanceof Date ? e : parseISO(e);
var Aa = (e, n) => {
  const a = Ne(e, n) ? n : e, t = Ne(n, e) ? n : e;
  return eachDayOfInterval({ start: a, end: t });
};
var Rr = (e) => {
  const n = addMonths(e, 1);
  return { month: getMonth(n), year: getYear(n) };
};
var Kt = (e, n, a) => {
  const t = startOfWeek(Ze(e, n), { weekStartsOn: +a }), o = endOfWeek(Ze(e, n), { weekStartsOn: +a });
  return [t, o];
};
var Sa = (e, n) => {
  const a = {
    hours: getHours(P()),
    minutes: getMinutes(P()),
    seconds: n ? getSeconds(P()) : 0
  };
  return Object.assign(a, e);
};
var tt = (e, n, a) => [set(P(e), { date: 1 }), set(P(), { month: n, year: a, date: 1 })];
var xe = (e, n, a) => {
  let t = e ? P(e) : P();
  return (n || n === 0) && (t = setMonth(t, n)), a && (t = setYear(t, a)), t;
};
var _a = (e, n, a, t, o) => {
  if (!t || o && !n || !o && !a)
    return false;
  const l = o ? addMonths(e, 1) : subMonths(e, 1), d = [getMonth(l), getYear(l)];
  return o ? !Or(...d, n) : !Nr(...d, a);
};
var Nr = (e, n, a) => Pe(...tt(a, e, n)) || ye(...tt(a, e, n));
var Or = (e, n, a) => Ne(...tt(a, e, n)) || ye(...tt(a, e, n));
var Pa = (e, n, a, t, o, l) => {
  if (typeof n == "function")
    return n(e);
  const d = a ? { locale: a } : void 0;
  return Array.isArray(e) ? `${format(e[0], l, d)}${o && !e[1] ? "" : t}${e[1] ? format(e[1], l, d) : ""}` : format(e, l, d);
};
var yt = (e) => {
  if (e)
    return null;
  throw new Error(Zt.prop("partial-range"));
};
var Lt = (e, n) => {
  if (n)
    return e();
  throw new Error(Zt.prop("range"));
};
var Sn = (e) => Array.isArray(e) ? isValid(e[0]) && (e[1] ? isValid(e[1]) : true) : e ? isValid(e) : false;
var Ir = (e) => set(P(), {
  hours: +e.hours || 0,
  minutes: +e.minutes || 0,
  seconds: +e.seconds || 0
});
var vn = (e, n, a, t) => {
  if (!e)
    return true;
  if (t) {
    const o = a === "max" ? isBefore(e, n) : isAfter(e, n), l = { seconds: 0, milliseconds: 0 };
    return o || isEqual(set(e, l), set(n, l));
  }
  return a === "max" ? e.getTime() <= n.getTime() : e.getTime() >= n.getTime();
};
var la = (e, n, a, t, o) => {
  const l = e ? Ir(e) : P(n);
  return Array.isArray(t) ? vn(t[0], l, a, !!n) && vn(t[1], l, a, !!n) && o : vn(t, l, a, !!n) && o;
};
var mn = (e) => set(P(), vt(e));
var Yr = (e, n) => Array.isArray(e) ? e.map((a) => P(a)).filter((a) => getYear(P(a)) === n).map((a) => getMonth(a)) : [];
var At = reactive({
  menuFocused: false,
  shiftKeyInMenu: false
});
var Ca = () => {
  const e = (t) => {
    At.menuFocused = t;
  }, n = (t) => {
    At.shiftKeyInMenu !== t && (At.shiftKeyInMenu = t);
  };
  return {
    control: computed(() => ({ shiftKeyInMenu: At.shiftKeyInMenu, menuFocused: At.menuFocused })),
    setMenuFocused: e,
    setShiftKey: n
  };
};
var be = reactive({
  monthYear: [],
  calendar: [],
  time: [],
  actionRow: [],
  selectionGrid: [],
  timePicker: {
    0: [],
    1: []
  },
  monthPicker: []
});
var gn = ref(null);
var Ut = ref(false);
var yn = ref(false);
var hn = ref(false);
var pn = ref(false);
var Oe = ref(0);
var _e = ref(0);
var lt = () => {
  const e = computed(() => Ut.value ? [...be.selectionGrid, be.actionRow].filter((k) => k.length) : yn.value ? [
    ...be.timePicker[0],
    ...be.timePicker[1],
    pn.value ? [] : [gn.value],
    be.actionRow
  ].filter((k) => k.length) : hn.value ? [...be.monthPicker, be.actionRow] : [be.monthYear, ...be.calendar, be.time, be.actionRow].filter((k) => k.length)), n = (k) => {
    Oe.value = k ? Oe.value + 1 : Oe.value - 1;
    let T = null;
    e.value[_e.value] && (T = e.value[_e.value][Oe.value]), T || (Oe.value = k ? Oe.value - 1 : Oe.value + 1);
  }, a = (k) => {
    if (_e.value === 0 && !k || _e.value === e.value.length && k)
      return;
    _e.value = k ? _e.value + 1 : _e.value - 1, e.value[_e.value] ? e.value[_e.value] && !e.value[_e.value][Oe.value] && Oe.value !== 0 && (Oe.value = e.value[_e.value].length - 1) : _e.value = k ? _e.value - 1 : _e.value + 1;
  }, t = (k) => {
    let T = null;
    e.value[_e.value] && (T = e.value[_e.value][Oe.value]), T ? T.focus({ preventScroll: !Ut.value }) : Oe.value = k ? Oe.value - 1 : Oe.value + 1;
  }, o = () => {
    n(true), t(true);
  }, l = () => {
    n(false), t(false);
  }, d = () => {
    a(false), t(true);
  }, M = () => {
    a(true), t(true);
  }, p = (k, T) => {
    be[T] = k;
  }, $ = (k, T) => {
    be[T] = k;
  }, h2 = () => {
    Oe.value = 0, _e.value = 0;
  };
  return {
    buildMatrix: p,
    buildMultiLevelMatrix: $,
    setTimePickerBackRef: (k) => {
      gn.value = k;
    },
    setSelectionGrid: (k) => {
      Ut.value = k, h2(), k || (be.selectionGrid = []);
    },
    setTimePicker: (k, T = false) => {
      yn.value = k, pn.value = T, h2(), k || (be.timePicker[0] = [], be.timePicker[1] = []);
    },
    setTimePickerElements: (k, T = 0) => {
      be.timePicker[T] = k;
    },
    arrowRight: o,
    arrowLeft: l,
    arrowUp: d,
    arrowDown: M,
    clearArrowNav: () => {
      be.monthYear = [], be.calendar = [], be.time = [], be.actionRow = [], be.selectionGrid = [], be.timePicker[0] = [], be.timePicker[1] = [], Ut.value = false, yn.value = false, pn.value = false, hn.value = false, h2(), gn.value = null;
    },
    setMonthPicker: (k) => {
      hn.value = k, h2();
    },
    refSets: be
    // exposed for testing
  };
};
var oa = (e) => ({
  menuAppearTop: "dp-menu-appear-top",
  menuAppearBottom: "dp-menu-appear-bottom",
  open: "dp-slide-down",
  close: "dp-slide-up",
  next: "calendar-next",
  previous: "calendar-prev",
  vNext: "dp-slide-up",
  vPrevious: "dp-slide-down",
  ...e ?? {}
});
var Br = (e) => ({
  toggleOverlay: "Toggle overlay",
  menu: "Datepicker menu",
  input: "Datepicker input",
  calendarWrap: "Calendar wrapper",
  calendarDays: "Calendar days",
  openTimePicker: "Open time picker",
  closeTimePicker: "Close time Picker",
  incrementValue: (n) => `Increment ${n}`,
  decrementValue: (n) => `Decrement ${n}`,
  openTpOverlay: (n) => `Open ${n} overlay`,
  amPmButton: "Switch AM/PM mode",
  openYearsOverlay: "Open years overlay",
  openMonthsOverlay: "Open months overlay",
  nextMonth: "Next month",
  prevMonth: "Previous month",
  nextYear: "Next year",
  prevYear: "Previous year",
  day: () => "",
  ...e ?? {}
});
var sa = (e) => e ? typeof e == "boolean" ? e ? 2 : 0 : +e >= 2 ? +e : 2 : 0;
var Er = (e) => {
  const n = typeof e == "object" && e, a = {
    static: true,
    solo: false
  };
  if (!e)
    return { ...a, count: sa(false) };
  const t = n ? e : {}, o = n ? t.count ?? true : e, l = sa(o);
  return Object.assign(a, t, { count: l });
};
var Fr = (e, n, a) => e || (typeof a == "string" ? a : n);
var Vr = (e) => typeof e == "boolean" ? e ? oa({}) : false : oa(e);
var Hr = (e) => {
  const n = {
    enterSubmit: true,
    tabSubmit: true,
    openMenu: true,
    rangeSeparator: " - "
  };
  return typeof e == "object" ? { ...n, ...e ?? {}, enabled: true } : { ...n, enabled: e };
};
var Lr = (e) => ({
  months: [],
  years: [],
  times: { hours: [], minutes: [], seconds: [] },
  ...e ?? {}
});
var Ur = (e) => ({
  showSelect: true,
  showCancel: true,
  showNow: false,
  showPreview: true,
  ...e ?? {}
});
var Wr = (e) => {
  const n = { input: false };
  return typeof e == "object" ? { ...n, ...e ?? {}, enabled: true } : {
    enabled: e,
    ...n
  };
};
var Re = (e) => {
  const n = () => {
    const W = e.enableSeconds ? ":ss" : "";
    return e.is24 ? `HH:mm${W}` : `hh:mm${W} aa`;
  }, a = () => e.format ? e.format : e.monthPicker ? "MM/yyyy" : e.timePicker ? n() : e.weekPicker ? "MM/dd/yyyy" : e.yearPicker ? "yyyy" : e.enableTimePicker ? `MM/dd/yyyy, ${n()}` : "MM/dd/yyyy", t = (W) => Sa(W, e.enableSeconds), o = () => e.range ? e.startTime && Array.isArray(e.startTime) ? [t(e.startTime[0]), t(e.startTime[1])] : null : e.startTime && !Array.isArray(e.startTime) ? t(e.startTime) : null, l = computed(() => Er(e.multiCalendars)), d = computed(() => o()), M = computed(() => Br(e.ariaLabels)), p = computed(() => Lr(e.filters)), $ = computed(() => Vr(e.transitions)), h2 = computed(() => Ur(e.actionRow)), S = computed(
    () => Fr(e.previewFormat, e.format, a())
  ), R = computed(() => Hr(e.textInput)), J = computed(() => Wr(e.inline));
  return {
    defaultedTransitions: $,
    defaultedMultiCalendars: l,
    defaultedStartTime: d,
    defaultedAriaLabels: M,
    defaultedFilters: p,
    defaultedActionRow: h2,
    defaultedPreviewFormat: S,
    defaultedTextInput: R,
    defaultedInline: J,
    getDefaultPattern: a,
    getDefaultStartTime: o
  };
};
var zr = (e, n, a) => {
  const t = ref(), { defaultedTextInput: o, getDefaultPattern: l } = Re(n), d = ref(""), M = toRef(n, "format");
  watch(t, () => {
    e("internal-model-change", t.value);
  }), watch(M, () => {
    V();
  });
  const p = (r) => Cr(r, n.timezone), $ = (r) => Ze(r, n.timezone), h2 = (r, U) => Pa(
    r,
    n.format,
    n.formatLocale,
    o.value.rangeSeparator,
    n.modelAuto,
    U ?? l()
  ), S = (r) => {
    const U = r ?? P();
    return n.modelType ? m(U) : {
      hours: getHours(U),
      minutes: getMinutes(U),
      seconds: n.enableSeconds ? getSeconds(U) : 0
    };
  }, R = (r) => n.modelType ? m(r) : { month: getMonth(r), year: getYear(r) }, J = (r) => Array.isArray(r) ? Lt(
    () => [
      setYear(P(), r[0]),
      r[1] ? setYear(P(), r[1]) : yt(n.partialRange)
    ],
    n.range
  ) : setYear(P(), +r), W = (r, U) => (typeof r == "string" || typeof r == "number") && n.modelType ? b(r) : U, Q = (r) => Array.isArray(r) ? [
    W(
      r[0],
      nt(null, +r[0].hours, +r[0].minutes, r[0].seconds)
    ),
    W(
      r[1],
      nt(null, +r[1].hours, +r[1].minutes, r[1].seconds)
    )
  ] : W(r, nt(null, r.hours, r.minutes, r.seconds)), Z = (r) => Array.isArray(r) ? n.multiDates ? r.map((U) => W(U, xe(null, +U.month, +U.year))) : Lt(
    () => [
      W(r[0], xe(null, +r[0].month, +r[0].year)),
      W(
        r[1],
        r[1] ? xe(null, +r[1].month, +r[1].year) : yt(n.partialRange)
      )
    ],
    n.range
  ) : W(r, xe(null, +r.month, +r.year)), k = (r) => {
    if (Array.isArray(r))
      return r.map((U) => b(U));
    throw new Error(Zt.dateArr("multi-dates"));
  }, T = (r) => {
    if (Array.isArray(r))
      return [P(r[0]), P(r[1])];
    throw new Error(Zt.dateArr("week-picker"));
  }, I = (r) => n.modelAuto ? Array.isArray(r) ? [b(r[0]), b(r[1])] : n.autoApply ? [b(r)] : [b(r), null] : Array.isArray(r) ? Lt(
    () => [
      b(r[0]),
      r[1] ? b(r[1]) : yt(n.partialRange)
    ],
    n.range
  ) : b(r), H = () => {
    Array.isArray(t.value) && n.range && t.value.length === 1 && t.value.push(yt(n.partialRange));
  }, A = () => {
    const r = t.value;
    return [
      m(r[0]),
      r[1] ? m(r[1]) : yt(n.partialRange)
    ];
  }, q = () => t.value[1] ? A() : m(Te(t.value[0])), j = () => (t.value || []).map((r) => m(r)), le = () => (H(), n.modelAuto ? q() : n.multiDates ? j() : Array.isArray(t.value) ? Lt(() => A(), n.range) : m(Te(t.value))), f = (r) => !r || Array.isArray(r) && !r.length ? null : n.timePicker ? Q(Te(r)) : n.monthPicker ? Z(Te(r)) : n.yearPicker ? J(Te(r)) : n.multiDates ? k(Te(r)) : n.weekPicker ? T(Te(r)) : I(Te(r)), w = (r) => {
    const U = f(r);
    Sn(Te(U)) ? (t.value = Te(U), V()) : (t.value = null, d.value = "");
  }, C = () => {
    const r = (U) => format(U, o.value.format);
    return `${r(t.value[0])} ${o.value.rangeSeparator} ${t.value[1] ? r(t.value[1]) : ""}`;
  }, K = () => a.value && t.value ? Array.isArray(t.value) ? C() : format(t.value, o.value.format) : h2(t.value), c = () => t.value ? n.multiDates ? t.value.map((r) => h2(r)).join("; ") : o.value.enabled && typeof o.value.format == "string" ? K() : h2(t.value) : "", V = () => {
    !n.format || typeof n.format == "string" || o.value.enabled && typeof o.value.format == "string" ? d.value = c() : d.value = n.format(t.value);
  }, b = (r) => {
    if (n.utc) {
      const U = new Date(r);
      return n.utc === "preserve" ? new Date(U.getTime() + U.getTimezoneOffset() * 6e4) : U;
    }
    return n.modelType ? n.modelType === "date" || n.modelType === "timestamp" ? $(new Date(r)) : n.modelType === "format" && (typeof n.format == "string" || !n.format) ? parse(r, l(), /* @__PURE__ */ new Date()) : $(parse(r, n.modelType, /* @__PURE__ */ new Date())) : $(new Date(r));
  }, m = (r) => r ? n.utc ? Pr(r, n.utc === "preserve", n.enableSeconds) : n.modelType ? n.modelType === "timestamp" ? +p(r) : n.modelType === "format" && (typeof n.format == "string" || !n.format) ? h2(p(r)) : h2(p(r), n.modelType) : p(r) : "", u = (r, U = false) => {
    if (e("update:model-value", r), n.emitTimezone && U) {
      const N = Array.isArray(r) ? r.map((g) => Ze(Te(g)), n.emitTimezone) : Ze(Te(r), n.emitTimezone);
      e("update:model-timezone-value", N);
    }
  }, y = (r) => Array.isArray(t.value) ? n.multiDates ? t.value.map((U) => r(U)) : [
    r(t.value[0]),
    t.value[1] ? r(t.value[1]) : yt(n.partialRange)
  ] : r(Te(t.value)), s = (r) => u(Te(y(r)));
  return {
    inputValue: d,
    internalModelValue: t,
    checkBeforeEmit: () => t.value ? n.range ? n.partialRange ? t.value.length >= 1 : t.value.length === 2 : !!t.value : false,
    parseExternalModelValue: w,
    formatInputValue: V,
    emitModelValue: () => (V(), n.monthPicker ? s(R) : n.timePicker ? s(S) : n.yearPicker ? s(getYear) : n.weekPicker ? u(t.value, true) : u(le(), true))
  };
};
var jr = (e, n) => {
  const { defaultedFilters: a } = Re(e), { validateMonthYearInRange: t } = Et(e), o = ($, h2) => {
    let S = $;
    return a.value.months.includes(getMonth(S)) ? (S = h2 ? addMonths($, 1) : subMonths($, 1), o(S, h2)) : S;
  }, l = ($, h2) => {
    let S = $;
    return a.value.years.includes(getYear(S)) ? (S = h2 ? addYears($, 1) : subYears($, 1), l(S, h2)) : S;
  }, d = ($, h2 = false) => {
    const S = set(/* @__PURE__ */ new Date(), { month: e.month, year: e.year });
    let R = $ ? addMonths(S, 1) : subMonths(S, 1);
    e.disableYearSelect && (R = setYear(R, e.year));
    let J = getMonth(R), W = getYear(R);
    a.value.months.includes(J) && (R = o(R, $), J = getMonth(R), W = getYear(R)), a.value.years.includes(W) && (R = l(R, $), W = getYear(R)), t(J, W, $, e.preventMinMaxNavigation) && M(J, W, h2);
  }, M = ($, h2, S) => {
    n("update-month-year", { month: $, year: h2, fromNav: S });
  }, p = computed(() => ($) => _a(
    set(/* @__PURE__ */ new Date(), { month: e.month, year: e.year }),
    e.maxDate,
    e.minDate,
    e.preventMinMaxNavigation,
    $
  ));
  return { handleMonthYearChange: d, isDisabled: p, updateMonthYear: M };
};
var ht = ((e) => (e.center = "center", e.left = "left", e.right = "right", e))(ht || {});
var We = ((e) => (e.month = "month", e.year = "year", e))(We || {});
var ut = ((e) => (e.top = "top", e.bottom = "bottom", e))(ut || {});
var mt = ((e) => (e.header = "header", e.calendar = "calendar", e.timePicker = "timePicker", e))(mt || {});
var Ke = ((e) => (e.month = "month", e.year = "year", e.calendar = "calendar", e.time = "time", e.minutes = "minutes", e.hours = "hours", e.seconds = "seconds", e))(Ke || {});
var Kr = ({
  menuRef: e,
  menuRefInner: n,
  inputRef: a,
  pickerWrapperRef: t,
  inline: o,
  emit: l,
  props: d,
  slots: M
}) => {
  const p = ref({}), $ = ref(false), h2 = ref({
    top: "0",
    left: "0"
  }), S = ref(false), R = toRef(d, "teleportCenter");
  watch(R, () => {
    h2.value = JSON.parse(JSON.stringify({})), H();
  });
  const J = (m) => {
    if (d.teleport) {
      const u = m.getBoundingClientRect();
      return {
        left: u.left + window.scrollX,
        top: u.top + window.scrollY
      };
    }
    return { top: 0, left: 0 };
  }, W = (m, u) => {
    h2.value.left = `${m + u - p.value.width}px`;
  }, Q = (m) => {
    h2.value.left = `${m}px`;
  }, Z = (m, u) => {
    d.position === ht.left && Q(m), d.position === ht.right && W(m, u), d.position === ht.center && (h2.value.left = `${m + u / 2 - p.value.width / 2}px`);
  }, k = (m) => {
    const { width: u, height: y } = m.getBoundingClientRect(), { top: s, left: _ } = d.altPosition ? d.altPosition(m) : J(m);
    return { top: +s, left: +_, width: u, height: y };
  }, T = () => {
    h2.value.left = "50%", h2.value.top = "50%", h2.value.transform = "translate(-50%, -50%)", h2.value.position = "fixed", delete h2.value.opacity;
  }, I = () => {
    const m = Ae(a), { top: u, left: y, transform: s } = d.altPosition(m);
    h2.value = { top: `${u}px`, left: `${y}px`, transform: s ?? "" };
  }, H = (m = true) => {
    var u;
    if (!o.value.enabled) {
      if (R.value)
        return T();
      if (d.altPosition !== null)
        return I();
      if (m) {
        const y = d.teleport ? (u = n.value) == null ? void 0 : u.$el : e.value;
        y && (p.value = y.getBoundingClientRect()), l("recalculate-position");
      }
      return C();
    }
  }, A = ({ inputEl: m, left: u, width: y }) => {
    window.screen.width > 768 && !$.value && Z(u, y), le(m);
  }, q = (m) => {
    const { top: u, left: y, height: s, width: _ } = k(m);
    h2.value.top = `${s + u + +d.offset}px`, S.value = false, $.value || (h2.value.left = `${y + _ / 2 - p.value.width / 2}px`), A({ inputEl: m, left: y, width: _ });
  }, j = (m) => {
    const { top: u, left: y, width: s } = k(m);
    h2.value.top = `${u - +d.offset - p.value.height}px`, S.value = true, A({ inputEl: m, left: y, width: s });
  }, le = (m) => {
    if (d.autoPosition) {
      const { left: u, width: y } = k(m), { left: s, right: _ } = p.value;
      if (!$.value) {
        if (Math.abs(s) !== Math.abs(_)) {
          if (s <= 0)
            return $.value = true, Q(u);
          if (_ >= document.documentElement.clientWidth)
            return $.value = true, W(u, y);
        }
        return Z(u, y);
      }
    }
  }, f = () => {
    const m = Ae(a);
    if (m) {
      const { height: u } = p.value, { top: y, height: s } = m.getBoundingClientRect(), ee = window.innerHeight - y - s, r = y;
      return u <= ee ? ut.bottom : u > ee && u <= r ? ut.top : ee >= r ? ut.bottom : ut.top;
    }
    return ut.bottom;
  }, w = (m) => f() === ut.bottom ? q(m) : j(m), C = () => {
    const m = Ae(a);
    if (m)
      return d.autoPosition ? w(m) : q(m);
  }, K = function(m) {
    if (m) {
      const u = m.scrollHeight > m.clientHeight, s = window.getComputedStyle(m).overflowY.indexOf("hidden") !== -1;
      return u && !s;
    }
    return true;
  }, c = function(m) {
    return !m || m === document.body || m.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? window : K(m) ? m : c(m.parentNode);
  }, V = (m) => {
    if (m)
      switch (d.position) {
        case ht.left:
          return { left: 0, transform: "translateX(0)" };
        case ht.right:
          return { left: `${m.width}px`, transform: "translateX(-100%)" };
        default:
          return { left: `${m.width / 2}px`, transform: "translateX(-50%)" };
      }
    return {};
  };
  return {
    openOnTop: S,
    menuStyle: h2,
    xCorrect: $,
    setMenuPosition: H,
    getScrollableParent: c,
    shadowRender: (m, u) => {
      var N, g, F;
      const y = document.createElement("div"), s = (N = Ae(a)) == null ? void 0 : N.getBoundingClientRect();
      y.setAttribute("id", "dp--temp-container");
      const _ = (g = t.value) != null && g.clientWidth ? t.value : document.body;
      _.append(y);
      const ee = document.getElementById("dp--temp-container"), r = V(s), U = h(
        m,
        {
          ...u,
          shadow: true,
          style: { opacity: 0, position: "absolute", ...r }
        },
        Object.fromEntries(Object.keys(M).map((ae) => [ae, M[ae]]))
      );
      render(U, ee), p.value = (F = U.el) == null ? void 0 : F.getBoundingClientRect(), render(null, ee), _.removeChild(ee);
    }
  };
};
var st = [
  { name: "clock-icon", use: ["time", "calendar", "shared"] },
  { name: "arrow-left", use: ["month-year", "calendar", "shared"] },
  { name: "arrow-right", use: ["month-year", "calendar", "shared"] },
  { name: "arrow-up", use: ["time", "calendar", "month-year", "shared"] },
  { name: "arrow-down", use: ["time", "calendar", "month-year", "shared"] },
  { name: "calendar-icon", use: ["month-year", "time", "calendar", "shared"] },
  { name: "day", use: ["calendar", "shared"] },
  { name: "month-overlay-value", use: ["calendar", "month-year", "shared"] },
  { name: "year-overlay-value", use: ["calendar", "month-year", "shared"] },
  { name: "year-overlay", use: ["month-year", "shared"] },
  { name: "month-overlay", use: ["month-year", "shared"] },
  { name: "month-overlay-header", use: ["month-year", "shared"] },
  { name: "year-overlay-header", use: ["month-year", "shared"] },
  { name: "hours-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "minutes-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "seconds-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "hours", use: ["calendar", "time", "shared"] },
  { name: "minutes", use: ["calendar", "time", "shared"] },
  { name: "month", use: ["calendar", "month-year", "shared"] },
  { name: "year", use: ["calendar", "month-year", "shared"] },
  { name: "action-buttons", use: ["action"] },
  { name: "action-preview", use: ["action"] },
  { name: "calendar-header", use: ["calendar", "shared"] },
  { name: "marker-tooltip", use: ["calendar", "shared"] },
  { name: "action-extra", use: ["menu"] },
  { name: "time-picker-overlay", use: ["calendar", "time", "shared"] },
  { name: "am-pm-button", use: ["calendar", "time", "shared"] },
  { name: "left-sidebar", use: ["menu"] },
  { name: "right-sidebar", use: ["menu"] },
  { name: "month-year", use: ["month-year", "shared"] },
  { name: "time-picker", use: ["menu", "shared"] },
  { name: "action-row", use: ["action"] },
  { name: "marker", use: ["calendar", "shared"] }
];
var Gr = [{ name: "trigger" }, { name: "input-icon" }, { name: "clear-icon" }, { name: "dp-input" }];
var Zr = {
  all: () => st,
  monthYear: () => st.filter((e) => e.use.includes("month-year")),
  input: () => Gr,
  timePicker: () => st.filter((e) => e.use.includes("time")),
  action: () => st.filter((e) => e.use.includes("action")),
  calendar: () => st.filter((e) => e.use.includes("calendar")),
  menu: () => st.filter((e) => e.use.includes("menu")),
  shared: () => st.filter((e) => e.use.includes("shared"))
};
var je = (e, n, a) => {
  const t = [];
  return Zr[n]().forEach((o) => {
    e[o.name] && t.push(o.name);
  }), a != null && a.length && a.forEach((o) => {
    o.slot && t.push(o.slot);
  }), t;
};
var Bt = (e) => {
  const n = computed(() => (t) => e.value ? t ? e.value.open : e.value.close : ""), a = computed(() => (t) => e.value ? t ? e.value.menuAppearTop : e.value.menuAppearBottom : "");
  return { transitionName: n, showTransition: !!e.value, menuTransition: a };
};
var qt = (e, n) => {
  const a = ref([{ month: getMonth(P()), year: getYear(P()) }]), t = reactive({
    hours: e.range ? [getHours(P()), getHours(P())] : getHours(P()),
    minutes: e.range ? [getMinutes(P()), getMinutes(P())] : getMinutes(P()),
    seconds: e.range ? [0, 0] : 0
  }), o = computed({
    get: () => e.internalModelValue,
    set: (M) => {
      !e.readonly && !e.disabled && n("update:internal-model-value", M);
    }
  }), l = computed(
    () => (M) => a.value[M] ? a.value[M].month : 0
  ), d = computed(
    () => (M) => a.value[M] ? a.value[M].year : 0
  );
  return {
    calendars: a,
    time: t,
    modelValue: o,
    month: l,
    year: d
  };
};
var qr = (e, n) => {
  const { defaultedMultiCalendars: a } = Re(n), { isDisabled: t, matchDate: o } = Et(n), l = ref(null), d = ref(P()), M = (s) => {
    !s.current && n.hideOffsetDates || (l.value = s.value);
  }, p = () => {
    l.value = null;
  }, $ = (s) => Array.isArray(e.value) && n.range && e.value[0] && l.value ? s ? Ne(l.value, e.value[0]) : Pe(l.value, e.value[0]) : true, h2 = (s, _) => {
    const ee = () => e.value ? _ ? e.value[0] || null : e.value[1] : null, r = e.value && Array.isArray(e.value) ? ee() : null;
    return ye(P(s.value), r);
  }, S = (s) => {
    const _ = Array.isArray(e.value) ? e.value[0] : null;
    return s ? !Pe(l.value ?? null, _) : true;
  }, R = (s, _ = true) => (n.range || n.weekPicker) && Array.isArray(e.value) && e.value.length === 2 ? n.hideOffsetDates && !s.current ? false : ye(P(s.value), e.value[_ ? 0 : 1]) : n.range ? h2(s, _) && S(_) || ye(s.value, Array.isArray(e.value) ? e.value[0] : null) && $(_) : false, J = (s, _, ee) => Array.isArray(e.value) && e.value[0] && e.value.length === 1 ? s ? false : ee ? Ne(e.value[0], _.value) : Pe(e.value[0], _.value) : false, W = (s) => !e.value || n.hideOffsetDates && !s.current ? false : n.range ? n.modelAuto && Array.isArray(e.value) ? ye(s.value, e.value[0] ? e.value[0] : d.value) : false : n.multiDates && Array.isArray(e.value) ? e.value.some((_) => ye(_, s.value)) : ye(s.value, e.value ? e.value : d.value), Q = (s) => {
    if (n.autoRange || n.weekPicker) {
      if (l.value) {
        if (n.hideOffsetDates && !s.current)
          return false;
        const _ = addDays(l.value, +n.autoRange), ee = Kt(P(l.value), n.timezone, n.weekStart);
        return n.weekPicker ? ye(ee[1], P(s.value)) : ye(_, P(s.value));
      }
      return false;
    }
    return false;
  }, Z = (s) => {
    if (n.autoRange || n.weekPicker) {
      if (l.value) {
        const _ = addDays(l.value, +n.autoRange);
        if (n.hideOffsetDates && !s.current)
          return false;
        const ee = Kt(P(l.value), n.timezone, n.weekStart);
        return n.weekPicker ? Ne(s.value, ee[0]) && Pe(s.value, ee[1]) : Ne(s.value, l.value) && Pe(s.value, _);
      }
      return false;
    }
    return false;
  }, k = (s) => {
    if (n.autoRange || n.weekPicker) {
      if (l.value) {
        if (n.hideOffsetDates && !s.current)
          return false;
        const _ = Kt(P(l.value), n.timezone, n.weekStart);
        return n.weekPicker ? ye(_[0], s.value) : ye(l.value, s.value);
      }
      return false;
    }
    return false;
  }, T = (s) => Hn(e.value, l.value, s.value), I = () => n.modelAuto && Array.isArray(n.internalModelValue) ? !!n.internalModelValue[0] : false, H = () => n.modelAuto ? Ma(n.internalModelValue) : true, A = (s) => {
    if (Array.isArray(e.value) && e.value.length || n.weekPicker)
      return false;
    const _ = n.range ? !R(s) && !R(s, false) : true;
    return !t(s.value) && !W(s) && !(!s.current && n.hideOffsetDates) && _;
  }, q = (s) => n.range ? n.modelAuto ? I() && W(s) : false : W(s), j = (s) => {
    var _;
    return n.highlight ? o(
      s.value,
      (_ = n.arrMapValues) != null && _.highlightedDates ? n.arrMapValues.highlightedDates : n.highlight
    ) : false;
  }, le = (s) => t(s.value) && n.highlightDisabledDays === false, f = (s) => {
    var _;
    return (_ = n.highlightWeekDays) == null ? void 0 : _.includes(s.value.getDay());
  }, w = (s) => (n.range || n.weekPicker) && (!(a.value.count > 0) || s.current) && H() && !(!s.current && n.hideOffsetDates) && !W(s) ? T(s) : false, C = (s) => {
    const { isRangeStart: _, isRangeEnd: ee } = V(s), r = n.range ? _ || ee : false;
    return {
      dp__cell_offset: !s.current,
      dp__pointer: !n.disabled && !(!s.current && n.hideOffsetDates) && !t(s.value),
      dp__cell_disabled: t(s.value),
      dp__cell_highlight: !le(s) && (j(s) || f(s)) && !q(s) && !r,
      dp__cell_highlight_active: !le(s) && (j(s) || f(s)) && q(s),
      dp__today: !n.noToday && ye(s.value, d.value) && s.current
    };
  }, K = (s) => ({
    dp__active_date: q(s),
    dp__date_hover: A(s)
  }), c = (s) => ({
    ...b(s),
    ...m(s),
    dp__range_between_week: w(s) && n.weekPicker
  }), V = (s) => {
    const _ = a.value.count > 0 ? s.current && R(s) && H() : R(s) && H(), ee = a.value.count > 0 ? s.current && R(s, false) && H() : R(s, false) && H();
    return { isRangeStart: _, isRangeEnd: ee };
  }, b = (s) => {
    const { isRangeStart: _, isRangeEnd: ee } = V(s);
    return {
      dp__range_start: _,
      dp__range_end: ee,
      dp__range_between: w(s) && !n.weekPicker,
      dp__date_hover_start: J(A(s), s, true),
      dp__date_hover_end: J(A(s), s, false)
    };
  }, m = (s) => ({
    ...b(s),
    dp__cell_auto_range: Z(s),
    dp__cell_auto_range_start: k(s),
    dp__cell_auto_range_end: Q(s)
  }), u = (s) => n.range ? n.autoRange ? m(s) : n.modelAuto ? { ...K(s), ...b(s) } : b(s) : n.weekPicker ? c(s) : K(s);
  return {
    setHoverDate: M,
    clearHoverDate: p,
    getDayClassData: (s) => n.hideOffsetDates && !s.current ? {} : {
      ...C(s),
      ...u(s),
      [n.dayClass ? n.dayClass(s.value) : ""]: true,
      [n.calendarCellClassName]: !!n.calendarCellClassName
    }
  };
};
var Et = (e) => {
  const { defaultedFilters: n } = Re(e), a = (f) => {
    const w = Le(t(P(f))).toISOString(), [C] = w.split("T");
    return C;
  }, t = (f) => Ze(f, e.timezone), o = (f) => {
    var s;
    const w = e.maxDate ? Ne(t(f), t(P(e.maxDate))) : false, C = e.minDate ? Pe(t(f), t(P(e.minDate))) : false, K = p(
      f,
      (s = e.arrMapValues) != null && s.disabledDates ? e.arrMapValues.disabledDates : e.disabledDates
    ), V = n.value.months.map((_) => +_).includes(getMonth(f)), b = e.disabledWeekDays.length ? e.disabledWeekDays.some((_) => +_ === getDay(f)) : false, m = h2(f), u = getYear(f), y = u < +e.yearRange[0] || u > +e.yearRange[1];
    return !(w || C || K || V || y || b || m);
  }, l = (f, w) => Pe(...tt(e.minDate, f, w)) || ye(...tt(e.minDate, f, w)), d = (f, w) => Ne(...tt(e.maxDate, f, w)) || ye(...tt(e.maxDate, f, w)), M = (f, w, C) => {
    let K = false;
    return e.maxDate && C && d(f, w) && (K = true), e.minDate && !C && l(f, w) && (K = true), K;
  }, p = (f, w) => f ? w instanceof Map ? !!w.get(a(f)) : Array.isArray(w) ? w.some((C) => ye(t(P(C)), t(f))) : w ? w(P(JSON.parse(JSON.stringify(f)))) : false : true, $ = (f, w, C, K) => {
    let c = false;
    return K ? e.minDate && e.maxDate ? c = M(f, w, C) : (e.minDate && l(f, w) || e.maxDate && d(f, w)) && (c = true) : c = true, c;
  }, h2 = (f) => {
    var w, C, K, c, V;
    return Array.isArray(e.allowedDates) && !((w = e.allowedDates) != null && w.length) ? true : (C = e.arrMapValues) != null && C.allowedDates ? !p(f, (K = e.arrMapValues) == null ? void 0 : K.allowedDates) : (c = e.allowedDates) != null && c.length ? !((V = e.allowedDates) != null && V.some((b) => ye(t(P(b)), t(f)))) : false;
  }, S = (f) => !o(f), R = (f) => !eachDayOfInterval({ start: f[0], end: f[1] }).some((C) => S(C)), J = (f, w, C = 0) => {
    if (Array.isArray(w) && w[C]) {
      const K = differenceInCalendarDays(f, w[C]), c = Aa(w[C], f), V = c.length === 1 ? 0 : c.filter((m) => S(m)).length, b = Math.abs(K) - V;
      if (e.minRange && e.maxRange)
        return b >= +e.minRange && b <= +e.maxRange;
      if (e.minRange)
        return b >= +e.minRange;
      if (e.maxRange)
        return b <= +e.maxRange;
    }
    return true;
  }, W = (f) => new Map(f.map((w) => [a(w), true])), Q = (f) => Array.isArray(f) && f.length > 0, Z = () => {
    const f = {
      disabledDates: null,
      allowedDates: null,
      highlightedDates: null
    };
    return Q(e.allowedDates) && (f.allowedDates = W(e.allowedDates)), Q(e.highlight) && (f.highlightedDates = W(e.highlight)), Q(e.disabledDates) && (f.disabledDates = W(e.disabledDates)), f;
  }, k = () => !e.enableTimePicker || e.monthPicker || e.yearPicker || e.ignoreTimeValidation, T = (f) => Array.isArray(f) ? [f[0] ? mn(f[0]) : null, f[1] ? mn(f[1]) : null] : mn(f), I = (f, w, C) => f.find(
    (K) => +K.hours === getHours(w) && K.minutes === "*" ? true : +K.minutes === getMinutes(w)
  ) && C, H = (f, w, C) => {
    const [K, c] = f, [V, b] = w;
    return !I(K, V, C) && !I(c, b, C) && C;
  }, A = (f, w) => {
    const C = Array.isArray(w) ? w : [w];
    return Array.isArray(e.disabledTimes) ? Array.isArray(e.disabledTimes[0]) ? H(e.disabledTimes, C, f) : !C.some((K) => I(e.disabledTimes, K, f)) : f;
  }, q = (f, w) => {
    const C = Array.isArray(w) ? [vt(w[0]), w[1] ? vt(w[1]) : void 0] : vt(w), K = !e.disabledTimes(C);
    return f && K;
  }, j = (f, w) => e.disabledTimes ? Array.isArray(e.disabledTimes) ? A(w, f) : q(w, f) : w;
  return {
    isDisabled: S,
    validateDate: o,
    validateMonthYearInRange: $,
    isDateRangeAllowed: R,
    checkMinMaxRange: J,
    matchDate: p,
    mapDatesArrToMap: Z,
    isValidTime: (f) => {
      let w = true;
      if (!f || k())
        return true;
      const C = !e.minDate && !e.maxDate ? T(f) : f;
      return (e.maxTime || e.maxDate) && (w = la(e.maxTime, e.maxDate, "max", Te(C), w)), (e.minTime || e.minDate) && (w = la(e.minTime, e.minDate, "min", Te(C), w)), j(f, w);
    }
  };
};
var Jt = () => {
  const e = computed(() => (t, o) => t == null ? void 0 : t.includes(o)), n = computed(() => (t, o) => t.count ? t.solo ? true : o === 0 : true), a = computed(() => (t, o) => t.count ? t.solo ? true : o === t.count - 1 : true);
  return { hideNavigationButtons: e, showLeftIcon: n, showRightIcon: a };
};
var Jr = (e, n, a) => {
  const t = ref(0), o = reactive({
    // monthYearInput: !!props.timePicker,
    [mt.timePicker]: !e.enableTimePicker || e.timePicker || e.monthPicker,
    [mt.calendar]: false,
    [mt.header]: false
  }), l = (h2) => {
    var S;
    (S = e.flow) != null && S.length && (o[h2] = true, Object.keys(o).filter((R) => !o[R]).length || $());
  }, d = () => {
    var h2;
    (h2 = e.flow) != null && h2.length && t.value !== -1 && (t.value += 1, n("flow-step", t.value), $());
  }, M = () => {
    t.value = -1;
  }, p = (h2, S, ...R) => {
    e.flow[t.value] === h2 && a.value && a.value[S](...R);
  }, $ = () => {
    p(Ke.month, "toggleMonthPicker", true), p(Ke.year, "toggleYearPicker", true), p(Ke.calendar, "toggleTimePicker", false, true), p(Ke.time, "toggleTimePicker", true, true);
    const h2 = e.flow[t.value];
    (h2 === Ke.hours || h2 === Ke.minutes || h2 === Ke.seconds) && p(h2, "toggleTimePicker", true, true, h2);
  };
  return { childMount: l, updateFlowStep: d, resetFlow: M, flowStep: t };
};
var Xt = {
  multiCalendars: { type: [Boolean, Number, String, Object], default: void 0 },
  modelValue: { type: [String, Date, Array, Object, Number], default: null },
  modelType: { type: String, default: null },
  position: { type: String, default: "center" },
  dark: { type: Boolean, default: false },
  format: {
    type: [String, Function],
    default: () => null
  },
  closeOnScroll: { type: Boolean, default: false },
  autoPosition: { type: Boolean, default: true },
  closeOnAutoApply: { type: Boolean, default: true },
  altPosition: { type: Function, default: null },
  transitions: { type: [Boolean, Object], default: true },
  formatLocale: { type: Object, default: null },
  utc: { type: [Boolean, String], default: false },
  ariaLabels: { type: Object, default: () => ({}) },
  offset: { type: [Number, String], default: 10 },
  hideNavigation: { type: Array, default: () => [] },
  timezone: { type: String, default: null },
  emitTimezone: { type: String, default: null },
  vertical: { type: Boolean, default: false },
  disableMonthYearSelect: { type: Boolean, default: false },
  disableYearSelect: { type: Boolean, default: false },
  menuClassName: { type: String, default: null },
  dayClass: { type: Function, default: null },
  yearRange: { type: Array, default: () => [1900, 2100] },
  calendarCellClassName: { type: String, default: null },
  enableTimePicker: { type: Boolean, default: true },
  autoApply: { type: Boolean, default: false },
  disabledDates: { type: [Array, Function], default: () => [] },
  monthNameFormat: { type: String, default: "short" },
  startDate: { type: [Date, String], default: null },
  startTime: { type: [Object, Array], default: null },
  hideOffsetDates: { type: Boolean, default: false },
  autoRange: { type: [Number, String], default: null },
  noToday: { type: Boolean, default: false },
  disabledWeekDays: { type: Array, default: () => [] },
  allowedDates: { type: Array, default: null },
  nowButtonLabel: { type: String, default: "Now" },
  markers: { type: Array, default: () => [] },
  modeHeight: { type: [Number, String], default: 255 },
  escClose: { type: Boolean, default: true },
  spaceConfirm: { type: Boolean, default: true },
  monthChangeOnArrows: { type: Boolean, default: true },
  presetDates: { type: Array, default: () => [] },
  flow: { type: Array, default: () => [] },
  partialFlow: { type: Boolean, default: false },
  preventMinMaxNavigation: { type: Boolean, default: false },
  minRange: { type: [Number, String], default: null },
  maxRange: { type: [Number, String], default: null },
  multiDatesLimit: { type: [Number, String], default: null },
  reverseYears: { type: Boolean, default: false },
  keepActionRow: { type: Boolean, default: false },
  weekPicker: { type: Boolean, default: false },
  filters: { type: Object, default: () => ({}) },
  arrowNavigation: { type: Boolean, default: false },
  disableTimeRangeValidation: { type: Boolean, default: false },
  highlight: {
    type: [Array, Function],
    default: null
  },
  highlightWeekDays: {
    type: Array,
    default: null
  },
  highlightDisabledDays: { type: Boolean, default: false },
  teleport: { type: [String, Boolean], default: null },
  teleportCenter: { type: Boolean, default: false },
  locale: { type: String, default: "en-Us" },
  weekNumName: { type: String, default: "W" },
  weekStart: { type: [Number, String], default: 1 },
  weekNumbers: {
    type: [String, Function],
    default: null
  },
  calendarClassName: { type: String, default: null },
  noSwipe: { type: Boolean, default: false },
  monthChangeOnScroll: { type: [Boolean, String], default: true },
  dayNames: {
    type: [Function, Array],
    default: null
  },
  monthPicker: { type: Boolean, default: false },
  customProps: { type: Object, default: null },
  yearPicker: { type: Boolean, default: false },
  modelAuto: { type: Boolean, default: false },
  selectText: { type: String, default: "Select" },
  cancelText: { type: String, default: "Cancel" },
  previewFormat: {
    type: [String, Function],
    default: () => ""
  },
  multiDates: { type: Boolean, default: false },
  partialRange: { type: Boolean, default: true },
  ignoreTimeValidation: { type: Boolean, default: false },
  minDate: { type: [Date, String], default: null },
  maxDate: { type: [Date, String], default: null },
  minTime: { type: Object, default: null },
  maxTime: { type: Object, default: null },
  name: { type: String, default: null },
  placeholder: { type: String, default: "" },
  hideInputIcon: { type: Boolean, default: false },
  clearable: { type: Boolean, default: true },
  state: { type: Boolean, default: null },
  required: { type: Boolean, default: false },
  autocomplete: { type: String, default: "off" },
  inputClassName: { type: String, default: null },
  fixedStart: { type: Boolean, default: false },
  fixedEnd: { type: Boolean, default: false },
  timePicker: { type: Boolean, default: false },
  enableSeconds: { type: Boolean, default: false },
  is24: { type: Boolean, default: true },
  noHoursOverlay: { type: Boolean, default: false },
  noMinutesOverlay: { type: Boolean, default: false },
  noSecondsOverlay: { type: Boolean, default: false },
  hoursGridIncrement: { type: [String, Number], default: 1 },
  minutesGridIncrement: { type: [String, Number], default: 5 },
  secondsGridIncrement: { type: [String, Number], default: 5 },
  hoursIncrement: { type: [Number, String], default: 1 },
  minutesIncrement: { type: [Number, String], default: 1 },
  secondsIncrement: { type: [Number, String], default: 1 },
  range: { type: Boolean, default: false },
  uid: { type: String, default: null },
  disabled: { type: Boolean, default: false },
  readonly: { type: Boolean, default: false },
  inline: { type: [Boolean, Object], default: false },
  textInput: { type: [Boolean, Object], default: false },
  onClickOutside: { type: Function, default: null },
  noDisabledRange: { type: Boolean, default: false },
  sixWeeks: { type: [Boolean, String], default: false },
  actionRow: { type: Object, default: () => ({}) },
  allowPreventDefault: { type: Boolean, default: false },
  closeOnClearValue: { type: Boolean, default: true },
  focusStartDate: { type: Boolean, default: false },
  disabledTimes: { type: [Function, Array], default: void 0 },
  showLastInRange: { type: Boolean, default: true },
  timePickerInline: { type: Boolean, default: false },
  calendar: { type: Function, default: null }
};
var Qe = {
  ...Xt,
  shadow: { type: Boolean, default: false },
  flowStep: { type: Number, default: 0 },
  internalModelValue: { type: [Date, Array], default: null },
  arrMapValues: { type: Object, default: () => ({}) }
};
var Xr = {
  key: 1,
  class: "dp__input_wrap"
};
var xr = ["id", "name", "inputmode", "placeholder", "disabled", "readonly", "required", "value", "autocomplete", "aria-label", "aria-disabled", "aria-invalid", "onKeydown"];
var Qr = {
  key: 2,
  class: "dp__clear_icon"
};
var el = defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "DatepickerInput",
  props: {
    isMenuOpen: { type: Boolean, default: false },
    inputValue: { type: String, default: "" },
    ...Xt
  },
  emits: [
    "clear",
    "open",
    "update:input-value",
    "set-input-date",
    "close",
    "select-date",
    "set-empty-date",
    "toggle",
    "focus-prev",
    "focus",
    "blur",
    "real-blur"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, { defaultedTextInput: o, defaultedAriaLabels: l, defaultedInline: d, getDefaultPattern: M, getDefaultStartTime: p } = Re(t), $ = ref(), h2 = ref(null), S = ref(false), R = ref(false), J = computed(
      () => ({
        dp__pointer: !t.disabled && !t.readonly && !o.value.enabled,
        dp__disabled: t.disabled,
        dp__input_readonly: !o.value.enabled,
        dp__input: true,
        dp__input_icon_pad: !t.hideInputIcon,
        dp__input_valid: !!t.state,
        dp__input_invalid: t.state === false,
        dp__input_focus: S.value || t.isMenuOpen,
        dp__input_reg: !o.value.enabled,
        [t.inputClassName]: !!t.inputClassName
      })
    ), W = () => {
      a("set-input-date", null), t.autoApply && (a("set-empty-date"), $.value = null);
    }, Q = (c) => {
      const V = p();
      return _r(
        c,
        o.value.format ?? M(),
        V ?? Sa({}, t.enableSeconds),
        t.inputValue,
        R.value
      );
    }, Z = (c) => {
      const { rangeSeparator: V } = o.value, [b, m] = c.split(`${V}`);
      if (b) {
        const u = Q(b.trim()), y = m ? Q(m.trim()) : null, s = u && y ? [u, y] : [u];
        $.value = u ? s : null;
      }
    }, k = () => {
      R.value = true;
    }, T = (c) => {
      if (t.range)
        Z(c);
      else if (t.multiDates) {
        const V = c.split(";");
        $.value = V.map((b) => Q(b.trim())).filter((b) => b);
      } else
        $.value = Q(c);
    }, I = (c) => {
      var b;
      const V = typeof c == "string" ? c : (b = c.target) == null ? void 0 : b.value;
      V !== "" ? (o.value.openMenu && !t.isMenuOpen && a("open"), T(V), a("set-input-date", $.value)) : W(), R.value = false, a("update:input-value", V);
    }, H = (c) => {
      o.value.enabled ? (T(c.target.value), o.value.enterSubmit && Sn($.value) && t.inputValue !== "" ? (a("set-input-date", $.value, true), $.value = null) : o.value.enterSubmit && t.inputValue === "" && ($.value = null, a("clear"))) : j(c);
    }, A = (c) => {
      o.value.enabled && o.value.tabSubmit && T(c.target.value), o.value.tabSubmit && Sn($.value) && t.inputValue !== "" ? (a("set-input-date", $.value, true), $.value = null) : o.value.tabSubmit && t.inputValue === "" && ($.value = null, a("clear"));
    }, q = () => {
      S.value = true, a("focus");
    }, j = (c) => {
      c.preventDefault(), c.stopImmediatePropagation(), c.stopPropagation(), o.value.enabled && o.value.openMenu && !d.value.input && !t.isMenuOpen ? a("open") : o.value.enabled || a("toggle");
    }, le = () => {
      a("real-blur"), S.value = false, (!t.isMenuOpen || d.value.enabled && d.value.input) && a("blur"), t.autoApply && o.value.enabled && $.value && !t.isMenuOpen && (a("set-input-date", $.value), a("select-date"), $.value = null);
    }, f = () => {
      a("clear");
    }, w = (c) => {
      if (!o.value.enabled) {
        if (c.code === "Tab")
          return;
        c.preventDefault();
      }
    };
    return n({
      focusInput: () => {
        var c;
        (c = h2.value) == null || c.focus({ preventScroll: true });
      },
      setParsedDate: (c) => {
        $.value = c;
      }
    }), (c, V) => {
      var b;
      return openBlock(), createElementBlock("div", { onClick: j }, [
        c.$slots.trigger && !c.$slots["dp-input"] && !unref(d).enabled ? renderSlot(c.$slots, "trigger", { key: 0 }) : createCommentVNode("", true),
        !c.$slots.trigger && (!unref(d).enabled || unref(d).input) ? (openBlock(), createElementBlock("div", Xr, [
          c.$slots["dp-input"] && !c.$slots.trigger && !unref(d).enabled ? renderSlot(c.$slots, "dp-input", {
            key: 0,
            value: e.inputValue,
            isMenuOpen: e.isMenuOpen,
            onInput: I,
            onEnter: H,
            onTab: A,
            onClear: f,
            onBlur: le,
            onKeypress: w,
            onPaste: k
          }) : createCommentVNode("", true),
          c.$slots["dp-input"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("input", {
            key: 1,
            ref_key: "inputRef",
            ref: h2,
            id: c.uid ? `dp-input-${c.uid}` : void 0,
            name: c.name,
            class: normalizeClass(J.value),
            inputmode: unref(o).enabled ? "text" : "none",
            placeholder: c.placeholder,
            disabled: c.disabled,
            readonly: c.readonly,
            required: c.required,
            value: e.inputValue,
            autocomplete: c.autocomplete,
            "aria-label": (b = unref(l)) == null ? void 0 : b.input,
            "aria-disabled": c.disabled || void 0,
            "aria-invalid": c.state === false ? true : void 0,
            onInput: I,
            onKeydown: [
              withKeys(H, ["enter"]),
              withKeys(A, ["tab"]),
              w
            ],
            onBlur: le,
            onFocus: q,
            onKeypress: w,
            onPaste: k
          }, null, 42, xr)),
          createBaseVNode("div", {
            onClick: V[2] || (V[2] = (m) => a("toggle"))
          }, [
            c.$slots["input-icon"] && !c.hideInputIcon ? (openBlock(), createElementBlock("span", {
              key: 0,
              class: "dp__input_icon",
              onClick: V[0] || (V[0] = (m) => a("toggle"))
            }, [
              renderSlot(c.$slots, "input-icon")
            ])) : createCommentVNode("", true),
            !c.$slots["input-icon"] && !c.hideInputIcon && !c.$slots["dp-input"] ? (openBlock(), createBlock(unref(Yt), {
              key: 1,
              onClick: V[1] || (V[1] = (m) => a("toggle")),
              class: "dp__input_icon dp__input_icons"
            })) : createCommentVNode("", true)
          ]),
          c.$slots["clear-icon"] && e.inputValue && c.clearable && !c.disabled && !c.readonly ? (openBlock(), createElementBlock("span", Qr, [
            renderSlot(c.$slots, "clear-icon", { clear: f })
          ])) : createCommentVNode("", true),
          c.clearable && !c.$slots["clear-icon"] && e.inputValue && !c.disabled && !c.readonly ? (openBlock(), createBlock(unref(pa), {
            key: 3,
            class: "dp__clear_icon dp__input_icons",
            onClick: withModifiers(f, ["stop", "prevent"])
          }, null, 8, ["onClick"])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});
var tl = ["title"];
var nl = { class: "dp__action_buttons" };
var al = ["onKeydown", "disabled"];
var rl = defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "ActionRow",
  props: {
    menuMount: { type: Boolean, default: false },
    calendarWidth: { type: Number, default: 0 },
    ...Qe
  },
  emits: ["close-picker", "select-date", "select-now", "invalid-select"],
  setup(e, { emit: n }) {
    const a = e, {
      defaultedActionRow: t,
      defaultedPreviewFormat: o,
      defaultedMultiCalendars: l,
      defaultedTextInput: d,
      defaultedInline: M,
      getDefaultPattern: p
    } = Re(a), { isValidTime: $ } = Et(a), { buildMatrix: h2 } = lt(), S = ref(null), R = ref(null);
    onMounted(() => {
      a.arrowNavigation && h2([Ae(S), Ae(R)], "actionRow");
    });
    const J = computed(() => a.range && !a.partialRange && a.internalModelValue ? a.internalModelValue.length === 2 : true), W = computed(() => !Q.value || !Z.value || !J.value), Q = computed(() => !a.enableTimePicker || a.ignoreTimeValidation ? true : $(a.internalModelValue)), Z = computed(() => a.monthPicker ? a.range && Array.isArray(a.internalModelValue) ? !a.internalModelValue.filter((w) => !j(w)).length : j(a.internalModelValue) : true), k = () => {
      const f = o.value;
      return a.timePicker || a.monthPicker, f(Te(a.internalModelValue));
    }, T = () => {
      const f = a.internalModelValue;
      return l.value.count > 0 ? `${I(f[0])} - ${I(f[1])}` : [I(f[0]), I(f[1])];
    }, I = (f) => Pa(
      f,
      o.value,
      a.formatLocale,
      d.value.rangeSeparator,
      a.modelAuto,
      p()
    ), H = computed(() => !a.internalModelValue || !a.menuMount ? "" : typeof o.value == "string" ? Array.isArray(a.internalModelValue) ? a.internalModelValue.length === 2 && a.internalModelValue[1] ? T() : a.multiDates ? a.internalModelValue.map((f) => `${I(f)}`) : a.modelAuto ? `${I(a.internalModelValue[0])}` : `${I(a.internalModelValue[0])} -` : I(a.internalModelValue) : k()), A = () => a.multiDates ? "; " : " - ", q = computed(
      () => Array.isArray(H.value) ? H.value.join(A()) : H.value
    ), j = (f) => {
      if (!a.monthPicker)
        return true;
      let w = true;
      const C = P(ze(f));
      if (a.minDate && a.maxDate) {
        const K = P(ze(a.minDate)), c = P(ze(a.maxDate));
        return Ne(C, K) && Pe(C, c) || ye(C, K) || ye(C, c);
      }
      if (a.minDate) {
        const K = P(ze(a.minDate));
        w = Ne(C, K) || ye(C, K);
      }
      if (a.maxDate) {
        const K = P(ze(a.maxDate));
        w = Pe(C, K) || ye(C, K);
      }
      return w;
    }, le = () => {
      Q.value && Z.value && J.value ? n("select-date") : n("invalid-select");
    };
    return (f, w) => (openBlock(), createElementBlock("div", {
      class: "dp__action_row",
      style: normalizeStyle(e.calendarWidth ? { width: `${e.calendarWidth}px` } : {})
    }, [
      f.$slots["action-row"] ? renderSlot(f.$slots, "action-row", normalizeProps(mergeProps({ key: 0 }, {
        internalModelValue: f.internalModelValue,
        disabled: W.value,
        selectDate: () => f.$emit("select-date"),
        closePicker: () => f.$emit("close-picker")
      }))) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        unref(t).showPreview ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "dp__selection_preview",
          title: q.value
        }, [
          f.$slots["action-preview"] ? renderSlot(f.$slots, "action-preview", {
            key: 0,
            value: f.internalModelValue
          }) : createCommentVNode("", true),
          f.$slots["action-preview"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createTextVNode(toDisplayString(q.value), 1)
          ], 64))
        ], 8, tl)) : createCommentVNode("", true),
        createBaseVNode("div", nl, [
          f.$slots["action-buttons"] ? renderSlot(f.$slots, "action-buttons", {
            key: 0,
            value: f.internalModelValue
          }) : createCommentVNode("", true),
          f.$slots["action-buttons"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            !unref(M).enabled && unref(t).showCancel ? (openBlock(), createElementBlock("button", {
              key: 0,
              type: "button",
              ref_key: "cancelButtonRef",
              ref: S,
              class: "dp__action_button dp__action_cancel",
              onClick: w[0] || (w[0] = (C) => f.$emit("close-picker")),
              onKeydown: [
                w[1] || (w[1] = withKeys((C) => f.$emit("close-picker"), ["enter"])),
                w[2] || (w[2] = withKeys((C) => f.$emit("close-picker"), ["space"]))
              ]
            }, toDisplayString(f.cancelText), 545)) : createCommentVNode("", true),
            unref(t).showNow ? (openBlock(), createElementBlock("button", {
              key: 1,
              type: "button",
              ref_key: "cancelButtonRef",
              ref: S,
              class: "dp__action_button dp__action_cancel",
              onClick: w[3] || (w[3] = (C) => f.$emit("select-now")),
              onKeydown: [
                w[4] || (w[4] = withKeys((C) => f.$emit("select-now"), ["enter"])),
                w[5] || (w[5] = withKeys((C) => f.$emit("select-now"), ["space"]))
              ]
            }, toDisplayString(f.nowButtonLabel), 545)) : createCommentVNode("", true),
            unref(t).showSelect ? (openBlock(), createElementBlock("button", {
              key: 2,
              type: "button",
              class: "dp__action_button dp__action_select",
              onKeydown: [
                withKeys(le, ["enter"]),
                withKeys(le, ["space"])
              ],
              onClick: le,
              disabled: W.value,
              ref_key: "selectButtonRef",
              ref: R
            }, toDisplayString(f.selectText), 41, al)) : createCommentVNode("", true)
          ], 64))
        ])
      ], 64))
    ], 4));
  }
});
var ll = ["onKeydown"];
var ol = { class: "dp__selection_grid_header" };
var sl = ["aria-selected", "aria-disabled", "onClick", "onKeydown", "onMouseover"];
var ul = ["aria-label", "onKeydown"];
var Nt = defineComponent({
  __name: "SelectionOverlay",
  props: {
    items: {},
    type: {},
    isLast: { type: Boolean },
    arrowNavigation: { type: Boolean },
    skipButtonRef: { type: Boolean },
    headerRefs: {},
    hideNavigation: {},
    escClose: { type: Boolean },
    useRelative: { type: Boolean },
    height: {},
    textInput: { type: [Boolean, Object] }
  },
  emits: ["selected", "toggle", "reset-flow", "hover-value"],
  setup(e, { expose: n, emit: a }) {
    const t = e, { setSelectionGrid: o, buildMultiLevelMatrix: l, setMonthPicker: d } = lt(), { defaultedAriaLabels: M, defaultedTextInput: p } = Re(t), { hideNavigationButtons: $ } = Jt(), h2 = ref(false), S = ref(null), R = ref(null), J = ref([]), W = ref(), Q = ref(null), Z = ref(0), k = ref(null);
    onBeforeUpdate(() => {
      S.value = null;
    }), onMounted(() => {
      nextTick().then(() => f()), I(), T(true);
    }), onUnmounted(() => T(false));
    const T = (u) => {
      var y;
      t.arrowNavigation && ((y = t.headerRefs) != null && y.length ? d(u) : o(u));
    }, I = () => {
      var y;
      const u = Ae(R);
      u && (p.value.enabled || (S.value ? (y = S.value) == null || y.focus({ preventScroll: true }) : u.focus({ preventScroll: true })), h2.value = u.clientHeight < u.scrollHeight);
    }, H = computed(
      () => ({
        dp__overlay: true,
        "dp--overlay-absolute": !t.useRelative,
        "dp--overlay-relative": t.useRelative
      })
    ), A = computed(
      () => t.useRelative ? { height: `${t.height}px`, width: "260px" } : void 0
    ), q = computed(() => ({
      dp__overlay_col: true
    })), j = computed(
      () => ({
        dp__btn: true,
        dp__button: true,
        dp__overlay_action: true,
        dp__over_action_scroll: h2.value,
        dp__button_bottom: t.isLast
      })
    ), le = computed(() => {
      var u, y;
      return {
        dp__overlay_container: true,
        dp__container_flex: ((u = t.items) == null ? void 0 : u.length) <= 6,
        dp__container_block: ((y = t.items) == null ? void 0 : y.length) > 6
      };
    }), f = () => {
      nextTick().then(() => {
        const u = Ae(S), y = Ae(R), s = Ae(Q), _ = Ae(k), ee = s ? s.getBoundingClientRect().height : 0;
        y && (Z.value = y.getBoundingClientRect().height - ee), u && _ && (_.scrollTop = u.offsetTop - _.offsetTop - (Z.value / 2 - u.getBoundingClientRect().height) - ee);
      });
    }, w = (u) => {
      u.disabled || a("selected", u.value);
    }, C = () => {
      a("toggle"), a("reset-flow");
    }, K = () => {
      t.escClose && C();
    }, c = (u, y, s, _) => {
      u && (y.active && (S.value = u), t.arrowNavigation && (Array.isArray(J.value[s]) ? J.value[s][_] = u : J.value[s] = [u], V()));
    }, V = () => {
      var y, s;
      const u = (y = t.headerRefs) != null && y.length ? [t.headerRefs].concat(J.value) : J.value.concat([t.skipButtonRef ? [] : [Q.value]]);
      l(Te(u), (s = t.headerRefs) != null && s.length ? "monthPicker" : "selectionGrid");
    }, b = (u) => {
      t.arrowNavigation || u.stopImmediatePropagation();
    }, m = (u) => {
      W.value = u, a("hover-value", u);
    };
    return n({ focusGrid: I }), (u, y) => {
      var s;
      return openBlock(), createElementBlock("div", {
        ref_key: "gridWrapRef",
        ref: R,
        class: normalizeClass(H.value),
        style: normalizeStyle(A.value),
        role: "dialog",
        tabindex: "0",
        onKeydown: [
          withKeys(withModifiers(K, ["prevent"]), ["esc"]),
          y[0] || (y[0] = withKeys(withModifiers((_) => b(_), ["prevent"]), ["left"])),
          y[1] || (y[1] = withKeys(withModifiers((_) => b(_), ["prevent"]), ["up"])),
          y[2] || (y[2] = withKeys(withModifiers((_) => b(_), ["prevent"]), ["down"])),
          y[3] || (y[3] = withKeys(withModifiers((_) => b(_), ["prevent"]), ["right"]))
        ]
      }, [
        createBaseVNode("div", {
          class: normalizeClass(le.value),
          ref_key: "containerRef",
          ref: k,
          role: "grid",
          style: normalizeStyle({ height: `${Z.value}px` })
        }, [
          createBaseVNode("div", ol, [
            renderSlot(u.$slots, "header")
          ]),
          u.$slots.overlay ? renderSlot(u.$slots, "overlay", { key: 0 }) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(u.items, (_, ee) => (openBlock(), createElementBlock("div", {
            class: normalizeClass(["dp__overlay_row", { dp__flex_row: u.items.length >= 3 }]),
            key: ee,
            role: "row"
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_, (r, U) => (openBlock(), createElementBlock("div", {
              role: "gridcell",
              class: normalizeClass(q.value),
              key: r.value,
              "aria-selected": r.active,
              "aria-disabled": r.disabled || void 0,
              ref_for: true,
              ref: (N) => c(N, r, ee, U),
              tabindex: "0",
              onClick: (N) => w(r),
              onKeydown: [
                withKeys(withModifiers((N) => w(r), ["prevent"]), ["enter"]),
                withKeys(withModifiers((N) => w(r), ["prevent"]), ["space"])
              ],
              onMouseover: (N) => m(r.value)
            }, [
              createBaseVNode("div", {
                class: normalizeClass(r.className)
              }, [
                u.$slots.item ? renderSlot(u.$slots, "item", {
                  key: 0,
                  item: r
                }) : createCommentVNode("", true),
                u.$slots.item ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createTextVNode(toDisplayString(r.text), 1)
                ], 64))
              ], 2)
            ], 42, sl))), 128))
          ], 2))), 128))
        ], 6),
        u.$slots["button-icon"] ? withDirectives((openBlock(), createElementBlock("button", {
          key: 0,
          type: "button",
          "aria-label": (s = unref(M)) == null ? void 0 : s.toggleOverlay,
          class: normalizeClass(j.value),
          tabindex: "0",
          ref_key: "toggleButton",
          ref: Q,
          onClick: C,
          onKeydown: [
            withKeys(C, ["enter"]),
            withKeys(C, ["tab"])
          ]
        }, [
          renderSlot(u.$slots, "button-icon")
        ], 42, ul)), [
          [vShow, !unref($)(u.hideNavigation, u.type)]
        ]) : createCommentVNode("", true)
      ], 46, ll);
    };
  }
});
var Ln = defineComponent({
  __name: "InstanceWrap",
  props: {
    multiCalendars: {},
    stretch: { type: Boolean }
  },
  setup(e) {
    const n = e, a = computed(
      () => n.multiCalendars > 0 ? [...Array(n.multiCalendars).keys()] : [0]
    ), t = computed(() => ({
      dp__instance_calendar: n.multiCalendars > 0
    }));
    return (o, l) => (openBlock(), createElementBlock("div", {
      class: normalizeClass({
        dp__menu_inner: !o.stretch,
        "dp--menu--inner-stretched": o.stretch,
        dp__flex_display: o.multiCalendars > 0
      })
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(a.value, (d, M) => (openBlock(), createElementBlock("div", {
        key: d,
        class: normalizeClass(t.value)
      }, [
        renderSlot(o.$slots, "default", {
          instance: d,
          index: M
        })
      ], 2))), 128))
    ], 2));
  }
});
var il = ["aria-label", "aria-disabled"];
var St = defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "ArrowBtn",
  props: {
    ariaLabel: {},
    disabled: { type: Boolean }
  },
  emits: ["activate", "set-ref"],
  setup(e, { emit: n }) {
    const a = ref(null);
    return onMounted(() => n("set-ref", a)), (t, o) => (openBlock(), createElementBlock("button", {
      type: "button",
      class: "dp__btn dp--arrow-btn-nav",
      onClick: o[0] || (o[0] = (l) => t.$emit("activate")),
      onKeydown: [
        o[1] || (o[1] = withKeys(withModifiers((l) => t.$emit("activate"), ["prevent"]), ["enter"])),
        o[2] || (o[2] = withKeys(withModifiers((l) => t.$emit("activate"), ["prevent"]), ["space"]))
      ],
      tabindex: "0",
      "aria-label": t.ariaLabel,
      "aria-disabled": t.disabled || void 0,
      ref_key: "elRef",
      ref: a
    }, [
      createBaseVNode("span", {
        class: normalizeClass(["dp__inner_nav", { dp__inner_nav_disabled: t.disabled }])
      }, [
        renderSlot(t.$slots, "default")
      ], 2)
    ], 40, il));
  }
});
var Un = (e, n, a) => {
  if (n.value && Array.isArray(n.value))
    if (n.value.some((t) => ye(e, t))) {
      const t = n.value.filter((o) => !ye(o, e));
      n.value = t.length ? t : null;
    } else
      (a && +a > n.value.length || !a) && n.value.push(e);
  else
    n.value = [e];
};
var Ra = (e, n, a) => {
  let t = e.value ? e.value.slice() : [];
  return t.length === 2 && t[1] !== null && (t = []), t.length ? Pe(n, t[0]) ? (t.unshift(n), a("range-start", t[0]), a("range-start", t[1])) : (t[1] = n, a("range-end", n)) : (t = [n], a("range-start", n)), e.value = t, t;
};
var Wn = (e, n, a, t) => {
  e[0] && e[1] && a && n("auto-apply"), e[0] && !e[1] && t && a && n("auto-apply");
};
var dl = (e, n) => {
  const { defaultedMultiCalendars: a, defaultedAriaLabels: t, defaultedTransitions: o } = Re(e), { modelValue: l, year: d, month: M, calendars: p } = qt(e, n), $ = computed(() => Da(e.formatLocale, e.locale, e.monthNameFormat)), h2 = computed(() => Vn(e.yearRange, e.reverseYears)), S = ref(null), R = () => {
    for (let b = 0; b < a.value.count; b++)
      if (b === 0)
        p.value[b] = p.value[0];
      else {
        const m = set(P(), p.value[b - 1]);
        p.value[b] = { month: getMonth(m), year: getYear(addYears(m, b)) };
      }
  }, J = (b) => {
    if (!b)
      return R();
    const m = set(P(), p.value[b]);
    return p.value[0].year = getYear(subYears(m, a.value.count - 1)), R();
  }, W = (b) => e.focusStartDate ? b[0] : b[1] ? b[1] : b[0], Q = () => {
    if (l.value) {
      const b = Array.isArray(l.value) ? W(l.value) : l.value;
      p.value[0] = { month: getMonth(b), year: getYear(b) };
    }
  };
  onMounted(() => {
    Q(), a.value.count && R();
  });
  const Z = computed(() => (b, m) => {
    const u = set(ze(/* @__PURE__ */ new Date()), {
      month: M.value(b),
      year: d.value(b)
    });
    return _a(u, e.maxDate, e.minDate, e.preventMinMaxNavigation, m);
  }), k = (b) => b ? { month: getMonth(b), year: getYear(b) } : { month: null, year: null }, T = () => l.value ? Array.isArray(l.value) ? l.value.map((b) => k(b)) : k(l.value) : k(), I = (b, m) => {
    const u = p.value[b], y = T();
    return Array.isArray(y) ? y.some((s) => s.year === (u == null ? void 0 : u.year) && s.month === m) : (u == null ? void 0 : u.year) === y.year && m === y.month;
  }, H = (b, m, u) => {
    var s, _;
    const y = T();
    return Array.isArray(y) ? d.value(m) === ((s = y[u]) == null ? void 0 : s.year) && b === ((_ = y[u]) == null ? void 0 : _.month) : false;
  }, A = (b, m) => {
    if (e.range) {
      const u = T();
      if (Array.isArray(l.value) && Array.isArray(u)) {
        const y = H(b, m, 0) || H(b, m, 1), s = xe(ze(P()), b, d.value(m));
        return Hn(l.value, S.value, s) && !y;
      }
      return false;
    }
    return false;
  }, q = computed(() => (b) => kt($.value, (m) => {
    const u = I(b, m.value), y = Rt(
      m.value,
      $a(d.value(b), e.minDate),
      Ta(d.value(b), e.maxDate)
    ) || Yr(e.disabledDates, d.value(b)).includes(m.value), s = A(m.value, b);
    return { active: u, disabled: y, isBetween: s };
  })), j = computed(() => (b) => kt(h2.value, (m) => {
    const u = d.value(b) === m.value, y = Rt(m.value, wt(e.minDate), wt(e.maxDate));
    return { active: u, disabled: y };
  })), le = (b, m) => xe(ze(P()), b, d.value(m)), f = (b, m) => {
    const u = l.value ? l.value : ze(/* @__PURE__ */ new Date());
    l.value = xe(u, b, d.value(m)), n("auto-apply");
  }, w = (b, m) => {
    const u = Ra(l, le(b, m), n);
    Wn(u, n, e.autoApply, e.modelAuto);
  }, C = (b, m) => {
    Un(le(b, m), l, e.multiDatesLimit), n("auto-apply", true);
  };
  return {
    groupedMonths: q,
    groupedYears: j,
    year: d,
    isDisabled: Z,
    defaultedMultiCalendars: a,
    defaultedAriaLabels: t,
    defaultedTransitions: o,
    setHoverDate: (b, m) => {
      S.value = le(b, m);
    },
    selectMonth: (b, m) => (p.value[m].month = b, e.multiDates ? C(b, m) : e.range ? w(b, m) : f(b, m)),
    selectYear: (b, m) => {
      p.value[m].year = b, a.value.count && !a.value.solo && J(m);
    }
  };
};
var cl = { class: "dp__month_picker_header" };
var fl = ["aria-label", "onClick", "onKeydown"];
var vl = defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "MonthPicker",
  props: {
    ...Qe
  },
  emits: [
    "update:internal-model-value",
    "overlay-closed",
    "reset-flow",
    "range-start",
    "range-end",
    "auto-apply"
  ],
  setup(e, { emit: n }) {
    const a = e, {
      groupedMonths: t,
      groupedYears: o,
      year: l,
      isDisabled: d,
      defaultedMultiCalendars: M,
      defaultedAriaLabels: p,
      defaultedTransitions: $,
      setHoverDate: h2,
      selectMonth: S,
      selectYear: R
    } = dl(a, n), { transitionName: J, showTransition: W } = Bt($), { showRightIcon: Q, showLeftIcon: Z } = Jt(), k = ref([false]), T = (A, q) => {
      R(A, q), H(q);
    }, I = (A, q = false) => {
      if (!d.value(A, q)) {
        const j = q ? l.value(A) + 1 : l.value(A) - 1;
        R(j, A);
      }
    }, H = (A, q = false, j) => {
      q || n("reset-flow"), j !== void 0 ? k.value[A] = j : k.value[A] = !k.value[A], k.value || n("overlay-closed");
    };
    return (A, q) => (openBlock(), createBlock(Ln, {
      "multi-calendars": unref(M).count,
      stretch: ""
    }, {
      default: withCtx(({ instance: j }) => [
        A.$slots["month-year"] ? renderSlot(A.$slots, "month-year", normalizeProps(mergeProps({ key: 0 }, {
          year: unref(l),
          months: unref(t)(j),
          years: unref(o)(j),
          selectMonth: unref(S),
          selectYear: unref(R),
          instance: j
        }))) : (openBlock(), createBlock(Nt, {
          key: 1,
          items: unref(t)(j),
          "arrow-navigation": A.arrowNavigation,
          "is-last": A.autoApply && !A.keepActionRow,
          "esc-close": A.escClose,
          height: A.modeHeight,
          onSelected: (le) => unref(S)(le, j),
          onHoverValue: (le) => unref(h2)(le, j),
          "use-relative": "",
          type: "month"
        }, {
          header: withCtx(() => {
            var le, f, w;
            return [
              createBaseVNode("div", cl, [
                unref(Z)(unref(M), j) ? (openBlock(), createBlock(St, {
                  key: 0,
                  ref: "mpPrevIconRef",
                  "aria-label": (le = unref(p)) == null ? void 0 : le.prevYear,
                  disabled: unref(d)(j, false),
                  onActivate: (C) => I(j, false)
                }, {
                  default: withCtx(() => [
                    A.$slots["arrow-left"] ? renderSlot(A.$slots, "arrow-left", { key: 0 }) : createCommentVNode("", true),
                    A.$slots["arrow-left"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Rn), { key: 1 }))
                  ]),
                  _: 2
                }, 1032, ["aria-label", "disabled", "onActivate"])) : createCommentVNode("", true),
                createBaseVNode("div", {
                  class: "dp--year-select",
                  role: "button",
                  ref: "mpYearButtonRef",
                  "aria-label": (f = unref(p)) == null ? void 0 : f.openYearsOverlay,
                  tabindex: "0",
                  onClick: () => H(j, false),
                  onKeydown: withKeys(() => H(j, false), ["enter"])
                }, [
                  A.$slots.year ? renderSlot(A.$slots, "year", {
                    key: 0,
                    year: unref(l)(j)
                  }) : createCommentVNode("", true),
                  A.$slots.year ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createTextVNode(toDisplayString(unref(l)(j)), 1)
                  ], 64))
                ], 40, fl),
                unref(Q)(unref(M), j) ? (openBlock(), createBlock(St, {
                  key: 1,
                  ref: "mpNextIconRef",
                  "aria-label": (w = unref(p)) == null ? void 0 : w.nextYear,
                  disabled: unref(d)(j, false),
                  onActivate: (C) => I(j, true)
                }, {
                  default: withCtx(() => [
                    A.$slots["arrow-right"] ? renderSlot(A.$slots, "arrow-right", { key: 0 }) : createCommentVNode("", true),
                    A.$slots["arrow-right"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Nn), { key: 1 }))
                  ]),
                  _: 2
                }, 1032, ["aria-label", "disabled", "onActivate"])) : createCommentVNode("", true),
                createVNode(Transition, {
                  name: unref(J)(k.value[j]),
                  css: unref(W)
                }, {
                  default: withCtx(() => [
                    k.value[j] ? (openBlock(), createBlock(Nt, {
                      key: 0,
                      items: unref(o)(j),
                      "text-input": A.textInput,
                      "esc-close": A.escClose,
                      onToggle: (C) => H(j),
                      onSelected: (C) => T(C, j),
                      "is-last": A.autoApply && !A.keepActionRow,
                      type: "year"
                    }, createSlots({
                      "button-icon": withCtx(() => [
                        A.$slots["calendar-icon"] ? renderSlot(A.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true),
                        A.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Yt), { key: 1 }))
                      ]),
                      _: 2
                    }, [
                      A.$slots["year-overlay-value"] ? {
                        name: "item",
                        fn: withCtx(({ item: C }) => [
                          renderSlot(A.$slots, "year-overlay-value", {
                            text: C.text,
                            value: C.value
                          })
                        ]),
                        key: "0"
                      } : void 0
                    ]), 1032, ["items", "text-input", "esc-close", "onToggle", "onSelected", "is-last"])) : createCommentVNode("", true)
                  ]),
                  _: 2
                }, 1032, ["name", "css"])
              ])
            ];
          }),
          _: 2
        }, 1032, ["items", "arrow-navigation", "is-last", "esc-close", "height", "onSelected", "onHoverValue"]))
      ]),
      _: 3
    }, 8, ["multi-calendars"]));
  }
});
var ml = (e, n) => {
  const { modelValue: a } = qt(e, n), t = ref(null), o = (h2) => Array.isArray(a.value) ? a.value.some((S) => getYear(S) === h2) : a.value ? getYear(a.value) === h2 : false, l = (h2) => e.range && Array.isArray(a.value) ? Hn(a.value, t.value, M(h2)) : false, d = computed(() => kt(Vn(e.yearRange, e.reverseYears), (h2) => {
    const S = o(h2.value), R = Rt(h2.value, wt(e.minDate), wt(e.maxDate)), J = l(h2.value);
    return { active: S, disabled: R, isBetween: J };
  })), M = (h2) => setYear(ze(/* @__PURE__ */ new Date()), h2);
  return {
    groupedYears: d,
    setHoverValue: (h2) => {
      t.value = setYear(ze(/* @__PURE__ */ new Date()), h2);
    },
    selectYear: (h2) => {
      if (e.multiDates)
        return Un(M(h2), a, e.multiDatesLimit), n("auto-apply", true);
      if (e.range) {
        const S = Ra(a, M(h2), n);
        return Wn(S, n, e.autoApply, e.modelAuto);
      }
      a.value = M(h2), n("auto-apply");
    }
  };
};
var gl = defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "YearPicker",
  props: {
    ...Qe
  },
  emits: ["update:internal-model-value", "reset-flow", "range-start", "range-end", "auto-apply"],
  setup(e, { emit: n }) {
    const a = e, { groupedYears: t, selectYear: o, setHoverValue: l } = ml(a, n);
    return (d, M) => (openBlock(), createElementBlock("div", null, [
      d.$slots["month-year"] ? renderSlot(d.$slots, "month-year", normalizeProps(mergeProps({ key: 0 }, {
        years: unref(t),
        selectYear: unref(o)
      }))) : (openBlock(), createBlock(Nt, {
        key: 1,
        items: unref(t),
        "is-last": d.autoApply && !d.keepActionRow,
        height: d.modeHeight,
        type: "year",
        "use-relative": "",
        onSelected: unref(o),
        onHoverValue: unref(l)
      }, createSlots({ _: 2 }, [
        d.$slots["year-overlay-value"] ? {
          name: "item",
          fn: withCtx(({ item: p }) => [
            renderSlot(d.$slots, "year-overlay-value", {
              text: p.text,
              value: p.value
            })
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["items", "is-last", "height", "onSelected", "onHoverValue"]))
    ]));
  }
});
var yl = {
  key: 0,
  class: "dp__time_input"
};
var hl = ["aria-label", "onKeydown", "onClick"];
var pl = createBaseVNode("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_l" }, null, -1);
var bl = createBaseVNode("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_r" }, null, -1);
var kl = ["aria-label", "disabled", "onKeydown", "onClick"];
var wl = ["aria-label", "onKeydown", "onClick"];
var Dl = createBaseVNode("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_l" }, null, -1);
var Ml = createBaseVNode("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_r" }, null, -1);
var $l = { key: 0 };
var Tl = ["aria-label", "onKeydown"];
var Al = defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "TimeInput",
  props: {
    hours: { type: Number, default: 0 },
    minutes: { type: Number, default: 0 },
    seconds: { type: Number, default: 0 },
    closeTimePickerBtn: { type: Object, default: null },
    order: { type: Number, default: 0 },
    disabledTimesConfig: { type: Function, default: null },
    ...Qe
  },
  emits: [
    "set-hours",
    "set-minutes",
    "update:hours",
    "update:minutes",
    "update:seconds",
    "reset-flow",
    "mounted",
    "overlay-closed",
    "am-pm-change"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, { setTimePickerElements: o, setTimePickerBackRef: l } = lt(), { defaultedAriaLabels: d, defaultedTransitions: M, defaultedFilters: p } = Re(t), { transitionName: $, showTransition: h2 } = Bt(M), S = reactive({
      hours: false,
      minutes: false,
      seconds: false
    }), R = ref("AM"), J = ref(null), W = ref([]);
    onMounted(() => {
      a("mounted");
    });
    const Q = (r) => set(/* @__PURE__ */ new Date(), {
      hours: r.hours,
      minutes: r.minutes,
      seconds: t.enableSeconds ? r.seconds : 0,
      milliseconds: 0
    }), Z = computed(() => (r) => w(r, t[r])), k = computed(() => ({ hours: t.hours, minutes: t.minutes, seconds: t.seconds })), T = computed(() => (r) => !K(+t[r] + +t[`${r}Increment`], r)), I = computed(() => (r) => !K(+t[r] - +t[`${r}Increment`], r)), H = (r, U) => add(set(P(), r), U), A = (r, U) => sub(set(P(), r), U), q = computed(
      () => ({
        dp__time_col: true,
        dp__time_col_block: !t.timePickerInline,
        dp__time_col_reg_block: !t.enableSeconds && t.is24 && !t.timePickerInline,
        dp__time_col_reg_inline: !t.enableSeconds && t.is24 && t.timePickerInline,
        dp__time_col_reg_with_button: !t.enableSeconds && !t.is24,
        dp__time_col_sec: t.enableSeconds && t.is24,
        dp__time_col_sec_with_button: t.enableSeconds && !t.is24
      })
    ), j = computed(() => {
      const r = [{ type: "hours" }, { type: "", separator: true }, { type: "minutes" }];
      return t.enableSeconds ? r.concat([{ type: "", separator: true }, { type: "seconds" }]) : r;
    }), le = computed(() => j.value.filter((r) => !r.separator)), f = computed(() => (r) => {
      if (r === "hours") {
        const U = u(+t.hours);
        return { text: U < 10 ? `0${U}` : `${U}`, value: U };
      }
      return { text: t[r] < 10 ? `0${t[r]}` : `${t[r]}`, value: t[r] };
    }), w = (r, U) => {
      var g;
      if (!t.disabledTimesConfig)
        return false;
      const N = t.disabledTimesConfig(t.order, r === "hours" ? U : void 0);
      return N[r] ? !!((g = N[r]) != null && g.includes(U)) : true;
    }, C = (r) => {
      const U = t.is24 ? 24 : 12, N = r === "hours" ? U : 60, g = +t[`${r}GridIncrement`], F = r === "hours" && !t.is24 ? g : 0, ae = [];
      for (let G = F; G < N; G += g)
        ae.push({ value: G, text: G < 10 ? `0${G}` : `${G}` });
      return r === "hours" && !t.is24 && ae.push({ value: 0, text: "12" }), kt(ae, (G) => ({ active: false, disabled: p.value.times[r].includes(G.value) || !K(G.value, r) || w(r, G.value) }));
    }, K = (r, U) => {
      const N = t.minTime ? Q(fn(t.minTime)) : null, g = t.maxTime ? Q(fn(t.maxTime)) : null, F = Q(fn(k.value, U, r));
      return N && g ? (isBefore(F, g) || isEqual(F, g)) && (isAfter(F, N) || isEqual(F, N)) : N ? isAfter(F, N) || isEqual(F, N) : g ? isBefore(F, g) || isEqual(F, g) : true;
    }, c = (r) => t[`no${r[0].toUpperCase() + r.slice(1)}Overlay`], V = (r) => {
      c(r) || (S[r] = !S[r], S[r] || a("overlay-closed"));
    }, b = (r) => r === "hours" ? getHours : r === "minutes" ? getMinutes : getSeconds, m = (r, U = true) => {
      const N = U ? H : A, g = U ? +t[`${r}Increment`] : -+t[`${r}Increment`];
      K(+t[r] + g, r) && a(
        `update:${r}`,
        b(r)(N({ [r]: +t[r] }, { [r]: +t[`${r}Increment`] }))
      );
    }, u = (r) => t.is24 ? r : (r >= 12 ? R.value = "PM" : R.value = "AM", $r(r)), y = () => {
      R.value === "PM" ? (R.value = "AM", a("update:hours", t.hours - 12)) : (R.value = "PM", a("update:hours", t.hours + 12)), a("am-pm-change", R.value);
    }, s = (r) => {
      S[r] = true;
    }, _ = (r, U, N) => {
      if (r && t.arrowNavigation) {
        Array.isArray(W.value[U]) ? W.value[U][N] = r : W.value[U] = [r];
        const g = W.value.reduce(
          (F, ae) => ae.map((G, we) => [...F[we] || [], ae[we]]),
          []
        );
        l(t.closeTimePickerBtn), J.value && (g[1] = g[1].concat(J.value)), o(g, t.order);
      }
    }, ee = (r, U) => (V(r), r === "hours" && !t.is24 ? a(`update:${r}`, R.value === "PM" ? U + 12 : U) : a(`update:${r}`, U));
    return n({ openChildCmp: s }), (r, U) => {
      var N;
      return r.disabled ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", yl, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(j.value, (g, F) => {
          var ae, G, we;
          return openBlock(), createElementBlock("div", {
            key: F,
            class: normalizeClass(q.value)
          }, [
            g.separator ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createTextVNode(" : ")
            ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createBaseVNode("button", {
                type: "button",
                class: normalizeClass({
                  dp__btn: true,
                  dp__inc_dec_button: !t.timePickerInline,
                  dp__inc_dec_button_inline: t.timePickerInline,
                  dp__tp_inline_btn_top: t.timePickerInline,
                  dp__inc_dec_button_disabled: T.value(g.type)
                }),
                "aria-label": (ae = unref(d)) == null ? void 0 : ae.incrementValue(g.type),
                tabindex: "0",
                onKeydown: [
                  withKeys(withModifiers((se) => m(g.type), ["prevent"]), ["enter"]),
                  withKeys(withModifiers((se) => m(g.type), ["prevent"]), ["space"])
                ],
                onClick: (se) => m(g.type),
                ref_for: true,
                ref: (se) => _(se, F, 0)
              }, [
                t.timePickerInline ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  pl,
                  bl
                ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  r.$slots["arrow-up"] ? renderSlot(r.$slots, "arrow-up", { key: 0 }) : createCommentVNode("", true),
                  r.$slots["arrow-up"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(In), { key: 1 }))
                ], 64))
              ], 42, hl),
              createBaseVNode("button", {
                type: "button",
                "aria-label": (G = unref(d)) == null ? void 0 : G.openTpOverlay(g.type),
                class: normalizeClass({
                  dp__time_display: true,
                  dp__time_display_block: !t.timePickerInline,
                  dp__time_display_inline: t.timePickerInline,
                  "dp--time-invalid": Z.value(g.type),
                  "dp--time-overlay-btn": !Z.value(g.type)
                }),
                disabled: c(g.type),
                tabindex: "0",
                onKeydown: [
                  withKeys(withModifiers((se) => V(g.type), ["prevent"]), ["enter"]),
                  withKeys(withModifiers((se) => V(g.type), ["prevent"]), ["space"])
                ],
                onClick: (se) => V(g.type),
                ref_for: true,
                ref: (se) => _(se, F, 1)
              }, [
                r.$slots[g.type] ? renderSlot(r.$slots, g.type, {
                  key: 0,
                  text: f.value(g.type).text,
                  value: f.value(g.type).value
                }) : createCommentVNode("", true),
                r.$slots[g.type] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createTextVNode(toDisplayString(f.value(g.type).text), 1)
                ], 64))
              ], 42, kl),
              createBaseVNode("button", {
                type: "button",
                class: normalizeClass({
                  dp__btn: true,
                  dp__inc_dec_button: !t.timePickerInline,
                  dp__inc_dec_button_inline: t.timePickerInline,
                  dp__tp_inline_btn_bottom: t.timePickerInline,
                  dp__inc_dec_button_disabled: I.value(g.type)
                }),
                "aria-label": (we = unref(d)) == null ? void 0 : we.decrementValue(g.type),
                tabindex: "0",
                onKeydown: [
                  withKeys(withModifiers((se) => m(g.type, false), ["prevent"]), ["enter"]),
                  withKeys(withModifiers((se) => m(g.type, false), ["prevent"]), ["space"])
                ],
                onClick: (se) => m(g.type, false),
                ref_for: true,
                ref: (se) => _(se, F, 2)
              }, [
                t.timePickerInline ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  Dl,
                  Ml
                ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  r.$slots["arrow-down"] ? renderSlot(r.$slots, "arrow-down", { key: 0 }) : createCommentVNode("", true),
                  r.$slots["arrow-down"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Yn), { key: 1 }))
                ], 64))
              ], 42, wl)
            ], 64))
          ], 2);
        }), 128)),
        r.is24 ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", $l, [
          r.$slots["am-pm-button"] ? renderSlot(r.$slots, "am-pm-button", {
            key: 0,
            toggle: y,
            value: R.value
          }) : createCommentVNode("", true),
          r.$slots["am-pm-button"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("button", {
            key: 1,
            ref_key: "amPmButton",
            ref: J,
            type: "button",
            class: "dp__pm_am_button",
            role: "button",
            "aria-label": (N = unref(d)) == null ? void 0 : N.amPmButton,
            tabindex: "0",
            onClick: y,
            onKeydown: [
              withKeys(withModifiers(y, ["prevent"]), ["enter"]),
              withKeys(withModifiers(y, ["prevent"]), ["space"])
            ]
          }, toDisplayString(R.value), 41, Tl))
        ])),
        (openBlock(true), createElementBlock(Fragment, null, renderList(le.value, (g, F) => (openBlock(), createBlock(Transition, {
          key: F,
          name: unref($)(S[g.type]),
          css: unref(h2)
        }, {
          default: withCtx(() => [
            S[g.type] ? (openBlock(), createBlock(Nt, {
              key: 0,
              items: C(g.type),
              "is-last": r.autoApply && !r.keepActionRow,
              "esc-close": r.escClose,
              type: g.type,
              "text-input": r.textInput,
              "arrow-navigation": r.arrowNavigation,
              onSelected: (ae) => ee(g.type, ae),
              onToggle: (ae) => V(g.type),
              onResetFlow: U[0] || (U[0] = (ae) => r.$emit("reset-flow"))
            }, createSlots({
              "button-icon": withCtx(() => [
                r.$slots["clock-icon"] ? renderSlot(r.$slots, "clock-icon", { key: 0 }) : createCommentVNode("", true),
                r.$slots["clock-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(On), { key: 1 }))
              ]),
              _: 2
            }, [
              r.$slots[`${g.type}-overlay-value`] ? {
                name: "item",
                fn: withCtx(({ item: ae }) => [
                  renderSlot(r.$slots, `${g.type}-overlay-value`, {
                    text: ae.text,
                    value: ae.value
                  })
                ]),
                key: "0"
              } : void 0
            ]), 1032, ["items", "is-last", "esc-close", "type", "text-input", "arrow-navigation", "onSelected", "onToggle"])) : createCommentVNode("", true)
          ]),
          _: 2
        }, 1032, ["name", "css"]))), 128))
      ]));
    };
  }
});
var Sl = ["aria-label"];
var _l = ["tabindex"];
var Pl = ["aria-label"];
var Na = defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "TimePicker",
  props: {
    hours: { type: [Number, Array], default: 0 },
    minutes: { type: [Number, Array], default: 0 },
    seconds: { type: [Number, Array], default: 0 },
    disabledTimesConfig: { type: Function, default: null },
    ...Qe
  },
  emits: [
    "update:hours",
    "update:minutes",
    "update:seconds",
    "mount",
    "reset-flow",
    "overlay-opened",
    "overlay-closed",
    "am-pm-change"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, { buildMatrix: o, setTimePicker: l } = lt(), d = useSlots(), { defaultedTransitions: M, defaultedAriaLabels: p, defaultedTextInput: $ } = Re(t), { transitionName: h2, showTransition: S } = Bt(M), { hideNavigationButtons: R } = Jt(), J = ref(null), W = ref(null), Q = ref([]), Z = ref(null);
    onMounted(() => {
      a("mount"), !t.timePicker && t.arrowNavigation ? o([Ae(J.value)], "time") : l(true, t.timePicker);
    });
    const k = computed(() => t.range && t.modelAuto ? Ma(t.internalModelValue) : true), T = ref(false), I = (c) => ({
      hours: Array.isArray(t.hours) ? t.hours[c] : t.hours,
      minutes: Array.isArray(t.minutes) ? t.minutes[c] : t.minutes,
      seconds: Array.isArray(t.seconds) ? t.seconds[c] : t.seconds
    }), H = computed(() => {
      const c = [];
      if (t.range)
        for (let V = 0; V < 2; V++)
          c.push(I(V));
      else
        c.push(I(0));
      return c;
    }), A = (c, V = false, b = "") => {
      V || a("reset-flow"), T.value = c, a(c ? "overlay-opened" : "overlay-closed"), t.arrowNavigation && l(c), nextTick(() => {
        b !== "" && Q.value[0] && Q.value[0].openChildCmp(b);
      });
    }, q = computed(() => ({
      dp__btn: true,
      dp__button: true,
      dp__button_bottom: t.autoApply && !t.keepActionRow
    })), j = je(d, "timePicker"), le = (c, V, b) => t.range ? V === 0 ? [c, H.value[1][b]] : [H.value[0][b], c] : c, f = (c) => {
      a("update:hours", c);
    }, w = (c) => {
      a("update:minutes", c);
    }, C = (c) => {
      a("update:seconds", c);
    }, K = () => {
      if (Z.value && !$.value.enabled) {
        const c = Ar(Z.value);
        c && c.focus({ preventScroll: true });
      }
    };
    return n({ toggleTimePicker: A }), (c, V) => {
      var b;
      return openBlock(), createElementBlock("div", null, [
        !c.timePicker && !c.timePickerInline ? withDirectives((openBlock(), createElementBlock("button", {
          key: 0,
          type: "button",
          class: normalizeClass(q.value),
          "aria-label": (b = unref(p)) == null ? void 0 : b.openTimePicker,
          tabindex: "0",
          ref_key: "openTimePickerBtn",
          ref: J,
          onKeydown: [
            V[0] || (V[0] = withKeys((m) => A(true), ["enter"])),
            V[1] || (V[1] = withKeys((m) => A(true), ["space"]))
          ],
          onClick: V[2] || (V[2] = (m) => A(true))
        }, [
          c.$slots["clock-icon"] ? renderSlot(c.$slots, "clock-icon", { key: 0 }) : createCommentVNode("", true),
          c.$slots["clock-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(On), { key: 1 }))
        ], 42, Sl)), [
          [vShow, !unref(R)(c.hideNavigation, "time")]
        ]) : createCommentVNode("", true),
        createVNode(Transition, {
          name: unref(h2)(T.value),
          css: unref(S) && !c.timePickerInline
        }, {
          default: withCtx(() => {
            var m;
            return [
              T.value || c.timePicker || c.timePickerInline ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass({
                  dp__overlay: !c.timePickerInline,
                  "dp--overlay-absolute": !t.timePicker && !c.timePickerInline,
                  "dp--overlay-relative": t.timePicker
                }),
                style: normalizeStyle(c.timePicker ? { height: `${c.modeHeight}px` } : void 0),
                ref_key: "overlayRef",
                ref: Z,
                tabindex: c.timePickerInline ? void 0 : 0
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(
                    c.timePickerInline ? "dp__time_picker_inline_container" : "dp__overlay_container dp__container_flex dp__time_picker_overlay_container"
                  ),
                  style: { display: "flex" }
                }, [
                  c.$slots["time-picker-overlay"] ? renderSlot(c.$slots, "time-picker-overlay", {
                    key: 0,
                    hours: e.hours,
                    minutes: e.minutes,
                    seconds: e.seconds,
                    setHours: f,
                    setMinutes: w,
                    setSeconds: C
                  }) : createCommentVNode("", true),
                  c.$slots["time-picker-overlay"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", {
                    key: 1,
                    class: normalizeClass(c.timePickerInline ? "dp__flex" : "dp__overlay_row dp__flex_row")
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(H.value, (u, y) => withDirectives((openBlock(), createBlock(Al, mergeProps({ key: y }, {
                      ...c.$props,
                      order: y,
                      hours: u.hours,
                      minutes: u.minutes,
                      seconds: u.seconds,
                      closeTimePickerBtn: W.value,
                      disabledTimesConfig: e.disabledTimesConfig,
                      disabled: y === 0 ? c.fixedStart : c.fixedEnd
                    }, {
                      ref_for: true,
                      ref_key: "timeInputRefs",
                      ref: Q,
                      "onUpdate:hours": (s) => f(le(s, y, "hours")),
                      "onUpdate:minutes": (s) => w(le(s, y, "minutes")),
                      "onUpdate:seconds": (s) => C(le(s, y, "seconds")),
                      onMounted: K,
                      onOverlayClosed: K,
                      onAmPmChange: V[3] || (V[3] = (s) => c.$emit("am-pm-change", s))
                    }), createSlots({ _: 2 }, [
                      renderList(unref(j), (s, _) => ({
                        name: s,
                        fn: withCtx((ee) => [
                          renderSlot(c.$slots, s, normalizeProps(guardReactiveProps(ee)))
                        ])
                      }))
                    ]), 1040, ["onUpdate:hours", "onUpdate:minutes", "onUpdate:seconds"])), [
                      [vShow, y === 0 ? true : k.value]
                    ])), 128))
                  ], 2)),
                  !c.timePicker && !c.timePickerInline ? withDirectives((openBlock(), createElementBlock("button", {
                    key: 2,
                    type: "button",
                    ref_key: "closeTimePickerBtn",
                    ref: W,
                    class: normalizeClass(q.value),
                    "aria-label": (m = unref(p)) == null ? void 0 : m.closeTimePicker,
                    tabindex: "0",
                    onKeydown: [
                      V[4] || (V[4] = withKeys((u) => A(false), ["enter"])),
                      V[5] || (V[5] = withKeys((u) => A(false), ["space"]))
                    ],
                    onClick: V[6] || (V[6] = (u) => A(false))
                  }, [
                    c.$slots["calendar-icon"] ? renderSlot(c.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true),
                    c.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Yt), { key: 1 }))
                  ], 42, Pl)), [
                    [vShow, !unref(R)(c.hideNavigation, "time")]
                  ]) : createCommentVNode("", true)
                ], 2)
              ], 14, _l)) : createCommentVNode("", true)
            ];
          }),
          _: 3
        }, 8, ["name", "css"])
      ]);
    };
  }
});
var Oa = (e, n, a, t) => {
  const o = (k, T) => Array.isArray(n[k]) ? n[k][T] : n[k], l = (k) => e.enableSeconds ? Array.isArray(n.seconds) ? n.seconds[k] : n.seconds : 0, d = (k, T) => k ? T !== void 0 ? nt(k, o("hours", T), o("minutes", T), l(T)) : nt(k, n.hours, n.minutes, l()) : P(), M = (k, T) => {
    n[k] = T;
  }, p = (k, T) => {
    const I = Object.fromEntries(
      Object.keys(n).map((H) => H === k ? [H, T] : [H, n[H]].slice())
    );
    if (e.range && !e.disableTimeRangeValidation) {
      const H = (q) => a.value ? nt(
        a.value[q],
        I.hours[q],
        I.minutes[q],
        I.seconds[q]
      ) : null, A = (q) => setMilliseconds(a.value[q], 0);
      return !(ye(H(0), H(1)) && (isAfter(H(0), A(1)) || isBefore(H(1), A(0))));
    }
    return true;
  }, $ = (k, T) => {
    p(k, T) && (M(k, T), t && t());
  }, h2 = (k) => {
    $("hours", k);
  }, S = (k) => {
    $("minutes", k);
  }, R = (k) => {
    $("seconds", k);
  }, J = (k, T, I, H) => {
    T && h2(k), !T && !I && S(k), I && R(k), a.value && H(a.value);
  }, W = (k) => {
    if (k) {
      const T = Array.isArray(k), I = T ? [+k[0].hours, +k[1].hours] : +k.hours, H = T ? [+k[0].minutes, +k[1].minutes] : +k.minutes, A = T ? [+k[0].seconds, +k[1].seconds] : +k.seconds;
      M("hours", I), M("minutes", H), e.enableSeconds && M("seconds", A);
    }
  }, Q = (k, T) => {
    const I = {
      hours: Array.isArray(n.hours) ? n.hours[k] : n.hours,
      disabledArr: []
    };
    return (T || T === 0) && (I.hours = T), Array.isArray(e.disabledTimes) && (I.disabledArr = e.range && Array.isArray(e.disabledTimes[k]) ? e.disabledTimes[k] : e.disabledTimes), I;
  }, Z = computed(() => (k, T) => {
    var I;
    if (Array.isArray(e.disabledTimes)) {
      const { disabledArr: H, hours: A } = Q(k, T), q = H.filter((j) => +j.hours === A);
      return ((I = q[0]) == null ? void 0 : I.minutes) === "*" ? { hours: [A], minutes: void 0, seconds: void 0 } : {
        hours: [],
        minutes: (q == null ? void 0 : q.map((j) => +j.minutes)) ?? [],
        seconds: (q == null ? void 0 : q.map((j) => j.seconds ? +j.seconds : void 0)) ?? []
      };
    }
    return { hours: [], minutes: [], seconds: [] };
  });
  return {
    setTime: M,
    updateHours: h2,
    updateMinutes: S,
    updateSeconds: R,
    getSetDateTime: d,
    updateTimeValues: J,
    getSecondsValue: l,
    assignStartTime: W,
    disabledTimesConfig: Z
  };
};
var Cl = (e, n) => {
  const { modelValue: a, time: t } = qt(e, n), { defaultedStartTime: o } = Re(e), { updateTimeValues: l, getSetDateTime: d, setTime: M, assignStartTime: p, disabledTimesConfig: $ } = Oa(
    e,
    t,
    a
  ), h2 = (T) => {
    const { hours: I, minutes: H, seconds: A } = T;
    return { hours: +I, minutes: +H, seconds: A ? +A : 0 };
  }, S = () => {
    if (e.startTime) {
      if (Array.isArray(e.startTime)) {
        const I = h2(e.startTime[0]), H = h2(e.startTime[1]);
        return [set(P(), I), set(P(), H)];
      }
      const T = h2(e.startTime);
      return set(P(), T);
    }
    return e.range ? [null, null] : null;
  }, R = () => {
    if (e.range) {
      const [T, I] = S();
      a.value = [d(T, 0), d(I, 1)];
    } else
      a.value = d(S());
  }, J = (T) => Array.isArray(T) ? [vt(P(T[0])), vt(P(T[1]))] : [vt(T ?? P())], W = (T, I, H) => {
    M("hours", T), M("minutes", I), e.enableSeconds && M("seconds", H);
  }, Q = () => {
    const [T, I] = J(a.value);
    return e.range ? W(
      [T.hours, I.hours],
      [T.minutes, I.minutes],
      [T.seconds, I.minutes]
    ) : W(T.hours, T.minutes, T.seconds);
  };
  onMounted(() => {
    if (!e.shadow)
      return p(o.value), a.value ? Q() : R();
  });
  const Z = () => {
    Array.isArray(a.value) ? a.value = a.value.map((T, I) => T && d(T, I)) : a.value = d(a.value), n("time-update");
  };
  return {
    time: t,
    disabledTimesConfig: $,
    updateTime: (T, I = true, H = false) => {
      l(T, I, H, Z);
    }
  };
};
var Rl = defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "TimePickerSolo",
  props: {
    ...Qe
  },
  emits: ["update:internal-model-value", "time-update", "am-pm-change"],
  setup(e, { emit: n }) {
    const a = e, t = useSlots(), o = je(t, "timePicker"), { time: l, disabledTimesConfig: d, updateTime: M } = Cl(a, n);
    return (p, $) => (openBlock(), createBlock(Ln, {
      "multi-calendars": 0,
      stretch: ""
    }, {
      default: withCtx(() => [
        createVNode(Na, mergeProps(p.$props, {
          hours: unref(l).hours,
          minutes: unref(l).minutes,
          seconds: unref(l).seconds,
          "internal-model-value": p.internalModelValue,
          "disabled-times-config": unref(d),
          "onUpdate:hours": $[0] || ($[0] = (h2) => unref(M)(h2)),
          "onUpdate:minutes": $[1] || ($[1] = (h2) => unref(M)(h2, false)),
          "onUpdate:seconds": $[2] || ($[2] = (h2) => unref(M)(h2, false, true)),
          onAmPmChange: $[3] || ($[3] = (h2) => p.$emit("am-pm-change", h2))
        }), createSlots({ _: 2 }, [
          renderList(unref(o), (h2, S) => ({
            name: h2,
            fn: withCtx((R) => [
              renderSlot(p.$slots, h2, normalizeProps(guardReactiveProps(R)))
            ])
          }))
        ]), 1040, ["hours", "minutes", "seconds", "internal-model-value", "disabled-times-config"])
      ]),
      _: 3
    }));
  }
});
var Nl = { class: "dp__month_year_row" };
var Ol = ["aria-label", "onClick", "onKeydown"];
var Il = defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "DpHeader",
  props: {
    month: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    instance: { type: Number, default: 0 },
    years: { type: Array, default: () => [] },
    months: { type: Array, default: () => [] },
    ...Qe
  },
  emits: ["update-month-year", "mount", "reset-flow", "overlay-closed"],
  setup(e, { expose: n, emit: a }) {
    const t = e, { defaultedTransitions: o, defaultedAriaLabels: l, defaultedMultiCalendars: d, defaultedFilters: M } = Re(t), { transitionName: p, showTransition: $ } = Bt(o), { buildMatrix: h2 } = lt(), { handleMonthYearChange: S, isDisabled: R, updateMonthYear: J } = jr(t, a), { showLeftIcon: W, showRightIcon: Q } = Jt(), Z = ref(false), k = ref(false), T = ref([null, null, null, null]);
    onMounted(() => {
      a("mount");
    });
    const I = (u) => ({
      get: () => t[u],
      set: (y) => {
        const s = u === We.month ? We.year : We.month;
        a("update-month-year", { [u]: y, [s]: t[s] }), u === We.month ? C(true) : K(true);
      }
    }), H = computed(I(We.month)), A = computed(I(We.year)), q = computed(() => (u) => ({
      month: t.month,
      year: t.year,
      items: u === We.month ? t.months : t.years,
      instance: t.instance,
      updateMonthYear: J,
      toggle: u === We.month ? C : K
    })), j = computed(() => {
      const u = t.months.find((y) => y.value === t.month);
      return u || { text: "", value: 0 };
    }), le = computed(() => kt(t.months, (u) => {
      const y = t.month === u.value, s = Rt(
        u.value,
        $a(t.year, t.minDate),
        Ta(t.year, t.maxDate)
      ) || M.value.months.includes(u.value);
      return { active: y, disabled: s };
    })), f = computed(() => kt(t.years, (u) => {
      const y = t.year === u.value, s = Rt(u.value, wt(t.minDate), wt(t.maxDate)) || M.value.years.includes(u.value);
      return { active: y, disabled: s };
    })), w = (u, y) => {
      y !== void 0 ? u.value = y : u.value = !u.value, u.value || a("overlay-closed");
    }, C = (u = false, y) => {
      c(u), w(Z, y);
    }, K = (u = false, y) => {
      c(u), w(k, y);
    }, c = (u) => {
      u || a("reset-flow");
    }, V = (u, y) => {
      t.arrowNavigation && (T.value[y] = Ae(u), h2(T.value, "monthYear"));
    }, b = computed(() => {
      var u, y;
      return [
        {
          type: We.month,
          index: 1,
          toggle: C,
          modelValue: H.value,
          updateModelValue: (s) => H.value = s,
          text: j.value.text,
          showSelectionGrid: Z.value,
          items: le.value,
          ariaLabel: (u = l.value) == null ? void 0 : u.openMonthsOverlay
        },
        {
          type: We.year,
          index: 2,
          toggle: K,
          modelValue: A.value,
          updateModelValue: (s) => A.value = s,
          text: t.year,
          showSelectionGrid: k.value,
          items: f.value,
          ariaLabel: (y = l.value) == null ? void 0 : y.openYearsOverlay
        }
      ];
    }), m = computed(
      () => t.disableYearSelect ? [b.value[0]] : b.value
    );
    return n({
      toggleMonthPicker: C,
      toggleYearPicker: K,
      handleMonthYearChange: S
    }), (u, y) => {
      var s, _, ee;
      return openBlock(), createElementBlock("div", Nl, [
        u.$slots["month-year"] ? renderSlot(u.$slots, "month-year", normalizeProps(mergeProps({ key: 0 }, { month: e.month, year: e.year, months: e.months, years: e.years, updateMonthYear: unref(J), handleMonthYearChange: unref(S), instance: e.instance }))) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          unref(W)(unref(d), e.instance) && !u.vertical ? (openBlock(), createBlock(St, {
            key: 0,
            "aria-label": (s = unref(l)) == null ? void 0 : s.prevMonth,
            disabled: unref(R)(false),
            onActivate: y[0] || (y[0] = (r) => unref(S)(false, true)),
            onSetRef: y[1] || (y[1] = (r) => V(r, 0))
          }, {
            default: withCtx(() => [
              u.$slots["arrow-left"] ? renderSlot(u.$slots, "arrow-left", { key: 0 }) : createCommentVNode("", true),
              u.$slots["arrow-left"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Rn), { key: 1 }))
            ]),
            _: 3
          }, 8, ["aria-label", "disabled"])) : createCommentVNode("", true),
          createBaseVNode("div", {
            class: normalizeClass(["dp__month_year_wrap", {
              dp__year_disable_select: u.disableYearSelect
            }])
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(m.value, (r, U) => (openBlock(), createElementBlock(Fragment, {
              key: r.type
            }, [
              createBaseVNode("button", {
                type: "button",
                class: "dp__btn dp__month_year_select",
                tabindex: "0",
                "aria-label": r.ariaLabel,
                ref_for: true,
                ref: (N) => V(N, U + 1),
                onClick: r.toggle,
                onKeydown: [
                  withKeys(withModifiers(r.toggle, ["prevent"]), ["enter"]),
                  withKeys(withModifiers(r.toggle, ["prevent"]), ["space"])
                ]
              }, [
                u.$slots[r.type] ? renderSlot(u.$slots, r.type, {
                  key: 0,
                  text: r.text,
                  value: t[r.type]
                }) : createCommentVNode("", true),
                u.$slots[r.type] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createTextVNode(toDisplayString(r.text), 1)
                ], 64))
              ], 40, Ol),
              createVNode(Transition, {
                name: unref(p)(r.showSelectionGrid),
                css: unref($)
              }, {
                default: withCtx(() => [
                  r.showSelectionGrid ? (openBlock(), createBlock(Nt, {
                    key: 0,
                    items: r.items,
                    "arrow-navigation": u.arrowNavigation,
                    "hide-navigation": u.hideNavigation,
                    "is-last": u.autoApply && !u.keepActionRow,
                    "skip-button-ref": false,
                    type: r.type,
                    "header-refs": [],
                    "esc-close": u.escClose,
                    "text-input": u.textInput,
                    onSelected: r.updateModelValue,
                    onToggle: r.toggle
                  }, createSlots({
                    "button-icon": withCtx(() => [
                      u.$slots["calendar-icon"] ? renderSlot(u.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true),
                      u.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Yt), { key: 1 }))
                    ]),
                    _: 2
                  }, [
                    u.$slots[`${r.type}-overlay-val`] ? {
                      name: "item",
                      fn: withCtx(({ item: N }) => [
                        renderSlot(u.$slots, `${r.type}-overlay-val`, {
                          text: N.text,
                          value: N.value
                        })
                      ]),
                      key: "0"
                    } : void 0,
                    u.$slots[`${r.type}-overlay`] ? {
                      name: "overlay",
                      fn: withCtx(() => [
                        renderSlot(u.$slots, `${r.type}-overlay`, normalizeProps(guardReactiveProps(q.value(r.type))))
                      ]),
                      key: "1"
                    } : void 0,
                    u.$slots[`${r.type}-overlay-header`] ? {
                      name: "header",
                      fn: withCtx(() => [
                        renderSlot(u.$slots, `${r.type}-overlay-header`, {
                          toggle: r.toggle
                        })
                      ]),
                      key: "2"
                    } : void 0
                  ]), 1032, ["items", "arrow-navigation", "hide-navigation", "is-last", "type", "esc-close", "text-input", "onSelected", "onToggle"])) : createCommentVNode("", true)
                ]),
                _: 2
              }, 1032, ["name", "css"])
            ], 64))), 128))
          ], 2),
          unref(W)(unref(d), e.instance) && u.vertical ? (openBlock(), createBlock(St, {
            key: 1,
            "aria-label": (_ = unref(l)) == null ? void 0 : _.prevMonth,
            disabled: unref(R)(false),
            onActivate: y[2] || (y[2] = (r) => unref(S)(false, true))
          }, {
            default: withCtx(() => [
              u.$slots["arrow-up"] ? renderSlot(u.$slots, "arrow-up", { key: 0 }) : createCommentVNode("", true),
              u.$slots["arrow-up"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(In), { key: 1 }))
            ]),
            _: 3
          }, 8, ["aria-label", "disabled"])) : createCommentVNode("", true),
          unref(Q)(unref(d), e.instance) ? (openBlock(), createBlock(St, {
            key: 2,
            ref: "rightIcon",
            disabled: unref(R)(true),
            "aria-label": (ee = unref(l)) == null ? void 0 : ee.nextMonth,
            onActivate: y[3] || (y[3] = (r) => unref(S)(true, true)),
            onSetRef: y[4] || (y[4] = (r) => V(r, u.disableYearSelect ? 2 : 3))
          }, {
            default: withCtx(() => [
              u.$slots[u.vertical ? "arrow-down" : "arrow-right"] ? renderSlot(u.$slots, u.vertical ? "arrow-down" : "arrow-right", { key: 0 }) : createCommentVNode("", true),
              u.$slots[u.vertical ? "arrow-down" : "arrow-right"] ? createCommentVNode("", true) : (openBlock(), createBlock(resolveDynamicComponent(u.vertical ? unref(Yn) : unref(Nn)), { key: 1 }))
            ]),
            _: 3
          }, 8, ["disabled", "aria-label"])) : createCommentVNode("", true)
        ], 64))
      ]);
    };
  }
});
var Yl = ["aria-label"];
var Bl = {
  class: "dp__calendar_header",
  role: "row"
};
var El = {
  key: 0,
  class: "dp__calendar_header_item",
  role: "gridcell"
};
var Fl = createBaseVNode("div", { class: "dp__calendar_header_separator" }, null, -1);
var Vl = ["aria-label"];
var Hl = {
  key: 0,
  role: "gridcell",
  class: "dp__calendar_item dp__week_num"
};
var Ll = { class: "dp__cell_inner" };
var Ul = ["aria-selected", "aria-disabled", "aria-label", "onClick", "onKeydown", "onMouseenter", "onMouseleave"];
var Wl = defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "DpCalendar",
  props: {
    mappedDates: { type: Array, default: () => [] },
    instance: { type: Number, default: 0 },
    month: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    ...Qe
  },
  emits: [
    "select-date",
    "set-hover-date",
    "handle-scroll",
    "mount",
    "handle-swipe",
    "handle-space",
    "tooltip-open",
    "tooltip-close"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, { buildMultiLevelMatrix: o } = lt(), { defaultedTransitions: l, defaultedAriaLabels: d, defaultedMultiCalendars: M } = Re(t), p = ref(null), $ = ref({
      bottom: "",
      left: "",
      transform: ""
    }), h2 = ref([]), S = ref(null), R = ref(true), J = ref(""), W = ref({ startX: 0, endX: 0, startY: 0, endY: 0 }), Q = ref([]), Z = ref({ left: "50%" }), k = computed(() => t.calendar ? t.calendar(t.mappedDates) : t.mappedDates), T = computed(() => t.dayNames ? Array.isArray(t.dayNames) ? t.dayNames : t.dayNames(t.locale, +t.weekStart) : Mr(t.formatLocale, t.locale, +t.weekStart));
    onMounted(() => {
      a("mount", { cmp: "calendar", refs: h2 }), t.noSwipe || S.value && (S.value.addEventListener("touchstart", K, { passive: false }), S.value.addEventListener("touchend", c, { passive: false }), S.value.addEventListener("touchmove", V, { passive: false })), t.monthChangeOnScroll && S.value && S.value.addEventListener("wheel", u, { passive: false });
    });
    const I = (s) => s ? t.vertical ? "vNext" : "next" : t.vertical ? "vPrevious" : "previous", H = (s, _) => {
      if (t.transitions) {
        const ee = Le(xe(P(), t.month, t.year));
        J.value = Ne(Le(xe(P(), s, _)), ee) ? l.value[I(true)] : l.value[I(false)], R.value = false, nextTick(() => {
          R.value = true;
        });
      }
    }, A = computed(
      () => ({
        [t.calendarClassName]: !!t.calendarClassName
      })
    ), q = computed(() => (s) => {
      const _ = Tr(s);
      return {
        dp__marker_dot: _.type === "dot",
        dp__marker_line: _.type === "line"
      };
    }), j = computed(() => (s) => ye(s, p.value)), le = computed(() => ({
      dp__calendar: true,
      dp__calendar_next: M.value.count > 0 && t.instance !== 0
    })), f = computed(() => (s) => t.hideOffsetDates ? s.current : true), w = async (s, _, ee) => {
      var r, U;
      if (a("set-hover-date", s), (U = (r = s.marker) == null ? void 0 : r.tooltip) != null && U.length) {
        const N = Ae(h2.value[_][ee]);
        if (N) {
          const { width: g, height: F } = N.getBoundingClientRect();
          p.value = s.value;
          let ae = { left: `${g / 2}px` }, G = -50;
          if (await nextTick(), Q.value[0]) {
            const { left: we, width: se } = Q.value[0].getBoundingClientRect();
            we < 0 && (ae = { left: "0" }, G = 0, Z.value.left = `${g / 2}px`), window.innerWidth < we + se && (ae = { right: "0" }, G = 0, Z.value.left = `${se - g / 2}px`);
          }
          $.value = {
            bottom: `${F}px`,
            ...ae,
            transform: `translateX(${G}%)`
          }, a("tooltip-open", s.marker);
        }
      }
    }, C = (s) => {
      p.value && (p.value = null, $.value = JSON.parse(JSON.stringify({ bottom: "", left: "", transform: "" })), a("tooltip-close", s.marker));
    }, K = (s) => {
      W.value.startX = s.changedTouches[0].screenX, W.value.startY = s.changedTouches[0].screenY;
    }, c = (s) => {
      W.value.endX = s.changedTouches[0].screenX, W.value.endY = s.changedTouches[0].screenY, b();
    }, V = (s) => {
      t.vertical && !t.inline && s.preventDefault();
    }, b = () => {
      const s = t.vertical ? "Y" : "X";
      Math.abs(W.value[`start${s}`] - W.value[`end${s}`]) > 10 && a("handle-swipe", W.value[`start${s}`] > W.value[`end${s}`] ? "right" : "left");
    }, m = (s, _, ee) => {
      s && (Array.isArray(h2.value[_]) ? h2.value[_][ee] = s : h2.value[_] = [s]), t.arrowNavigation && o(h2.value, "calendar");
    }, u = (s) => {
      t.monthChangeOnScroll && (s.preventDefault(), a("handle-scroll", s));
    }, y = (s) => {
      const _ = s[0];
      return t.weekNumbers === "local" ? getWeek(_.value, { weekStartsOn: +t.weekStart }) : t.weekNumbers === "iso" ? getISOWeek(_.value) : typeof t.weekNumbers == "function" ? t.weekNumbers(_.value) : "";
    };
    return n({ triggerTransition: H }), (s, _) => {
      var ee;
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(le.value)
      }, [
        createBaseVNode("div", {
          ref_key: "calendarWrapRef",
          ref: S,
          role: "grid",
          class: normalizeClass(A.value),
          "aria-label": (ee = unref(d)) == null ? void 0 : ee.calendarWrap
        }, [
          (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createBaseVNode("div", Bl, [
              s.weekNumbers ? (openBlock(), createElementBlock("div", El, toDisplayString(s.weekNumName), 1)) : createCommentVNode("", true),
              (openBlock(true), createElementBlock(Fragment, null, renderList(T.value, (r, U) => (openBlock(), createElementBlock("div", {
                class: "dp__calendar_header_item",
                role: "gridcell",
                key: U
              }, [
                s.$slots["calendar-header"] ? renderSlot(s.$slots, "calendar-header", {
                  key: 0,
                  day: r,
                  index: U
                }) : createCommentVNode("", true),
                s.$slots["calendar-header"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createTextVNode(toDisplayString(r), 1)
                ], 64))
              ]))), 128))
            ]),
            Fl,
            createVNode(Transition, {
              name: J.value,
              css: !!s.transitions
            }, {
              default: withCtx(() => {
                var r;
                return [
                  R.value ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: "dp__calendar",
                    role: "grid",
                    "aria-label": ((r = unref(d)) == null ? void 0 : r.calendarDays) || void 0
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(k.value, (U, N) => (openBlock(), createElementBlock("div", {
                      class: "dp__calendar_row",
                      role: "row",
                      key: N
                    }, [
                      s.weekNumbers ? (openBlock(), createElementBlock("div", Hl, [
                        createBaseVNode("div", Ll, toDisplayString(y(U.days)), 1)
                      ])) : createCommentVNode("", true),
                      (openBlock(true), createElementBlock(Fragment, null, renderList(U.days, (g, F) => {
                        var ae, G, we;
                        return openBlock(), createElementBlock("div", {
                          role: "gridcell",
                          class: "dp__calendar_item",
                          ref_for: true,
                          ref: (se) => m(se, N, F),
                          key: F + N,
                          "aria-selected": g.classData.dp__active_date || g.classData.dp__range_start || g.classData.dp__range_start,
                          "aria-disabled": g.classData.dp__cell_disabled || void 0,
                          "aria-label": (G = (ae = unref(d)) == null ? void 0 : ae.day) == null ? void 0 : G.call(ae, g),
                          tabindex: "0",
                          onClick: withModifiers((se) => s.$emit("select-date", g), ["stop", "prevent"]),
                          onKeydown: [
                            withKeys((se) => s.$emit("select-date", g), ["enter"]),
                            withKeys((se) => s.$emit("handle-space", g), ["space"])
                          ],
                          onMouseenter: (se) => w(g, N, F),
                          onMouseleave: (se) => C(g)
                        }, [
                          createBaseVNode("div", {
                            class: normalizeClass(["dp__cell_inner", g.classData])
                          }, [
                            s.$slots.day && f.value(g) ? renderSlot(s.$slots, "day", {
                              key: 0,
                              day: +g.text,
                              date: g.value
                            }) : createCommentVNode("", true),
                            s.$slots.day ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                              createTextVNode(toDisplayString(g.text), 1)
                            ], 64)),
                            g.marker && f.value(g) ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                              s.$slots.marker ? renderSlot(s.$slots, "marker", {
                                key: 0,
                                marker: g.marker,
                                day: +g.text,
                                date: g.value
                              }) : (openBlock(), createElementBlock("div", {
                                key: 1,
                                class: normalizeClass(q.value(g.marker)),
                                style: normalizeStyle(g.marker.color ? { backgroundColor: g.marker.color } : {})
                              }, null, 6))
                            ], 64)) : createCommentVNode("", true),
                            j.value(g.value) ? (openBlock(), createElementBlock("div", {
                              key: 3,
                              class: "dp__marker_tooltip",
                              ref_for: true,
                              ref_key: "activeTooltip",
                              ref: Q,
                              style: normalizeStyle($.value)
                            }, [
                              (we = g.marker) != null && we.tooltip ? (openBlock(), createElementBlock("div", {
                                key: 0,
                                class: "dp__tooltip_content",
                                onClick: _[0] || (_[0] = withModifiers(() => {
                                }, ["stop"]))
                              }, [
                                (openBlock(true), createElementBlock(Fragment, null, renderList(g.marker.tooltip, (se, O) => (openBlock(), createElementBlock("div", {
                                  key: O,
                                  class: "dp__tooltip_text"
                                }, [
                                  s.$slots["marker-tooltip"] ? renderSlot(s.$slots, "marker-tooltip", {
                                    key: 0,
                                    tooltip: se,
                                    day: g.value
                                  }) : createCommentVNode("", true),
                                  s.$slots["marker-tooltip"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                                    createBaseVNode("div", {
                                      class: "dp__tooltip_mark",
                                      style: normalizeStyle(se.color ? { backgroundColor: se.color } : {})
                                    }, null, 4),
                                    createBaseVNode("div", null, toDisplayString(se.text), 1)
                                  ], 64))
                                ]))), 128)),
                                createBaseVNode("div", {
                                  class: "dp__arrow_bottom_tp",
                                  style: normalizeStyle(Z.value)
                                }, null, 4)
                              ])) : createCommentVNode("", true)
                            ], 4)) : createCommentVNode("", true)
                          ], 2)
                        ], 40, Ul);
                      }), 128))
                    ]))), 128))
                  ], 8, Vl)) : createCommentVNode("", true)
                ];
              }),
              _: 3
            }, 8, ["name", "css"])
          ], 64))
        ], 10, Yl)
      ], 2);
    };
  }
});
var ua = (e) => Array.isArray(e);
var zl = (e, n, a, t) => {
  const o = ref([]), { modelValue: l, calendars: d, time: M } = qt(e, n), { defaultedMultiCalendars: p, defaultedStartTime: $ } = Re(e), { validateMonthYearInRange: h2, isDisabled: S, isDateRangeAllowed: R, checkMinMaxRange: J } = Et(e), { updateTimeValues: W, getSetDateTime: Q, setTime: Z, assignStartTime: k, disabledTimesConfig: T } = Oa(
    e,
    M,
    l,
    t
  ), I = computed(
    () => (i) => d.value[i] ? d.value[i].month : 0
  ), H = computed(
    () => (i) => d.value[i] ? d.value[i].year : 0
  ), A = (i, E, ne) => {
    var de, De;
    d.value[i] || (d.value[i] = { month: 0, year: 0 }), d.value[i].month = na(E) ? (de = d.value[i]) == null ? void 0 : de.month : E, d.value[i].year = na(ne) ? (De = d.value[i]) == null ? void 0 : De.year : ne;
  }, q = () => {
    e.autoApply && n("select-date");
  };
  watch(l, (i, E) => {
    JSON.stringify(i) !== JSON.stringify(E) && f();
  }), onMounted(() => {
    e.shadow || (l.value || (s(), $.value && k($.value)), f(true), e.focusStartDate && e.startDate && s());
  });
  const j = computed(() => {
    var i;
    return (i = e.flow) != null && i.length && !e.partialFlow ? e.flowStep === e.flow.length : true;
  }), le = () => {
    e.autoApply && j.value && n("auto-apply", e.partialFlow);
  }, f = (i = false) => {
    if (l.value)
      return Array.isArray(l.value) ? (o.value = l.value, b(i)) : C(l.value, i);
    if (p.value.count && i && !e.startDate)
      return w(P(), i);
  }, w = (i, E = false) => {
    if ((!p.value.count || !p.value.static || E) && A(0, getMonth(i), getYear(i)), p.value.count)
      for (let ne = 1; ne < p.value.count; ne++) {
        const de = set(P(), { month: I.value(ne - 1), year: H.value(ne - 1) }), De = add(de, { months: 1 });
        d.value[ne] = { month: getMonth(De), year: getYear(De) };
      }
  }, C = (i, E) => {
    w(i), Z("hours", getHours(i)), Z("minutes", getMinutes(i)), Z("seconds", getSeconds(i)), p.value.count && E && y();
  }, K = (i) => {
    if (p.value.count) {
      if (p.value.solo)
        return 0;
      const E = getMonth(i[0]), ne = getMonth(i[1]);
      return Math.abs(ne - E) < p.value.count ? 0 : 1;
    }
    return 1;
  }, c = (i, E) => {
    i[1] && e.showLastInRange ? w(i[K(i)], E) : w(i[0], E);
    const ne = (de, De) => [
      de(i[0]),
      i[1] ? de(i[1]) : M[De][1]
    ];
    Z("hours", ne(getHours, "hours")), Z("minutes", ne(getMinutes, "minutes")), Z("seconds", ne(getSeconds, "seconds"));
  }, V = (i, E) => {
    if ((e.range || e.weekPicker) && !e.multiDates)
      return c(i, E);
    if (e.multiDates && E) {
      const ne = i[i.length - 1];
      return C(ne, E);
    }
  }, b = (i) => {
    const E = l.value;
    V(E, i), p.value.count && p.value.solo && y();
  }, m = (i, E) => {
    const ne = set(P(), { month: I.value(E), year: H.value(E) }), de = i < 0 ? addMonths(ne, 1) : subMonths(ne, 1);
    h2(getMonth(de), getYear(de), i < 0, e.preventMinMaxNavigation) && (A(E, getMonth(de), getYear(de)), p.value.count && !p.value.solo && u(E), a());
  }, u = (i) => {
    for (let E = i - 1; E >= 0; E--) {
      const ne = subMonths(set(P(), { month: I.value(E + 1), year: H.value(E + 1) }), 1);
      A(E, getMonth(ne), getYear(ne));
    }
    for (let E = i + 1; E <= p.value.count - 1; E++) {
      const ne = addMonths(set(P(), { month: I.value(E - 1), year: H.value(E - 1) }), 1);
      A(E, getMonth(ne), getYear(ne));
    }
  }, y = () => {
    if (Array.isArray(l.value) && l.value.length === 2) {
      const i = P(
        P(l.value[1] ? l.value[1] : addMonths(l.value[0], 1))
      ), [E, ne] = [getMonth(l.value[0]), getYear(l.value[0])], [de, De] = [getMonth(l.value[1]), getYear(l.value[1])];
      (E !== de || E === de && ne !== De) && p.value.solo && A(1, getMonth(i), getYear(i));
    } else
      l.value && !Array.isArray(l.value) && (A(0, getMonth(l.value), getYear(l.value)), w(P()));
  }, s = () => {
    e.startDate && (A(0, getMonth(P(e.startDate)), getYear(P(e.startDate))), p.value.count && u(0));
  }, _ = (i, E) => {
    e.monthChangeOnScroll && m(e.monthChangeOnScroll !== "inverse" ? -i.deltaY : i.deltaY, E);
  }, ee = (i, E, ne = false) => {
    e.monthChangeOnArrows && e.vertical === ne && r(i, E);
  }, r = (i, E) => {
    m(i === "right" ? -1 : 1, E);
  }, U = (i) => e.markers.find((E) => ye(ra(i.value), ra(E.date))), N = (i, E) => {
    switch (e.sixWeeks === true ? "append" : e.sixWeeks) {
      case "prepend":
        return [true, false];
      case "center":
        return [i == 0, true];
      case "fair":
        return [i == 0 || E > i, true];
      case "append":
        return [false, false];
      default:
        return [false, false];
    }
  }, g = (i, E, ne, de) => {
    if (e.sixWeeks && i.length < 6) {
      const De = 6 - i.length, et = (E.getDay() + 7 - de) % 7, Vt = 6 - (ne.getDay() + 7 - de) % 7, [Tt, ln] = N(et, Vt);
      for (let ot = 1; ot <= De; ot++)
        if (ln ? !!(ot % 2) == Tt : Tt) {
          const Ht = i[0].days[0], on = F(addDays(Ht.value, -7), getMonth(E));
          i.unshift({ days: on });
        } else {
          const Ht = i[i.length - 1], on = Ht.days[Ht.days.length - 1], Ya = F(addDays(on.value, 1), getMonth(E));
          i.push({ days: Ya });
        }
    }
    return i;
  }, F = (i, E) => {
    const ne = P(JSON.parse(JSON.stringify(i))), de = [];
    for (let De = 0; De < 7; De++) {
      const et = addDays(ne, De), $t = getMonth(et) !== E;
      de.push({
        text: e.hideOffsetDates && $t ? "" : et.getDate(),
        value: et,
        current: !$t,
        classData: {}
      });
    }
    return de;
  }, ae = (i, E) => {
    const ne = [], de = P(Ze(new Date(E, i), e.timezone)), De = P(Ze(new Date(E, i + 1, 0), e.timezone)), et = e.weekStart, $t = startOfWeek(de, { weekStartsOn: et }), Vt = (Tt) => {
      const ln = F(Tt, i);
      if (ne.push({ days: ln }), !ne[ne.length - 1].days.some(
        (ot) => ye(Le(ot.value), Le(De))
      )) {
        const ot = addDays(Tt, 7);
        Vt(ot);
      }
    };
    return Vt($t), g(ne, de, De, et);
  }, G = (i) => (l.value = Kt(P(i.value), e.timezone, e.weekStart), le()), we = (i) => {
    const E = nt(P(i.value), M.hours, M.minutes, Ft());
    e.multiDates ? Un(E, l, e.multiDatesLimit) : l.value = E, t(), nextTick().then(() => {
      le();
    });
  }, se = (i) => e.noDisabledRange ? Aa(o.value[0], i).some((ne) => S(ne)) : false, O = () => {
    o.value = l.value ? l.value.slice() : [], o.value.length === 2 && !(e.fixedStart || e.fixedEnd) && (o.value = []);
  }, X = (i, E) => {
    const ne = [P(i.value), addDays(P(i.value), +e.autoRange)];
    R(ne) && (E && $e(i.value), o.value = ne);
  }, $e = (i) => {
    const E = getMonth(P(i)), ne = getYear(P(i));
    if (A(0, E, ne), p.value.count > 0)
      for (let de = 1; de < p.value.count; de++) {
        const De = Rr(
          set(P(i), { year: I.value(de - 1), month: H.value(de - 1) })
        );
        A(de, De.month, De.year);
      }
  }, x = (i) => Array.isArray(l.value) && l.value.length === 2 ? e.fixedStart && (Ne(i, l.value[0]) || ye(i, l.value[0])) ? [l.value[0], i] : e.fixedEnd && (Pe(i, l.value[1]) || ye(i, l.value[1])) ? [i, l.value[1]] : (n("invalid-fixed-range", i), l.value) : [], Ve = (i) => {
    se(i.value) || !J(i.value, l.value, e.fixedStart ? 0 : 1) || (o.value = x(P(i.value)));
  }, Se = (i, E) => {
    if (O(), e.autoRange)
      return X(i, E);
    if (e.fixedStart || e.fixedEnd)
      return Ve(i);
    o.value[0] ? J(P(i.value), l.value) && !se(i.value) && (Pe(P(i.value), P(o.value[0])) ? (o.value.unshift(P(i.value)), n("range-end", o.value[0])) : (o.value[1] = P(i.value), n("range-end", o.value[1]))) : (o.value[0] = P(i.value), n("range-start", o.value[0]));
  }, Ft = (i = true) => e.enableSeconds ? Array.isArray(M.seconds) ? i ? M.seconds[0] : M.seconds[1] : M.seconds : 0, Mt = (i) => {
    o.value[i] = nt(
      o.value[i],
      M.hours[i],
      M.minutes[i],
      Ft(i !== 1)
    );
  }, xt = () => {
    var i, E;
    o.value[0] && o.value[1] && +((i = o.value) == null ? void 0 : i[0]) > +((E = o.value) == null ? void 0 : E[1]) && (o.value.reverse(), n("range-start", o.value[0]), n("range-end", o.value[1]));
  }, Qt = () => {
    o.value.length && (o.value[0] && !o.value[1] ? Mt(0) : (Mt(0), Mt(1), t()), xt(), l.value = o.value.slice(), Wn(o.value, n, e.autoApply, e.modelAuto));
  }, en = (i, E = false) => {
    if (!(S(i.value) || !i.current && e.hideOffsetDates)) {
      if (e.weekPicker)
        return G(i);
      if (!e.range)
        return we(i);
      ua(M.hours) && ua(M.minutes) && !e.multiDates && (Se(i, E), Qt());
    }
  }, tn = (i, E) => {
    var de;
    A(i, E.month, E.year), p.value.count && !p.value.solo && u(i), n("update-month-year", { instance: i, month: E.month, year: E.year }), a(p.value.solo ? i : void 0);
    const ne = (de = e.flow) != null && de.length ? e.flow[e.flowStep] : void 0;
    !E.fromNav && (ne === Ke.month || ne === Ke.year) && t();
  }, nn = (i, E) => {
    Array.isArray(i) && i.length <= 2 && e.range ? l.value = i.map((ne) => Ze(P(ne), E ? void 0 : e.timezone)) : Array.isArray(i) || (l.value = Ze(P(i), E ? void 0 : e.timezone)), q(), e.multiCalendars && nextTick().then(() => f(true));
  }, an = () => {
    e.range ? l.value && Array.isArray(l.value) && l.value[0] ? l.value = Pe(P(), l.value[0]) ? [P(), l.value[0]] : [l.value[0], P()] : l.value = [P()] : l.value = P(), q();
  }, rn = () => {
    if (Array.isArray(l.value))
      if (e.multiDates) {
        const i = re();
        l.value[l.value.length - 1] = Q(i);
      } else
        l.value = l.value.map((i, E) => i && Q(i, E));
    else
      l.value = Q(l.value);
    n("time-update");
  }, re = () => Array.isArray(l.value) && l.value.length ? l.value[l.value.length - 1] : null;
  return {
    calendars: d,
    modelValue: l,
    month: I,
    year: H,
    time: M,
    disabledTimesConfig: T,
    getCalendarDays: ae,
    getMarker: U,
    handleScroll: _,
    handleSwipe: r,
    handleArrow: ee,
    selectDate: en,
    updateMonthYear: tn,
    presetDate: nn,
    selectCurrentDate: an,
    updateTime: (i, E = true, ne = false) => {
      W(i, E, ne, rn);
    }
  };
};
var jl = { key: 0 };
var Kl = defineComponent({
  __name: "DatePicker",
  props: {
    ...Qe
  },
  emits: [
    "tooltip-open",
    "tooltip-close",
    "mount",
    "update:internal-model-value",
    "update-flow-step",
    "reset-flow",
    "auto-apply",
    "focus-menu",
    "select-date",
    "range-start",
    "range-end",
    "invalid-fixed-range",
    "time-update",
    "am-pm-change",
    "time-picker-open",
    "time-picker-close",
    "recalculate-position",
    "update-month-year"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, {
      calendars: o,
      month: l,
      year: d,
      modelValue: M,
      time: p,
      disabledTimesConfig: $,
      getCalendarDays: h2,
      getMarker: S,
      handleArrow: R,
      handleScroll: J,
      handleSwipe: W,
      selectDate: Q,
      updateMonthYear: Z,
      presetDate: k,
      selectCurrentDate: T,
      updateTime: I
    } = zl(t, a, u, y), H = useSlots(), { setHoverDate: A, getDayClassData: q, clearHoverDate: j } = qr(M, t), { defaultedMultiCalendars: le } = Re(t), f = ref([]), w = ref([]), C = ref(null), K = je(H, "calendar"), c = je(H, "monthYear"), V = je(H, "timePicker"), b = (N) => {
      t.shadow || a("mount", N);
    };
    watch(
      o,
      () => {
        t.shadow || setTimeout(() => {
          a("recalculate-position");
        }, 0);
      },
      { deep: true }
    );
    const m = computed(() => (N) => h2(l.value(N), d.value(N)).map((g) => ({
      ...g,
      days: g.days.map((F) => (F.marker = S(F), F.classData = q(F), F))
    })));
    function u(N) {
      var g;
      N || N === 0 ? (g = w.value[N]) == null || g.triggerTransition(l.value(N), d.value(N)) : w.value.forEach((F, ae) => F.triggerTransition(l.value(ae), d.value(ae)));
    }
    function y() {
      a("update-flow-step");
    }
    const s = (N, g = false) => {
      Q(N, g), t.spaceConfirm && a("select-date");
    };
    return n({
      clearHoverDate: j,
      presetDate: k,
      selectCurrentDate: T,
      toggleMonthPicker: (N, g, F = 0) => {
        var ae;
        (ae = f.value[F]) == null || ae.toggleMonthPicker(N, g);
      },
      toggleYearPicker: (N, g, F = 0) => {
        var ae;
        (ae = f.value[F]) == null || ae.toggleYearPicker(N, g);
      },
      toggleTimePicker: (N, g, F) => {
        var ae;
        (ae = C.value) == null || ae.toggleTimePicker(N, g, F);
      },
      handleArrow: R,
      updateMonthYear: Z,
      getSidebarProps: () => ({
        modelValue: M,
        month: l,
        year: d,
        time: p,
        updateTime: I,
        updateMonthYear: Z,
        selectDate: Q,
        presetDate: k
      })
    }), (N, g) => (openBlock(), createElementBlock(Fragment, null, [
      createVNode(Ln, {
        "multi-calendars": unref(le).count
      }, {
        default: withCtx(({ instance: F, index: ae }) => [
          N.disableMonthYearSelect ? createCommentVNode("", true) : (openBlock(), createBlock(Il, mergeProps({
            key: 0,
            ref: (G) => {
              G && (f.value[ae] = G);
            },
            months: unref(Da)(N.formatLocale, N.locale, N.monthNameFormat),
            years: unref(Vn)(N.yearRange, N.reverseYears),
            month: unref(l)(F),
            year: unref(d)(F),
            instance: F
          }, N.$props, {
            onMount: g[0] || (g[0] = (G) => b(unref(mt).header)),
            onResetFlow: g[1] || (g[1] = (G) => N.$emit("reset-flow")),
            onUpdateMonthYear: (G) => unref(Z)(F, G),
            onOverlayClosed: g[2] || (g[2] = (G) => N.$emit("focus-menu"))
          }), createSlots({ _: 2 }, [
            renderList(unref(c), (G, we) => ({
              name: G,
              fn: withCtx((se) => [
                renderSlot(N.$slots, G, normalizeProps(guardReactiveProps(se)))
              ])
            }))
          ]), 1040, ["months", "years", "month", "year", "instance", "onUpdateMonthYear"])),
          createVNode(Wl, mergeProps({
            ref: (G) => {
              G && (w.value[ae] = G);
            },
            "mapped-dates": m.value(F),
            month: unref(l)(F),
            year: unref(d)(F)
          }, N.$props, {
            onSelectDate: (G) => unref(Q)(G, F !== 1),
            onHandleSpace: (G) => s(G, F !== 1),
            onSetHoverDate: g[3] || (g[3] = (G) => unref(A)(G)),
            onHandleScroll: (G) => unref(J)(G, F),
            onHandleSwipe: (G) => unref(W)(G, F),
            onMount: g[4] || (g[4] = (G) => b(unref(mt).calendar)),
            onResetFlow: g[5] || (g[5] = (G) => N.$emit("reset-flow")),
            onTooltipOpen: g[6] || (g[6] = (G) => N.$emit("tooltip-open", G)),
            onTooltipClose: g[7] || (g[7] = (G) => N.$emit("tooltip-close", G))
          }), createSlots({ _: 2 }, [
            renderList(unref(K), (G, we) => ({
              name: G,
              fn: withCtx((se) => [
                renderSlot(N.$slots, G, normalizeProps(guardReactiveProps({ ...se })))
              ])
            }))
          ]), 1040, ["mapped-dates", "month", "year", "onSelectDate", "onHandleSpace", "onHandleScroll", "onHandleSwipe"])
        ]),
        _: 3
      }, 8, ["multi-calendars"]),
      N.enableTimePicker ? (openBlock(), createElementBlock("div", jl, [
        N.$slots["time-picker"] ? renderSlot(N.$slots, "time-picker", normalizeProps(mergeProps({ key: 0 }, { time: unref(p), updateTime: unref(I) }))) : (openBlock(), createBlock(Na, mergeProps({
          key: 1,
          ref_key: "timePickerRef",
          ref: C
        }, N.$props, {
          hours: unref(p).hours,
          minutes: unref(p).minutes,
          seconds: unref(p).seconds,
          "internal-model-value": N.internalModelValue,
          "disabled-times-config": unref($),
          onMount: g[8] || (g[8] = (F) => b(unref(mt).timePicker)),
          "onUpdate:hours": g[9] || (g[9] = (F) => unref(I)(F)),
          "onUpdate:minutes": g[10] || (g[10] = (F) => unref(I)(F, false)),
          "onUpdate:seconds": g[11] || (g[11] = (F) => unref(I)(F, false, true)),
          onResetFlow: g[12] || (g[12] = (F) => N.$emit("reset-flow")),
          onOverlayClosed: g[13] || (g[13] = (F) => N.$emit("time-picker-close")),
          onOverlayOpened: g[14] || (g[14] = (F) => N.$emit("time-picker-open", F)),
          onAmPmChange: g[15] || (g[15] = (F) => N.$emit("am-pm-change", F))
        }), createSlots({ _: 2 }, [
          renderList(unref(V), (F, ae) => ({
            name: F,
            fn: withCtx((G) => [
              renderSlot(N.$slots, F, normalizeProps(guardReactiveProps(G)))
            ])
          }))
        ]), 1040, ["hours", "minutes", "seconds", "internal-model-value", "disabled-times-config"]))
      ])) : createCommentVNode("", true)
    ], 64));
  }
});
var Gl = ["id", "onKeydown"];
var Zl = {
  key: 0,
  class: "dp__sidebar_left"
};
var ql = {
  key: 1,
  class: "dp--preset-dates"
};
var Jl = ["onClick", "onKeydown"];
var Xl = {
  key: 2,
  class: "dp__sidebar_right"
};
var xl = {
  key: 3,
  class: "dp__action_extra"
};
var ia = defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "DatepickerMenu",
  props: {
    ...Xt,
    shadow: { type: Boolean, default: false },
    openOnTop: { type: Boolean, default: false },
    internalModelValue: { type: [Date, Array], default: null },
    arrMapValues: { type: Object, default: () => ({}) }
  },
  emits: [
    "close-picker",
    "select-date",
    "auto-apply",
    "time-update",
    "flow-step",
    "update-month-year",
    "invalid-select",
    "update:internal-model-value",
    "recalculate-position",
    "invalid-fixed-range",
    "tooltip-open",
    "tooltip-close",
    "time-picker-open",
    "time-picker-close",
    "am-pm-change",
    "range-start",
    "range-end"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, o = computed(() => {
      const { openOnTop: O, ...X } = t;
      return {
        ...X,
        flowStep: q.value
      };
    }), { setMenuFocused: l, setShiftKey: d, control: M } = Ca(), p = useSlots(), { defaultedTextInput: $, defaultedInline: h2 } = Re(t), S = ref(null), R = ref(0), J = ref(null), W = ref(null), Q = ref(false), Z = ref(null);
    onMounted(() => {
      if (!t.shadow) {
        Q.value = true, k(), window.addEventListener("resize", k);
        const O = Ae(J);
        if (O && !$.value.enabled && !h2.value.enabled && (l(true), C()), O) {
          const X = ($e) => {
            t.allowPreventDefault && $e.preventDefault(), $e.stopImmediatePropagation(), $e.stopPropagation();
          };
          O.addEventListener("pointerdown", X), O.addEventListener("mousedown", X);
        }
      }
    }), onUnmounted(() => {
      window.removeEventListener("resize", k);
    });
    const k = () => {
      const O = Ae(W);
      O && (R.value = O.getBoundingClientRect().width);
    }, { arrowRight: T, arrowLeft: I, arrowDown: H, arrowUp: A } = lt(), { flowStep: q, updateFlowStep: j, childMount: le, resetFlow: f } = Jr(t, a, Z), w = computed(() => t.monthPicker ? vl : t.yearPicker ? gl : t.timePicker ? Rl : Kl), C = () => {
      const O = Ae(J);
      O && O.focus({ preventScroll: true });
    }, K = computed(() => {
      var O;
      return ((O = Z.value) == null ? void 0 : O.getSidebarProps()) || {};
    }), c = () => {
      t.openOnTop && a("recalculate-position");
    }, V = je(p, "action"), b = computed(() => t.monthPicker || t.yearPicker ? je(p, "monthYear") : t.timePicker ? je(p, "timePicker") : je(p, "shared")), m = computed(() => t.openOnTop ? "dp__arrow_bottom" : "dp__arrow_top"), u = computed(() => ({
      dp__menu_disabled: t.disabled,
      dp__menu_readonly: t.readonly
    })), y = computed(
      () => ({
        dp__menu: true,
        dp__menu_index: !h2.value.enabled,
        dp__relative: h2.value.enabled,
        [t.menuClassName]: !!t.menuClassName
      })
    ), s = (O) => {
      O.stopPropagation(), O.stopImmediatePropagation();
    }, _ = () => {
      t.escClose && a("close-picker");
    }, ee = (O) => {
      if (t.arrowNavigation) {
        if (O === "up")
          return A();
        if (O === "down")
          return H();
        if (O === "left")
          return I();
        if (O === "right")
          return T();
      } else
        O === "left" || O === "up" ? F("handleArrow", "left", 0, O === "up") : F("handleArrow", "right", 0, O === "down");
    }, r = (O) => {
      d(O.shiftKey), !t.disableMonthYearSelect && O.code === "Tab" && O.target.classList.contains("dp__menu") && M.value.shiftKeyInMenu && (O.preventDefault(), O.stopImmediatePropagation(), a("close-picker"));
    }, U = () => {
      C(), a("time-picker-close");
    }, N = (O) => {
      var X, $e, x;
      (X = Z.value) == null || X.toggleTimePicker(false, false), ($e = Z.value) == null || $e.toggleMonthPicker(false, false, O), (x = Z.value) == null || x.toggleYearPicker(false, false, O);
    }, g = (O, X = 0) => {
      var $e, x, Ve;
      return O === "month" ? ($e = Z.value) == null ? void 0 : $e.toggleMonthPicker(false, true, X) : O === "year" ? (x = Z.value) == null ? void 0 : x.toggleYearPicker(false, true, X) : O === "time" ? (Ve = Z.value) == null ? void 0 : Ve.toggleTimePicker(true, false) : N(X);
    }, F = (O, ...X) => {
      var $e, x;
      ($e = Z.value) != null && $e[O] && ((x = Z.value) == null || x[O](...X));
    }, ae = () => {
      F("selectCurrentDate");
    }, G = (O, X) => {
      F("presetDate", O, X);
    }, we = () => {
      F("clearHoverDate");
    };
    return n({
      updateMonthYear: (O, X) => {
        F("updateMonthYear", O, X);
      },
      switchView: g
    }), (O, X) => {
      var $e;
      return openBlock(), createElementBlock("div", {
        id: O.uid ? `dp-menu-${O.uid}` : void 0,
        tabindex: "0",
        ref_key: "dpMenuRef",
        ref: J,
        role: "dialog",
        class: normalizeClass(y.value),
        onMouseleave: we,
        onClick: s,
        onKeydown: [
          withKeys(_, ["esc"]),
          X[15] || (X[15] = withKeys(withModifiers((x) => ee("left"), ["prevent"]), ["left"])),
          X[16] || (X[16] = withKeys(withModifiers((x) => ee("up"), ["prevent"]), ["up"])),
          X[17] || (X[17] = withKeys(withModifiers((x) => ee("down"), ["prevent"]), ["down"])),
          X[18] || (X[18] = withKeys(withModifiers((x) => ee("right"), ["prevent"]), ["right"])),
          r
        ]
      }, [
        (O.disabled || O.readonly) && unref(h2).enabled ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(u.value)
        }, null, 2)) : createCommentVNode("", true),
        !unref(h2).enabled && !O.teleportCenter ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(m.value)
        }, null, 2)) : createCommentVNode("", true),
        createBaseVNode("div", {
          ref_key: "innerMenuRef",
          ref: W,
          class: normalizeClass({
            dp__menu_content_wrapper: (($e = O.presetDates) == null ? void 0 : $e.length) || !!O.$slots["left-sidebar"] || !!O.$slots["right-sidebar"]
          }),
          style: normalizeStyle({ "--dp-menu-width": `${R.value}px` })
        }, [
          O.$slots["left-sidebar"] ? (openBlock(), createElementBlock("div", Zl, [
            renderSlot(O.$slots, "left-sidebar", normalizeProps(guardReactiveProps(K.value)))
          ])) : createCommentVNode("", true),
          O.presetDates.length ? (openBlock(), createElementBlock("div", ql, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(O.presetDates, (x, Ve) => (openBlock(), createElementBlock("div", {
              key: Ve,
              style: normalizeStyle(x.style || {}),
              class: "dp--preset-range"
            }, [
              x.slot ? renderSlot(O.$slots, x.slot, {
                key: 0,
                presetDate: G,
                label: x.label,
                value: x.value
              }) : (openBlock(), createElementBlock("div", {
                key: 1,
                role: "button",
                tabindex: "0",
                onClick: (Se) => G(x.value, x.noTz),
                onKeydown: [
                  withKeys(withModifiers((Se) => G(x.value, x.noTz), ["prevent"]), ["enter"]),
                  withKeys(withModifiers((Se) => G(x.value, x.noTz), ["prevent"]), ["space"])
                ]
              }, toDisplayString(x.label), 41, Jl))
            ], 4))), 128))
          ])) : createCommentVNode("", true),
          createBaseVNode("div", {
            class: "dp__instance_calendar",
            ref_key: "calendarWrapperRef",
            ref: S,
            role: "document"
          }, [
            (openBlock(), createBlock(resolveDynamicComponent(w.value), mergeProps({
              ref_key: "dynCmpRef",
              ref: Z
            }, o.value, {
              "flow-step": unref(q),
              onMount: unref(le),
              onUpdateFlowStep: unref(j),
              onResetFlow: unref(f),
              onFocusMenu: C,
              onSelectDate: X[0] || (X[0] = (x) => O.$emit("select-date")),
              onTooltipOpen: X[1] || (X[1] = (x) => O.$emit("tooltip-open", x)),
              onTooltipClose: X[2] || (X[2] = (x) => O.$emit("tooltip-close", x)),
              onAutoApply: X[3] || (X[3] = (x) => O.$emit("auto-apply", x)),
              onRangeStart: X[4] || (X[4] = (x) => O.$emit("range-start", x)),
              onRangeEnd: X[5] || (X[5] = (x) => O.$emit("range-end", x)),
              onInvalidFixedRange: X[6] || (X[6] = (x) => O.$emit("invalid-fixed-range", x)),
              onTimeUpdate: X[7] || (X[7] = (x) => O.$emit("time-update")),
              onAmPmChange: X[8] || (X[8] = (x) => O.$emit("am-pm-change", x)),
              onTimePickerOpen: X[9] || (X[9] = (x) => O.$emit("time-picker-open", x)),
              onTimePickerClose: U,
              onRecalculatePosition: c,
              onUpdateMonthYear: X[10] || (X[10] = (x) => O.$emit("update-month-year", x)),
              "onUpdate:internalModelValue": X[11] || (X[11] = (x) => O.$emit("update:internal-model-value", x))
            }), createSlots({ _: 2 }, [
              renderList(b.value, (x, Ve) => ({
                name: x,
                fn: withCtx((Se) => [
                  renderSlot(O.$slots, x, normalizeProps(guardReactiveProps({ ...Se })))
                ])
              }))
            ]), 1040, ["flow-step", "onMount", "onUpdateFlowStep", "onResetFlow"]))
          ], 512),
          O.$slots["right-sidebar"] ? (openBlock(), createElementBlock("div", Xl, [
            renderSlot(O.$slots, "right-sidebar", normalizeProps(guardReactiveProps(K.value)))
          ])) : createCommentVNode("", true),
          O.$slots["action-extra"] ? (openBlock(), createElementBlock("div", xl, [
            O.$slots["action-extra"] ? renderSlot(O.$slots, "action-extra", {
              key: 0,
              selectCurrentDate: ae
            }) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ], 6),
        !O.autoApply || O.keepActionRow ? (openBlock(), createBlock(rl, mergeProps({
          key: 2,
          "menu-mount": Q.value
        }, o.value, {
          "calendar-width": R.value,
          onClosePicker: X[12] || (X[12] = (x) => O.$emit("close-picker")),
          onSelectDate: X[13] || (X[13] = (x) => O.$emit("select-date")),
          onInvalidSelect: X[14] || (X[14] = (x) => O.$emit("invalid-select")),
          onSelectNow: ae
        }), createSlots({ _: 2 }, [
          renderList(unref(V), (x, Ve) => ({
            name: x,
            fn: withCtx((Se) => [
              renderSlot(O.$slots, x, normalizeProps(guardReactiveProps({ ...Se })))
            ])
          }))
        ]), 1040, ["menu-mount", "calendar-width"])) : createCommentVNode("", true)
      ], 42, Gl);
    };
  }
});
var Ql = typeof window < "u" ? window : void 0;
var bn = () => {
};
var eo = (e) => getCurrentScope() ? (onScopeDispose(e), true) : false;
var to = (e, n, a, t) => {
  if (!e)
    return bn;
  let o = bn;
  const l = watch(
    () => unref(e),
    (M) => {
      o(), M && (M.addEventListener(n, a, t), o = () => {
        M.removeEventListener(n, a, t), o = bn;
      });
    },
    { immediate: true, flush: "post" }
  ), d = () => {
    l(), o();
  };
  return eo(d), d;
};
var no = (e, n, a, t = {}) => {
  const { window: o = Ql, event: l = "pointerdown" } = t;
  return o ? to(o, l, (M) => {
    const p = Ae(e), $ = Ae(n);
    !p || !$ || p === M.target || M.composedPath().includes(p) || M.composedPath().includes($) || a(M);
  }, { passive: true }) : void 0;
};
var ao = defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "VueDatePicker",
  props: {
    ...Xt
  },
  emits: [
    "update:model-value",
    "update:model-timezone-value",
    "text-submit",
    "closed",
    "cleared",
    "open",
    "focus",
    "blur",
    "internal-model-change",
    "recalculate-position",
    "flow-step",
    "update-month-year",
    "invalid-select",
    "invalid-fixed-range",
    "tooltip-open",
    "tooltip-close",
    "time-picker-open",
    "time-picker-close",
    "am-pm-change",
    "range-start",
    "range-end"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, o = useSlots(), l = ref(false), d = toRef(t, "modelValue"), M = toRef(t, "timezone"), p = ref(null), $ = ref(null), h2 = ref(null), S = ref(false), R = ref(null), { setMenuFocused: J, setShiftKey: W } = Ca(), { clearArrowNav: Q } = lt(), { mapDatesArrToMap: Z, validateDate: k, isValidTime: T } = Et(t), { defaultedTransitions: I, defaultedTextInput: H, defaultedInline: A } = Re(t), { menuTransition: q, showTransition: j } = Bt(I);
    onMounted(() => {
      s(t.modelValue), nextTick().then(() => {
        A.value.enabled || (b(R.value).addEventListener("scroll", F), window.addEventListener("resize", ae));
      }), A.value.enabled && (l.value = true);
    });
    const le = computed(() => Z());
    onUnmounted(() => {
      if (!A.value.enabled) {
        const re = b(R.value);
        re && re.removeEventListener("scroll", F), window.removeEventListener("resize", ae);
      }
    });
    const f = je(o, "all", t.presetDates), w = je(o, "input");
    watch(
      [d, M],
      () => {
        s(d.value);
      },
      { deep: true }
    );
    const { openOnTop: C, menuStyle: K, xCorrect: c, setMenuPosition: V, getScrollableParent: b, shadowRender: m } = Kr({
      menuRef: p,
      menuRefInner: $,
      inputRef: h2,
      pickerWrapperRef: R,
      inline: A,
      emit: a,
      props: t,
      slots: o
    }), {
      inputValue: u,
      internalModelValue: y,
      parseExternalModelValue: s,
      emitModelValue: _,
      formatInputValue: ee,
      checkBeforeEmit: r
    } = zr(a, t, S), U = computed(
      () => ({
        dp__main: true,
        dp__theme_dark: t.dark,
        dp__theme_light: !t.dark,
        dp__flex_display: A.value.enabled,
        dp__flex_display_with_input: A.value.input
      })
    ), N = computed(() => t.dark ? "dp__theme_dark" : "dp__theme_light"), g = computed(() => t.teleport ? {
      to: typeof t.teleport == "boolean" ? "body" : t.teleport,
      disabled: A.value.enabled
    } : { class: "dp__outer_menu_wrap" }), F = () => {
      l.value && (t.closeOnScroll ? Se() : V());
    }, ae = () => {
      l.value && V();
    }, G = () => {
      !t.disabled && !t.readonly && (m(ia, t), V(false), l.value = true, l.value && a("open"), l.value || Ve(), s(t.modelValue));
    }, we = () => {
      u.value = "", Ve(), a("update:model-value", null), a("update:model-timezone-value", null), a("cleared"), t.closeOnClearValue && Se();
    }, se = () => {
      const re = y.value;
      return !re || !Array.isArray(re) && k(re) ? true : Array.isArray(re) ? re.length === 2 && k(re[0]) && k(re[1]) ? true : t.partialRange && !t.timePicker ? k(re[0]) : false : false;
    }, O = () => {
      r() && se() ? (_(), Se()) : a("invalid-select", y.value);
    }, X = (re) => {
      $e(), _(), t.closeOnAutoApply && !re && Se();
    }, $e = () => {
      h2.value && H.value.enabled && h2.value.setParsedDate(y.value);
    }, x = (re = false) => {
      t.autoApply && T(y.value) && se() && (t.range && Array.isArray(y.value) ? (t.partialRange || y.value.length === 2) && X(re) : X(re));
    }, Ve = () => {
      H.value.enabled || (y.value = null);
    }, Se = () => {
      A.value.enabled || (l.value && (l.value = false, c.value = false, J(false), W(false), Q(), a("closed"), u.value && s(d.value)), Ve(), a("blur"));
    }, Ft = (re, ie) => {
      if (!re) {
        y.value = null;
        return;
      }
      y.value = re, ie && (O(), a("text-submit"));
    }, Mt = () => {
      t.autoApply && T(y.value) && _(), $e();
    }, xt = () => l.value ? Se() : G(), Qt = (re) => {
      y.value = re;
    }, en = () => {
      H.value.enabled && (S.value = true, ee()), a("focus");
    }, tn = () => {
      H.value.enabled && (S.value = false, s(t.modelValue)), a("blur");
    }, nn = (re) => {
      $.value && $.value.updateMonthYear(0, {
        month: ta(re.month),
        year: ta(re.year)
      });
    }, an = (re) => {
      s(re ?? t.modelValue);
    }, rn = (re, ie) => {
      var i;
      (i = $.value) == null || i.switchView(re, ie);
    };
    return no(
      p,
      h2,
      t.onClickOutside ? () => t.onClickOutside(se) : Se
    ), n({
      closeMenu: Se,
      selectDate: O,
      clearValue: we,
      openMenu: G,
      onScroll: F,
      formatInputValue: ee,
      // exposed for testing purposes
      updateInternalModelValue: Qt,
      // modify internal modelValue
      setMonthYear: nn,
      parseModel: an,
      switchView: rn
    }), (re, ie) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(U.value),
      ref_key: "pickerWrapperRef",
      ref: R
    }, [
      createVNode(el, mergeProps({
        ref_key: "inputRef",
        ref: h2,
        "is-menu-open": l.value,
        "input-value": unref(u),
        "onUpdate:inputValue": ie[0] || (ie[0] = (i) => isRef(u) ? u.value = i : null)
      }, re.$props, {
        onClear: we,
        onOpen: G,
        onSetInputDate: Ft,
        onSetEmptyDate: unref(_),
        onSelectDate: O,
        onToggle: xt,
        onClose: Se,
        onFocus: en,
        onBlur: tn,
        onRealBlur: ie[1] || (ie[1] = (i) => S.value = false)
      }), createSlots({ _: 2 }, [
        renderList(unref(w), (i, E) => ({
          name: i,
          fn: withCtx((ne) => [
            renderSlot(re.$slots, i, normalizeProps(guardReactiveProps(ne)))
          ])
        }))
      ]), 1040, ["is-menu-open", "input-value", "onSetEmptyDate"]),
      createVNode(Transition, {
        name: unref(q)(unref(C)),
        css: unref(j) && !unref(A).enabled
      }, {
        default: withCtx(() => [
          l.value ? (openBlock(), createBlock(resolveDynamicComponent(re.teleport ? Teleport : "div"), mergeProps({
            key: 0,
            ref_key: "dpWrapMenuRef",
            ref: p
          }, g.value, {
            class: { "dp--menu-wrapper": !unref(A).enabled },
            style: unref(A).enabled ? void 0 : unref(K)
          }), {
            default: withCtx(() => [
              createVNode(ia, mergeProps({
                ref_key: "dpMenuRef",
                ref: $,
                class: { [N.value]: true, "dp--menu-wrapper": re.teleport },
                style: re.teleport ? unref(K) : void 0,
                "open-on-top": unref(C),
                "arr-map-values": le.value
              }, re.$props, {
                "internal-model-value": unref(y),
                "onUpdate:internalModelValue": ie[2] || (ie[2] = (i) => isRef(y) ? y.value = i : null),
                onClosePicker: Se,
                onSelectDate: O,
                onAutoApply: x,
                onTimeUpdate: Mt,
                onFlowStep: ie[3] || (ie[3] = (i) => re.$emit("flow-step", i)),
                onUpdateMonthYear: ie[4] || (ie[4] = (i) => re.$emit("update-month-year", i)),
                onInvalidSelect: ie[5] || (ie[5] = (i) => re.$emit("invalid-select", unref(y))),
                onInvalidFixedRange: ie[6] || (ie[6] = (i) => re.$emit("invalid-fixed-range", i)),
                onRecalculatePosition: unref(V),
                onTooltipOpen: ie[7] || (ie[7] = (i) => re.$emit("tooltip-open", i)),
                onTooltipClose: ie[8] || (ie[8] = (i) => re.$emit("tooltip-close", i)),
                onTimePickerOpen: ie[9] || (ie[9] = (i) => re.$emit("time-picker-open", i)),
                onTimePickerClose: ie[10] || (ie[10] = (i) => re.$emit("time-picker-close", i)),
                onAmPmChange: ie[11] || (ie[11] = (i) => re.$emit("am-pm-change", i)),
                onRangeStart: ie[12] || (ie[12] = (i) => re.$emit("range-start", i)),
                onRangeEnd: ie[13] || (ie[13] = (i) => re.$emit("range-end", i))
              }), createSlots({ _: 2 }, [
                renderList(unref(f), (i, E) => ({
                  name: i,
                  fn: withCtx((ne) => [
                    renderSlot(re.$slots, i, normalizeProps(guardReactiveProps({ ...ne })))
                  ])
                }))
              ]), 1040, ["class", "style", "open-on-top", "arr-map-values", "internal-model-value", "onRecalculatePosition"])
            ]),
            _: 3
          }, 16, ["class", "style"])) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["name", "css"])
    ], 2));
  }
});
var Ia = (() => {
  const e = ao;
  return e.install = (n) => {
    n.component("Vue3DatePicker", e);
  }, e;
})();
var ro = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: Ia
}, Symbol.toStringTag, { value: "Module" }));
Object.entries(ro).forEach(([e, n]) => {
  e !== "default" && (Ia[e] = n);
});
export {
  Ia as default
};
//# sourceMappingURL=@vuepic_vue-datepicker.js.map
