import { openBlock as D, createElementBlock as Y, createElementVNode as ue, unref as v, reactive as Ot, computed as L, ref as z, toRef as Gt, watch as gt, h as Ba, render as zn, defineComponent as Ee, renderSlot as te, createCommentVNode as B, normalizeClass as he, withKeys as oe, createBlock as ve, withModifiers as pe, onMounted as Ue, normalizeStyle as Ge, normalizeProps as Ce, mergeProps as Be, Fragment as fe, createTextVNode as at, toDisplayString as Ie, onBeforeUpdate as Ea, nextTick as rt, onUnmounted as _n, renderList as Me, withDirectives as Wt, vShow as zt, withCtx as ce, createVNode as qe, Transition as Dt, createSlots as Fe, useSlots as It, guardReactiveProps as He, resolveDynamicComponent as Pn, getCurrentScope as Fa, onScopeDispose as Va, isRef as jn, Teleport as Ha } from "vue";
import { format as dt, isBefore as _t, isEqual as pt, isAfter as Pt, set as ke, setHours as da, setMinutes as ca, setSeconds as fa, setMilliseconds as Cn, getYear as me, getMonth as ge, setMonth as La, setYear as ct, addMonths as ft, subMonths as Ct, isValid as jt, parseISO as Ua, eachDayOfInterval as va, getHours as Je, getMinutes as Xe, getSeconds as bt, startOfWeek as ma, endOfWeek as Wa, parse as kn, isDate as za, addYears as ga, subYears as ya, addDays as it, getDay as ja, differenceInCalendarDays as Ka, add as ha, sub as Ga, getWeek as Za, getISOWeek as qa } from "date-fns";
function Yt() {
  return D(), Y(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      ue("path", {
        d: "M29.333 8c0-2.208-1.792-4-4-4h-18.667c-2.208 0-4 1.792-4 4v18.667c0 2.208 1.792 4 4 4h18.667c2.208 0 4-1.792 4-4v-18.667zM26.667 8v18.667c0 0.736-0.597 1.333-1.333 1.333 0 0-18.667 0-18.667 0-0.736 0-1.333-0.597-1.333-1.333 0 0 0-18.667 0-18.667 0-0.736 0.597-1.333 1.333-1.333 0 0 18.667 0 18.667 0 0.736 0 1.333 0.597 1.333 1.333z"
      }),
      ue("path", {
        d: "M20 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      }),
      ue("path", {
        d: "M9.333 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      }),
      ue("path", {
        d: "M4 14.667h24c0.736 0 1.333-0.597 1.333-1.333s-0.597-1.333-1.333-1.333h-24c-0.736 0-1.333 0.597-1.333 1.333s0.597 1.333 1.333 1.333z"
      })
    ]
  );
}
Yt.compatConfig = {
  MODE: 3
};
function pa() {
  return D(), Y(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      ue("path", {
        d: "M23.057 7.057l-16 16c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l16-16c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0z"
      }),
      ue("path", {
        d: "M7.057 8.943l16 16c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885l-16-16c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
      })
    ]
  );
}
pa.compatConfig = {
  MODE: 3
};
function Rn() {
  return D(), Y(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      ue("path", {
        d: "M20.943 23.057l-7.057-7.057c0 0 7.057-7.057 7.057-7.057 0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-8 8c-0.521 0.521-0.521 1.365 0 1.885l8 8c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
      })
    ]
  );
}
Rn.compatConfig = {
  MODE: 3
};
function Nn() {
  return D(), Y(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      ue("path", {
        d: "M12.943 24.943l8-8c0.521-0.521 0.521-1.365 0-1.885l-8-8c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885l7.057 7.057c0 0-7.057 7.057-7.057 7.057-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0z"
      })
    ]
  );
}
Nn.compatConfig = {
  MODE: 3
};
function On() {
  return D(), Y(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      ue("path", {
        d: "M16 1.333c-8.095 0-14.667 6.572-14.667 14.667s6.572 14.667 14.667 14.667c8.095 0 14.667-6.572 14.667-14.667s-6.572-14.667-14.667-14.667zM16 4c6.623 0 12 5.377 12 12s-5.377 12-12 12c-6.623 0-12-5.377-12-12s5.377-12 12-12z"
      }),
      ue("path", {
        d: "M14.667 8v8c0 0.505 0.285 0.967 0.737 1.193l5.333 2.667c0.658 0.329 1.46 0.062 1.789-0.596s0.062-1.46-0.596-1.789l-4.596-2.298c0 0 0-7.176 0-7.176 0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      })
    ]
  );
}
On.compatConfig = {
  MODE: 3
};
function In() {
  return D(), Y(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      ue("path", {
        d: "M24.943 19.057l-8-8c-0.521-0.521-1.365-0.521-1.885 0l-8 8c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l7.057-7.057c0 0 7.057 7.057 7.057 7.057 0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
      })
    ]
  );
}
In.compatConfig = {
  MODE: 3
};
function Yn() {
  return D(), Y(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      ue("path", {
        d: "M7.057 12.943l8 8c0.521 0.521 1.365 0.521 1.885 0l8-8c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-7.057 7.057c0 0-7.057-7.057-7.057-7.057-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
      })
    ]
  );
}
Yn.compatConfig = {
  MODE: 3
};
function Bn(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var ba = { exports: {} };
(function(e) {
  function n(a) {
    return a && a.__esModule ? a : {
      default: a
    };
  }
  e.exports = n, e.exports.__esModule = !0, e.exports.default = e.exports;
})(ba);
var Ja = ba.exports, wn = { exports: {} };
(function(e, n) {
  Object.defineProperty(n, "__esModule", {
    value: !0
  }), n.default = a;
  function a(t) {
    if (t === null || t === !0 || t === !1)
      return NaN;
    var o = Number(t);
    return isNaN(o) ? o : o < 0 ? Math.ceil(o) : Math.floor(o);
  }
  e.exports = n.default;
})(wn, wn.exports);
var Xa = wn.exports;
const xa = /* @__PURE__ */ Bn(Xa);
var Dn = { exports: {} };
(function(e, n) {
  Object.defineProperty(n, "__esModule", {
    value: !0
  }), n.default = a;
  function a(t) {
    var o = new Date(Date.UTC(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours(), t.getMinutes(), t.getSeconds(), t.getMilliseconds()));
    return o.setUTCFullYear(t.getFullYear()), t.getTime() - o.getTime();
  }
  e.exports = n.default;
})(Dn, Dn.exports);
var Qa = Dn.exports;
const Kn = /* @__PURE__ */ Bn(Qa);
function er(e, n) {
  var a = rr(n);
  return a.formatToParts ? nr(a, e) : ar(a, e);
}
var tr = {
  year: 0,
  month: 1,
  day: 2,
  hour: 3,
  minute: 4,
  second: 5
};
function nr(e, n) {
  try {
    for (var a = e.formatToParts(n), t = [], o = 0; o < a.length; o++) {
      var l = tr[a[o].type];
      l >= 0 && (t[l] = parseInt(a[o].value, 10));
    }
    return t;
  } catch (d) {
    if (d instanceof RangeError)
      return [NaN];
    throw d;
  }
}
function ar(e, n) {
  var a = e.format(n).replace(/\u200E/g, ""), t = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(a);
  return [t[3], t[1], t[2], t[4], t[5], t[6]];
}
var sn = {};
function rr(e) {
  if (!sn[e]) {
    var n = new Intl.DateTimeFormat("en-US", {
      hour12: !1,
      timeZone: "America/New_York",
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    }).format(/* @__PURE__ */ new Date("2014-06-25T04:00:00.123Z")), a = n === "06/25/2014, 00:00:00" || n === "‎06‎/‎25‎/‎2014‎ ‎00‎:‎00‎:‎00";
    sn[e] = a ? new Intl.DateTimeFormat("en-US", {
      hour12: !1,
      timeZone: e,
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    }) : new Intl.DateTimeFormat("en-US", {
      hourCycle: "h23",
      timeZone: e,
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
  }
  return sn[e];
}
function En(e, n, a, t, o, l, d) {
  var M = /* @__PURE__ */ new Date(0);
  return M.setUTCFullYear(e, n, a), M.setUTCHours(t, o, l, d), M;
}
var Gn = 36e5, lr = 6e4, un = {
  timezone: /([Z+-].*)$/,
  timezoneZ: /^(Z)$/,
  timezoneHH: /^([+-]\d{2})$/,
  timezoneHHMM: /^([+-]\d{2}):?(\d{2})$/
};
function Fn(e, n, a) {
  var t, o;
  if (!e || (t = un.timezoneZ.exec(e), t))
    return 0;
  var l;
  if (t = un.timezoneHH.exec(e), t)
    return l = parseInt(t[1], 10), Zn(l) ? -(l * Gn) : NaN;
  if (t = un.timezoneHHMM.exec(e), t) {
    l = parseInt(t[1], 10);
    var d = parseInt(t[2], 10);
    return Zn(l, d) ? (o = Math.abs(l) * Gn + d * lr, l > 0 ? -o : o) : NaN;
  }
  if (ur(e)) {
    n = new Date(n || Date.now());
    var M = a ? n : or(n), p = Mn(M, e), $ = a ? p : sr(n, p, e);
    return -$;
  }
  return NaN;
}
function or(e) {
  return En(
    e.getFullYear(),
    e.getMonth(),
    e.getDate(),
    e.getHours(),
    e.getMinutes(),
    e.getSeconds(),
    e.getMilliseconds()
  );
}
function Mn(e, n) {
  var a = er(e, n), t = En(
    a[0],
    a[1] - 1,
    a[2],
    a[3] % 24,
    a[4],
    a[5],
    0
  ).getTime(), o = e.getTime(), l = o % 1e3;
  return o -= l >= 0 ? l : 1e3 + l, t - o;
}
function sr(e, n, a) {
  var t = e.getTime(), o = t - n, l = Mn(new Date(o), a);
  if (n === l)
    return n;
  o -= l - n;
  var d = Mn(new Date(o), a);
  return l === d ? l : Math.max(l, d);
}
function Zn(e, n) {
  return -23 <= e && e <= 23 && (n == null || 0 <= n && n <= 59);
}
var qn = {};
function ur(e) {
  if (qn[e])
    return !0;
  try {
    return new Intl.DateTimeFormat(void 0, { timeZone: e }), qn[e] = !0, !0;
  } catch {
    return !1;
  }
}
var ka = /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/, dn = 36e5, Jn = 6e4, ir = 2, Ye = {
  dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
  datePattern: /^([0-9W+-]+)(.*)/,
  plainTime: /:/,
  // year tokens
  YY: /^(\d{2})$/,
  YYY: [
    /^([+-]\d{2})$/,
    // 0 additional digits
    /^([+-]\d{3})$/,
    // 1 additional digit
    /^([+-]\d{4})$/
    // 2 additional digits
  ],
  YYYY: /^(\d{4})/,
  YYYYY: [
    /^([+-]\d{4})/,
    // 0 additional digits
    /^([+-]\d{5})/,
    // 1 additional digit
    /^([+-]\d{6})/
    // 2 additional digits
  ],
  // date tokens
  MM: /^-(\d{2})$/,
  DDD: /^-?(\d{3})$/,
  MMDD: /^-?(\d{2})-?(\d{2})$/,
  Www: /^-?W(\d{2})$/,
  WwwD: /^-?W(\d{2})-?(\d{1})$/,
  HH: /^(\d{2}([.,]\d*)?)$/,
  HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
  HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
  // time zone tokens (to identify the presence of a tz)
  timeZone: ka
};
function $n(e, n) {
  if (arguments.length < 1)
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  if (e === null)
    return /* @__PURE__ */ new Date(NaN);
  var a = n || {}, t = a.additionalDigits == null ? ir : xa(a.additionalDigits);
  if (t !== 2 && t !== 1 && t !== 0)
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  if (e instanceof Date || typeof e == "object" && Object.prototype.toString.call(e) === "[object Date]")
    return new Date(e.getTime());
  if (typeof e == "number" || Object.prototype.toString.call(e) === "[object Number]")
    return new Date(e);
  if (!(typeof e == "string" || Object.prototype.toString.call(e) === "[object String]"))
    return /* @__PURE__ */ new Date(NaN);
  var o = dr(e), l = cr(o.date, t), d = l.year, M = l.restDateString, p = fr(M, d);
  if (isNaN(p))
    return /* @__PURE__ */ new Date(NaN);
  if (p) {
    var $ = p.getTime(), h = 0, S;
    if (o.time && (h = vr(o.time), isNaN(h)))
      return /* @__PURE__ */ new Date(NaN);
    if (o.timeZone || a.timeZone) {
      if (S = Fn(o.timeZone || a.timeZone, new Date($ + h)), isNaN(S))
        return /* @__PURE__ */ new Date(NaN);
    } else
      S = Kn(new Date($ + h)), S = Kn(new Date($ + h + S));
    return new Date($ + h + S);
  } else
    return /* @__PURE__ */ new Date(NaN);
}
function dr(e) {
  var n = {}, a = Ye.dateTimePattern.exec(e), t;
  if (a ? (n.date = a[1], t = a[3]) : (a = Ye.datePattern.exec(e), a ? (n.date = a[1], t = a[2]) : (n.date = null, t = e)), t) {
    var o = Ye.timeZone.exec(t);
    o ? (n.time = t.replace(o[1], ""), n.timeZone = o[1].trim()) : n.time = t;
  }
  return n;
}
function cr(e, n) {
  var a = Ye.YYY[n], t = Ye.YYYYY[n], o;
  if (o = Ye.YYYY.exec(e) || t.exec(e), o) {
    var l = o[1];
    return {
      year: parseInt(l, 10),
      restDateString: e.slice(l.length)
    };
  }
  if (o = Ye.YY.exec(e) || a.exec(e), o) {
    var d = o[1];
    return {
      year: parseInt(d, 10) * 100,
      restDateString: e.slice(d.length)
    };
  }
  return {
    year: null
  };
}
function fr(e, n) {
  if (n === null)
    return null;
  var a, t, o, l;
  if (e.length === 0)
    return t = /* @__PURE__ */ new Date(0), t.setUTCFullYear(n), t;
  if (a = Ye.MM.exec(e), a)
    return t = /* @__PURE__ */ new Date(0), o = parseInt(a[1], 10) - 1, xn(n, o) ? (t.setUTCFullYear(n, o), t) : /* @__PURE__ */ new Date(NaN);
  if (a = Ye.DDD.exec(e), a) {
    t = /* @__PURE__ */ new Date(0);
    var d = parseInt(a[1], 10);
    return yr(n, d) ? (t.setUTCFullYear(n, 0, d), t) : /* @__PURE__ */ new Date(NaN);
  }
  if (a = Ye.MMDD.exec(e), a) {
    t = /* @__PURE__ */ new Date(0), o = parseInt(a[1], 10) - 1;
    var M = parseInt(a[2], 10);
    return xn(n, o, M) ? (t.setUTCFullYear(n, o, M), t) : /* @__PURE__ */ new Date(NaN);
  }
  if (a = Ye.Www.exec(e), a)
    return l = parseInt(a[1], 10) - 1, Qn(n, l) ? Xn(n, l) : /* @__PURE__ */ new Date(NaN);
  if (a = Ye.WwwD.exec(e), a) {
    l = parseInt(a[1], 10) - 1;
    var p = parseInt(a[2], 10) - 1;
    return Qn(n, l, p) ? Xn(n, l, p) : /* @__PURE__ */ new Date(NaN);
  }
  return null;
}
function vr(e) {
  var n, a, t;
  if (n = Ye.HH.exec(e), n)
    return a = parseFloat(n[1].replace(",", ".")), cn(a) ? a % 24 * dn : NaN;
  if (n = Ye.HHMM.exec(e), n)
    return a = parseInt(n[1], 10), t = parseFloat(n[2].replace(",", ".")), cn(a, t) ? a % 24 * dn + t * Jn : NaN;
  if (n = Ye.HHMMSS.exec(e), n) {
    a = parseInt(n[1], 10), t = parseInt(n[2], 10);
    var o = parseFloat(n[3].replace(",", "."));
    return cn(a, t, o) ? a % 24 * dn + t * Jn + o * 1e3 : NaN;
  }
  return null;
}
function Xn(e, n, a) {
  n = n || 0, a = a || 0;
  var t = /* @__PURE__ */ new Date(0);
  t.setUTCFullYear(e, 0, 4);
  var o = t.getUTCDay() || 7, l = n * 7 + a + 1 - o;
  return t.setUTCDate(t.getUTCDate() + l), t;
}
var mr = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], gr = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function wa(e) {
  return e % 400 === 0 || e % 4 === 0 && e % 100 !== 0;
}
function xn(e, n, a) {
  if (n < 0 || n > 11)
    return !1;
  if (a != null) {
    if (a < 1)
      return !1;
    var t = wa(e);
    if (t && a > gr[n] || !t && a > mr[n])
      return !1;
  }
  return !0;
}
function yr(e, n) {
  if (n < 1)
    return !1;
  var a = wa(e);
  return !(a && n > 366 || !a && n > 365);
}
function Qn(e, n, a) {
  return !(n < 0 || n > 52 || a != null && (a < 0 || a > 6));
}
function cn(e, n, a) {
  return !(e != null && (e < 0 || e >= 25) || n != null && (n < 0 || n >= 60) || a != null && (a < 0 || a >= 60));
}
var Tn = { exports: {} }, An = { exports: {} };
(function(e, n) {
  Object.defineProperty(n, "__esModule", {
    value: !0
  }), n.default = a;
  function a(t, o) {
    if (t == null)
      throw new TypeError("assign requires that input parameter not be null or undefined");
    for (var l in o)
      Object.prototype.hasOwnProperty.call(o, l) && (t[l] = o[l]);
    return t;
  }
  e.exports = n.default;
})(An, An.exports);
var hr = An.exports;
(function(e, n) {
  var a = Ja.default;
  Object.defineProperty(n, "__esModule", {
    value: !0
  }), n.default = o;
  var t = a(hr);
  function o(l) {
    return (0, t.default)({}, l);
  }
  e.exports = n.default;
})(Tn, Tn.exports);
var pr = Tn.exports;
const br = /* @__PURE__ */ Bn(pr);
function kr(e, n, a) {
  var t = $n(e, a), o = Fn(n, t, !0), l = new Date(t.getTime() - o), d = /* @__PURE__ */ new Date(0);
  return d.setFullYear(l.getUTCFullYear(), l.getUTCMonth(), l.getUTCDate()), d.setHours(l.getUTCHours(), l.getUTCMinutes(), l.getUTCSeconds(), l.getUTCMilliseconds()), d;
}
function wr(e, n, a) {
  if (typeof e == "string" && !e.match(ka)) {
    var t = br(a);
    return t.timeZone = n, $n(e, t);
  }
  var o = $n(e, a), l = En(
    o.getFullYear(),
    o.getMonth(),
    o.getDate(),
    o.getHours(),
    o.getMinutes(),
    o.getSeconds(),
    o.getMilliseconds()
  ).getTime(), d = Fn(n, new Date(l));
  return new Date(l + d);
}
function ea(e) {
  return (n) => new Intl.DateTimeFormat(e, { weekday: "short", timeZone: "UTC" }).format(/* @__PURE__ */ new Date(`2017-01-0${n}T00:00:00+00:00`)).slice(0, 2);
}
function Dr(e) {
  return (n) => dt(/* @__PURE__ */ new Date(`2017-01-0${n}T00:00:00+00:00`), "EEEEEE", { locale: e });
}
const Mr = (e, n, a) => {
  const t = [1, 2, 3, 4, 5, 6, 7];
  let o;
  if (e !== null)
    try {
      o = t.map(Dr(e));
    } catch {
      o = t.map(ea(n));
    }
  else
    o = t.map(ea(n));
  const l = o.slice(0, a), d = o.slice(a + 1, o.length);
  return [o[a]].concat(...d).concat(...l);
}, Vn = (e, n) => {
  const a = [];
  for (let t = +e[0]; t <= +e[1]; t++)
    a.push({ value: +t, text: `${t}` });
  return n ? a.reverse() : a;
}, Da = (e, n, a) => {
  const t = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map((l) => {
    const d = l < 10 ? `0${l}` : l;
    return /* @__PURE__ */ new Date(`2017-${d}-01T00:00:00+00:00`);
  });
  if (e !== null)
    try {
      const l = a === "long" ? "MMMM" : "MMM";
      return t.map((d, M) => {
        const p = dt(d, l, { locale: e });
        return {
          text: p.charAt(0).toUpperCase() + p.substring(1),
          value: M
        };
      });
    } catch {
    }
  const o = new Intl.DateTimeFormat(n, { month: a, timeZone: "UTC" });
  return t.map((l, d) => {
    const M = o.format(l);
    return {
      text: M.charAt(0).toUpperCase() + M.substring(1),
      value: d
    };
  });
}, $r = (e) => [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11][e], Ae = (e) => {
  const n = v(e);
  return n != null && n.$el ? n == null ? void 0 : n.$el : n;
}, Tr = (e) => Object.assign({ type: "dot" }, e), Ma = (e) => Array.isArray(e) ? !!e[0] && !!e[1] : !1, Zt = {
  prop: (e) => `"${e}" prop must be enabled!`,
  dateArr: (e) => `You need to use array as "model-value" binding in order to support "${e}"`
}, Te = (e) => e, ta = (e) => e === 0 ? e : !e || isNaN(+e) ? null : +e, na = (e) => e === null, Ar = (e) => {
  if (e)
    return [...e.querySelectorAll("input, button, select, textarea, a[href]")][0];
}, Sr = (e) => {
  const n = [], a = (t) => t.filter((o) => o);
  for (let t = 0; t < e.length; t += 3) {
    const o = [e[t], e[t + 1], e[t + 2]];
    n.push(a(o));
  }
  return n;
}, Rt = (e, n, a) => {
  const t = a ?? a === 0, o = n ?? n === 0;
  if (!t && !o)
    return !1;
  const l = +a, d = +n;
  return t && o ? +e > l || +e < d : t ? +e > l : o ? +e < d : !1;
}, kt = (e, n) => Sr(e).map((a) => a.map((t) => {
  const { active: o, disabled: l, isBetween: d } = n(t);
  return {
    ...t,
    active: o,
    disabled: l,
    className: {
      dp__overlay_cell_active: o,
      dp__overlay_cell: !o,
      dp__overlay_cell_disabled: l,
      dp__overlay_cell_pad: !0,
      dp__overlay_cell_active_disabled: l && o,
      dp__cell_in_between: d
    }
  };
})), aa = (e, n, a, t, o) => {
  const l = kn(e, n.slice(0, e.length), /* @__PURE__ */ new Date());
  return jt(l) && za(l) ? t || o ? l : ke(l, {
    hours: +a.hours,
    minutes: +(a == null ? void 0 : a.minutes),
    seconds: +(a == null ? void 0 : a.seconds),
    milliseconds: 0
  }) : null;
}, _r = (e, n, a, t, o) => {
  const l = Array.isArray(a) ? a[0] : a;
  if (typeof n == "string")
    return aa(e, n, l, t, o);
  if (Array.isArray(n)) {
    let d = null;
    for (const M of n)
      if (d = aa(e, M, l, t, o), d)
        break;
    return d;
  }
  return typeof n == "function" ? n(e) : null;
}, P = (e) => e ? new Date(e) : /* @__PURE__ */ new Date(), Pr = (e, n, a) => {
  if (n) {
    const o = (e.getMonth() + 1).toString().padStart(2, "0"), l = e.getDate().toString().padStart(2, "0"), d = e.getHours().toString().padStart(2, "0"), M = e.getMinutes().toString().padStart(2, "0"), p = a ? e.getSeconds().toString().padStart(2, "0") : "00";
    return `${e.getFullYear()}-${o}-${l}T${d}:${M}:${p}.000Z`;
  }
  const t = Date.UTC(
    e.getUTCFullYear(),
    e.getUTCMonth(),
    e.getUTCDate(),
    e.getUTCHours(),
    e.getUTCMinutes(),
    e.getUTCSeconds()
  );
  return new Date(t).toISOString();
}, Le = (e) => {
  let n = P(JSON.parse(JSON.stringify(e)));
  return n = da(n, 0), n = ca(n, 0), n = fa(n, 0), n = Cn(n, 0), n;
}, nt = (e, n, a, t) => {
  let o = e ? P(e) : P();
  return (n || n === 0) && (o = da(o, +n)), (a || a === 0) && (o = ca(o, +a)), (t || t === 0) && (o = fa(o, +t)), Cn(o, 0);
}, Pe = (e, n) => !e || !n ? !1 : _t(Le(e), Le(n)), ye = (e, n) => !e || !n ? !1 : pt(Le(e), Le(n)), Ne = (e, n) => !e || !n ? !1 : Pt(Le(e), Le(n)), Hn = (e, n, a) => e != null && e[0] && (e != null && e[1]) ? Ne(a, e[0]) && Pe(a, e[1]) : e != null && e[0] && n ? Ne(a, e[0]) && Pe(a, n) || Pe(a, e[0]) && Ne(a, n) : !1, ze = (e) => {
  const n = ke(new Date(e), { date: 1 });
  return Le(n);
}, fn = (e, n, a) => n && (a || a === 0) ? Object.fromEntries(
  ["hours", "minutes", "seconds"].map((t) => t === n ? [t, a] : [t, isNaN(+e[t]) ? void 0 : +e[t]])
) : {
  hours: isNaN(+e.hours) ? void 0 : +e.hours,
  minutes: isNaN(+e.minutes) ? void 0 : +e.minutes,
  seconds: isNaN(+e.seconds) ? void 0 : +e.seconds
}, vt = (e) => ({
  hours: Je(e),
  minutes: Xe(e),
  seconds: bt(e)
}), $a = (e, n) => {
  if (n) {
    const a = me(P(n));
    if (a > e)
      return 12;
    if (a === e)
      return ge(P(n));
  }
}, Ta = (e, n) => {
  if (n) {
    const a = me(P(n));
    return a < e ? -1 : a === e ? ge(P(n)) : void 0;
  }
}, wt = (e) => {
  if (e)
    return me(P(e));
}, Ze = (e, n) => n ? kr(e, n) : e, Cr = (e, n) => n ? wr(e, n) : e, ra = (e) => e instanceof Date ? e : Ua(e), Aa = (e, n) => {
  const a = Ne(e, n) ? n : e, t = Ne(n, e) ? n : e;
  return va({ start: a, end: t });
}, Rr = (e) => {
  const n = ft(e, 1);
  return { month: ge(n), year: me(n) };
}, Kt = (e, n, a) => {
  const t = ma(Ze(e, n), { weekStartsOn: +a }), o = Wa(Ze(e, n), { weekStartsOn: +a });
  return [t, o];
}, Sa = (e, n) => {
  const a = {
    hours: Je(P()),
    minutes: Xe(P()),
    seconds: n ? bt(P()) : 0
  };
  return Object.assign(a, e);
}, tt = (e, n, a) => [ke(P(e), { date: 1 }), ke(P(), { month: n, year: a, date: 1 })], xe = (e, n, a) => {
  let t = e ? P(e) : P();
  return (n || n === 0) && (t = La(t, n)), a && (t = ct(t, a)), t;
}, _a = (e, n, a, t, o) => {
  if (!t || o && !n || !o && !a)
    return !1;
  const l = o ? ft(e, 1) : Ct(e, 1), d = [ge(l), me(l)];
  return o ? !Or(...d, n) : !Nr(...d, a);
}, Nr = (e, n, a) => Pe(...tt(a, e, n)) || ye(...tt(a, e, n)), Or = (e, n, a) => Ne(...tt(a, e, n)) || ye(...tt(a, e, n)), Pa = (e, n, a, t, o, l) => {
  if (typeof n == "function")
    return n(e);
  const d = a ? { locale: a } : void 0;
  return Array.isArray(e) ? `${dt(e[0], l, d)}${o && !e[1] ? "" : t}${e[1] ? dt(e[1], l, d) : ""}` : dt(e, l, d);
}, yt = (e) => {
  if (e)
    return null;
  throw new Error(Zt.prop("partial-range"));
}, Lt = (e, n) => {
  if (n)
    return e();
  throw new Error(Zt.prop("range"));
}, Sn = (e) => Array.isArray(e) ? jt(e[0]) && (e[1] ? jt(e[1]) : !0) : e ? jt(e) : !1, Ir = (e) => ke(P(), {
  hours: +e.hours || 0,
  minutes: +e.minutes || 0,
  seconds: +e.seconds || 0
}), vn = (e, n, a, t) => {
  if (!e)
    return !0;
  if (t) {
    const o = a === "max" ? _t(e, n) : Pt(e, n), l = { seconds: 0, milliseconds: 0 };
    return o || pt(ke(e, l), ke(n, l));
  }
  return a === "max" ? e.getTime() <= n.getTime() : e.getTime() >= n.getTime();
}, la = (e, n, a, t, o) => {
  const l = e ? Ir(e) : P(n);
  return Array.isArray(t) ? vn(t[0], l, a, !!n) && vn(t[1], l, a, !!n) && o : vn(t, l, a, !!n) && o;
}, mn = (e) => ke(P(), vt(e)), Yr = (e, n) => Array.isArray(e) ? e.map((a) => P(a)).filter((a) => me(P(a)) === n).map((a) => ge(a)) : [], At = Ot({
  menuFocused: !1,
  shiftKeyInMenu: !1
}), Ca = () => {
  const e = (t) => {
    At.menuFocused = t;
  }, n = (t) => {
    At.shiftKeyInMenu !== t && (At.shiftKeyInMenu = t);
  };
  return {
    control: L(() => ({ shiftKeyInMenu: At.shiftKeyInMenu, menuFocused: At.menuFocused })),
    setMenuFocused: e,
    setShiftKey: n
  };
}, be = Ot({
  monthYear: [],
  calendar: [],
  time: [],
  actionRow: [],
  selectionGrid: [],
  timePicker: {
    0: [],
    1: []
  },
  monthPicker: []
}), gn = z(null), Ut = z(!1), yn = z(!1), hn = z(!1), pn = z(!1), Oe = z(0), _e = z(0), lt = () => {
  const e = L(() => Ut.value ? [...be.selectionGrid, be.actionRow].filter((k) => k.length) : yn.value ? [
    ...be.timePicker[0],
    ...be.timePicker[1],
    pn.value ? [] : [gn.value],
    be.actionRow
  ].filter((k) => k.length) : hn.value ? [...be.monthPicker, be.actionRow] : [be.monthYear, ...be.calendar, be.time, be.actionRow].filter((k) => k.length)), n = (k) => {
    Oe.value = k ? Oe.value + 1 : Oe.value - 1;
    let T = null;
    e.value[_e.value] && (T = e.value[_e.value][Oe.value]), T || (Oe.value = k ? Oe.value - 1 : Oe.value + 1);
  }, a = (k) => {
    if (_e.value === 0 && !k || _e.value === e.value.length && k)
      return;
    _e.value = k ? _e.value + 1 : _e.value - 1, e.value[_e.value] ? e.value[_e.value] && !e.value[_e.value][Oe.value] && Oe.value !== 0 && (Oe.value = e.value[_e.value].length - 1) : _e.value = k ? _e.value - 1 : _e.value + 1;
  }, t = (k) => {
    let T = null;
    e.value[_e.value] && (T = e.value[_e.value][Oe.value]), T ? T.focus({ preventScroll: !Ut.value }) : Oe.value = k ? Oe.value - 1 : Oe.value + 1;
  }, o = () => {
    n(!0), t(!0);
  }, l = () => {
    n(!1), t(!1);
  }, d = () => {
    a(!1), t(!0);
  }, M = () => {
    a(!0), t(!0);
  }, p = (k, T) => {
    be[T] = k;
  }, $ = (k, T) => {
    be[T] = k;
  }, h = () => {
    Oe.value = 0, _e.value = 0;
  };
  return {
    buildMatrix: p,
    buildMultiLevelMatrix: $,
    setTimePickerBackRef: (k) => {
      gn.value = k;
    },
    setSelectionGrid: (k) => {
      Ut.value = k, h(), k || (be.selectionGrid = []);
    },
    setTimePicker: (k, T = !1) => {
      yn.value = k, pn.value = T, h(), k || (be.timePicker[0] = [], be.timePicker[1] = []);
    },
    setTimePickerElements: (k, T = 0) => {
      be.timePicker[T] = k;
    },
    arrowRight: o,
    arrowLeft: l,
    arrowUp: d,
    arrowDown: M,
    clearArrowNav: () => {
      be.monthYear = [], be.calendar = [], be.time = [], be.actionRow = [], be.selectionGrid = [], be.timePicker[0] = [], be.timePicker[1] = [], Ut.value = !1, yn.value = !1, pn.value = !1, hn.value = !1, h(), gn.value = null;
    },
    setMonthPicker: (k) => {
      hn.value = k, h();
    },
    refSets: be
    // exposed for testing
  };
}, oa = (e) => ({
  menuAppearTop: "dp-menu-appear-top",
  menuAppearBottom: "dp-menu-appear-bottom",
  open: "dp-slide-down",
  close: "dp-slide-up",
  next: "calendar-next",
  previous: "calendar-prev",
  vNext: "dp-slide-up",
  vPrevious: "dp-slide-down",
  ...e ?? {}
}), Br = (e) => ({
  toggleOverlay: "Toggle overlay",
  menu: "Datepicker menu",
  input: "Datepicker input",
  calendarWrap: "Calendar wrapper",
  calendarDays: "Calendar days",
  openTimePicker: "Open time picker",
  closeTimePicker: "Close time Picker",
  incrementValue: (n) => `Increment ${n}`,
  decrementValue: (n) => `Decrement ${n}`,
  openTpOverlay: (n) => `Open ${n} overlay`,
  amPmButton: "Switch AM/PM mode",
  openYearsOverlay: "Open years overlay",
  openMonthsOverlay: "Open months overlay",
  nextMonth: "Next month",
  prevMonth: "Previous month",
  nextYear: "Next year",
  prevYear: "Previous year",
  day: () => "",
  ...e ?? {}
}), sa = (e) => e ? typeof e == "boolean" ? e ? 2 : 0 : +e >= 2 ? +e : 2 : 0, Er = (e) => {
  const n = typeof e == "object" && e, a = {
    static: !0,
    solo: !1
  };
  if (!e)
    return { ...a, count: sa(!1) };
  const t = n ? e : {}, o = n ? t.count ?? !0 : e, l = sa(o);
  return Object.assign(a, t, { count: l });
}, Fr = (e, n, a) => e || (typeof a == "string" ? a : n), Vr = (e) => typeof e == "boolean" ? e ? oa({}) : !1 : oa(e), Hr = (e) => {
  const n = {
    enterSubmit: !0,
    tabSubmit: !0,
    openMenu: !0,
    rangeSeparator: " - "
  };
  return typeof e == "object" ? { ...n, ...e ?? {}, enabled: !0 } : { ...n, enabled: e };
}, Lr = (e) => ({
  months: [],
  years: [],
  times: { hours: [], minutes: [], seconds: [] },
  ...e ?? {}
}), Ur = (e) => ({
  showSelect: !0,
  showCancel: !0,
  showNow: !1,
  showPreview: !0,
  ...e ?? {}
}), Wr = (e) => {
  const n = { input: !1 };
  return typeof e == "object" ? { ...n, ...e ?? {}, enabled: !0 } : {
    enabled: e,
    ...n
  };
}, Re = (e) => {
  const n = () => {
    const W = e.enableSeconds ? ":ss" : "";
    return e.is24 ? `HH:mm${W}` : `hh:mm${W} aa`;
  }, a = () => e.format ? e.format : e.monthPicker ? "MM/yyyy" : e.timePicker ? n() : e.weekPicker ? "MM/dd/yyyy" : e.yearPicker ? "yyyy" : e.enableTimePicker ? `MM/dd/yyyy, ${n()}` : "MM/dd/yyyy", t = (W) => Sa(W, e.enableSeconds), o = () => e.range ? e.startTime && Array.isArray(e.startTime) ? [t(e.startTime[0]), t(e.startTime[1])] : null : e.startTime && !Array.isArray(e.startTime) ? t(e.startTime) : null, l = L(() => Er(e.multiCalendars)), d = L(() => o()), M = L(() => Br(e.ariaLabels)), p = L(() => Lr(e.filters)), $ = L(() => Vr(e.transitions)), h = L(() => Ur(e.actionRow)), S = L(
    () => Fr(e.previewFormat, e.format, a())
  ), R = L(() => Hr(e.textInput)), J = L(() => Wr(e.inline));
  return {
    defaultedTransitions: $,
    defaultedMultiCalendars: l,
    defaultedStartTime: d,
    defaultedAriaLabels: M,
    defaultedFilters: p,
    defaultedActionRow: h,
    defaultedPreviewFormat: S,
    defaultedTextInput: R,
    defaultedInline: J,
    getDefaultPattern: a,
    getDefaultStartTime: o
  };
}, zr = (e, n, a) => {
  const t = z(), { defaultedTextInput: o, getDefaultPattern: l } = Re(n), d = z(""), M = Gt(n, "format");
  gt(t, () => {
    e("internal-model-change", t.value);
  }), gt(M, () => {
    V();
  });
  const p = (r) => Cr(r, n.timezone), $ = (r) => Ze(r, n.timezone), h = (r, U) => Pa(
    r,
    n.format,
    n.formatLocale,
    o.value.rangeSeparator,
    n.modelAuto,
    U ?? l()
  ), S = (r) => {
    const U = r ?? P();
    return n.modelType ? m(U) : {
      hours: Je(U),
      minutes: Xe(U),
      seconds: n.enableSeconds ? bt(U) : 0
    };
  }, R = (r) => n.modelType ? m(r) : { month: ge(r), year: me(r) }, J = (r) => Array.isArray(r) ? Lt(
    () => [
      ct(P(), r[0]),
      r[1] ? ct(P(), r[1]) : yt(n.partialRange)
    ],
    n.range
  ) : ct(P(), +r), W = (r, U) => (typeof r == "string" || typeof r == "number") && n.modelType ? b(r) : U, Q = (r) => Array.isArray(r) ? [
    W(
      r[0],
      nt(null, +r[0].hours, +r[0].minutes, r[0].seconds)
    ),
    W(
      r[1],
      nt(null, +r[1].hours, +r[1].minutes, r[1].seconds)
    )
  ] : W(r, nt(null, r.hours, r.minutes, r.seconds)), Z = (r) => Array.isArray(r) ? n.multiDates ? r.map((U) => W(U, xe(null, +U.month, +U.year))) : Lt(
    () => [
      W(r[0], xe(null, +r[0].month, +r[0].year)),
      W(
        r[1],
        r[1] ? xe(null, +r[1].month, +r[1].year) : yt(n.partialRange)
      )
    ],
    n.range
  ) : W(r, xe(null, +r.month, +r.year)), k = (r) => {
    if (Array.isArray(r))
      return r.map((U) => b(U));
    throw new Error(Zt.dateArr("multi-dates"));
  }, T = (r) => {
    if (Array.isArray(r))
      return [P(r[0]), P(r[1])];
    throw new Error(Zt.dateArr("week-picker"));
  }, I = (r) => n.modelAuto ? Array.isArray(r) ? [b(r[0]), b(r[1])] : n.autoApply ? [b(r)] : [b(r), null] : Array.isArray(r) ? Lt(
    () => [
      b(r[0]),
      r[1] ? b(r[1]) : yt(n.partialRange)
    ],
    n.range
  ) : b(r), H = () => {
    Array.isArray(t.value) && n.range && t.value.length === 1 && t.value.push(yt(n.partialRange));
  }, A = () => {
    const r = t.value;
    return [
      m(r[0]),
      r[1] ? m(r[1]) : yt(n.partialRange)
    ];
  }, q = () => t.value[1] ? A() : m(Te(t.value[0])), j = () => (t.value || []).map((r) => m(r)), le = () => (H(), n.modelAuto ? q() : n.multiDates ? j() : Array.isArray(t.value) ? Lt(() => A(), n.range) : m(Te(t.value))), f = (r) => !r || Array.isArray(r) && !r.length ? null : n.timePicker ? Q(Te(r)) : n.monthPicker ? Z(Te(r)) : n.yearPicker ? J(Te(r)) : n.multiDates ? k(Te(r)) : n.weekPicker ? T(Te(r)) : I(Te(r)), w = (r) => {
    const U = f(r);
    Sn(Te(U)) ? (t.value = Te(U), V()) : (t.value = null, d.value = "");
  }, C = () => {
    const r = (U) => dt(U, o.value.format);
    return `${r(t.value[0])} ${o.value.rangeSeparator} ${t.value[1] ? r(t.value[1]) : ""}`;
  }, K = () => a.value && t.value ? Array.isArray(t.value) ? C() : dt(t.value, o.value.format) : h(t.value), c = () => t.value ? n.multiDates ? t.value.map((r) => h(r)).join("; ") : o.value.enabled && typeof o.value.format == "string" ? K() : h(t.value) : "", V = () => {
    !n.format || typeof n.format == "string" || o.value.enabled && typeof o.value.format == "string" ? d.value = c() : d.value = n.format(t.value);
  }, b = (r) => {
    if (n.utc) {
      const U = new Date(r);
      return n.utc === "preserve" ? new Date(U.getTime() + U.getTimezoneOffset() * 6e4) : U;
    }
    return n.modelType ? n.modelType === "date" || n.modelType === "timestamp" ? $(new Date(r)) : n.modelType === "format" && (typeof n.format == "string" || !n.format) ? kn(r, l(), /* @__PURE__ */ new Date()) : $(kn(r, n.modelType, /* @__PURE__ */ new Date())) : $(new Date(r));
  }, m = (r) => r ? n.utc ? Pr(r, n.utc === "preserve", n.enableSeconds) : n.modelType ? n.modelType === "timestamp" ? +p(r) : n.modelType === "format" && (typeof n.format == "string" || !n.format) ? h(p(r)) : h(p(r), n.modelType) : p(r) : "", u = (r, U = !1) => {
    if (e("update:model-value", r), n.emitTimezone && U) {
      const N = Array.isArray(r) ? r.map((g) => Ze(Te(g)), n.emitTimezone) : Ze(Te(r), n.emitTimezone);
      e("update:model-timezone-value", N);
    }
  }, y = (r) => Array.isArray(t.value) ? n.multiDates ? t.value.map((U) => r(U)) : [
    r(t.value[0]),
    t.value[1] ? r(t.value[1]) : yt(n.partialRange)
  ] : r(Te(t.value)), s = (r) => u(Te(y(r)));
  return {
    inputValue: d,
    internalModelValue: t,
    checkBeforeEmit: () => t.value ? n.range ? n.partialRange ? t.value.length >= 1 : t.value.length === 2 : !!t.value : !1,
    parseExternalModelValue: w,
    formatInputValue: V,
    emitModelValue: () => (V(), n.monthPicker ? s(R) : n.timePicker ? s(S) : n.yearPicker ? s(me) : n.weekPicker ? u(t.value, !0) : u(le(), !0))
  };
}, jr = (e, n) => {
  const { defaultedFilters: a } = Re(e), { validateMonthYearInRange: t } = Et(e), o = ($, h) => {
    let S = $;
    return a.value.months.includes(ge(S)) ? (S = h ? ft($, 1) : Ct($, 1), o(S, h)) : S;
  }, l = ($, h) => {
    let S = $;
    return a.value.years.includes(me(S)) ? (S = h ? ga($, 1) : ya($, 1), l(S, h)) : S;
  }, d = ($, h = !1) => {
    const S = ke(/* @__PURE__ */ new Date(), { month: e.month, year: e.year });
    let R = $ ? ft(S, 1) : Ct(S, 1);
    e.disableYearSelect && (R = ct(R, e.year));
    let J = ge(R), W = me(R);
    a.value.months.includes(J) && (R = o(R, $), J = ge(R), W = me(R)), a.value.years.includes(W) && (R = l(R, $), W = me(R)), t(J, W, $, e.preventMinMaxNavigation) && M(J, W, h);
  }, M = ($, h, S) => {
    n("update-month-year", { month: $, year: h, fromNav: S });
  }, p = L(() => ($) => _a(
    ke(/* @__PURE__ */ new Date(), { month: e.month, year: e.year }),
    e.maxDate,
    e.minDate,
    e.preventMinMaxNavigation,
    $
  ));
  return { handleMonthYearChange: d, isDisabled: p, updateMonthYear: M };
};
var ht = /* @__PURE__ */ ((e) => (e.center = "center", e.left = "left", e.right = "right", e))(ht || {}), We = /* @__PURE__ */ ((e) => (e.month = "month", e.year = "year", e))(We || {}), ut = /* @__PURE__ */ ((e) => (e.top = "top", e.bottom = "bottom", e))(ut || {}), mt = /* @__PURE__ */ ((e) => (e.header = "header", e.calendar = "calendar", e.timePicker = "timePicker", e))(mt || {}), Ke = /* @__PURE__ */ ((e) => (e.month = "month", e.year = "year", e.calendar = "calendar", e.time = "time", e.minutes = "minutes", e.hours = "hours", e.seconds = "seconds", e))(Ke || {});
const Kr = ({
  menuRef: e,
  menuRefInner: n,
  inputRef: a,
  pickerWrapperRef: t,
  inline: o,
  emit: l,
  props: d,
  slots: M
}) => {
  const p = z({}), $ = z(!1), h = z({
    top: "0",
    left: "0"
  }), S = z(!1), R = Gt(d, "teleportCenter");
  gt(R, () => {
    h.value = JSON.parse(JSON.stringify({})), H();
  });
  const J = (m) => {
    if (d.teleport) {
      const u = m.getBoundingClientRect();
      return {
        left: u.left + window.scrollX,
        top: u.top + window.scrollY
      };
    }
    return { top: 0, left: 0 };
  }, W = (m, u) => {
    h.value.left = `${m + u - p.value.width}px`;
  }, Q = (m) => {
    h.value.left = `${m}px`;
  }, Z = (m, u) => {
    d.position === ht.left && Q(m), d.position === ht.right && W(m, u), d.position === ht.center && (h.value.left = `${m + u / 2 - p.value.width / 2}px`);
  }, k = (m) => {
    const { width: u, height: y } = m.getBoundingClientRect(), { top: s, left: _ } = d.altPosition ? d.altPosition(m) : J(m);
    return { top: +s, left: +_, width: u, height: y };
  }, T = () => {
    h.value.left = "50%", h.value.top = "50%", h.value.transform = "translate(-50%, -50%)", h.value.position = "fixed", delete h.value.opacity;
  }, I = () => {
    const m = Ae(a), { top: u, left: y, transform: s } = d.altPosition(m);
    h.value = { top: `${u}px`, left: `${y}px`, transform: s ?? "" };
  }, H = (m = !0) => {
    var u;
    if (!o.value.enabled) {
      if (R.value)
        return T();
      if (d.altPosition !== null)
        return I();
      if (m) {
        const y = d.teleport ? (u = n.value) == null ? void 0 : u.$el : e.value;
        y && (p.value = y.getBoundingClientRect()), l("recalculate-position");
      }
      return C();
    }
  }, A = ({ inputEl: m, left: u, width: y }) => {
    window.screen.width > 768 && !$.value && Z(u, y), le(m);
  }, q = (m) => {
    const { top: u, left: y, height: s, width: _ } = k(m);
    h.value.top = `${s + u + +d.offset}px`, S.value = !1, $.value || (h.value.left = `${y + _ / 2 - p.value.width / 2}px`), A({ inputEl: m, left: y, width: _ });
  }, j = (m) => {
    const { top: u, left: y, width: s } = k(m);
    h.value.top = `${u - +d.offset - p.value.height}px`, S.value = !0, A({ inputEl: m, left: y, width: s });
  }, le = (m) => {
    if (d.autoPosition) {
      const { left: u, width: y } = k(m), { left: s, right: _ } = p.value;
      if (!$.value) {
        if (Math.abs(s) !== Math.abs(_)) {
          if (s <= 0)
            return $.value = !0, Q(u);
          if (_ >= document.documentElement.clientWidth)
            return $.value = !0, W(u, y);
        }
        return Z(u, y);
      }
    }
  }, f = () => {
    const m = Ae(a);
    if (m) {
      const { height: u } = p.value, { top: y, height: s } = m.getBoundingClientRect(), ee = window.innerHeight - y - s, r = y;
      return u <= ee ? ut.bottom : u > ee && u <= r ? ut.top : ee >= r ? ut.bottom : ut.top;
    }
    return ut.bottom;
  }, w = (m) => f() === ut.bottom ? q(m) : j(m), C = () => {
    const m = Ae(a);
    if (m)
      return d.autoPosition ? w(m) : q(m);
  }, K = function(m) {
    if (m) {
      const u = m.scrollHeight > m.clientHeight, s = window.getComputedStyle(m).overflowY.indexOf("hidden") !== -1;
      return u && !s;
    }
    return !0;
  }, c = function(m) {
    return !m || m === document.body || m.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? window : K(m) ? m : c(m.parentNode);
  }, V = (m) => {
    if (m)
      switch (d.position) {
        case ht.left:
          return { left: 0, transform: "translateX(0)" };
        case ht.right:
          return { left: `${m.width}px`, transform: "translateX(-100%)" };
        default:
          return { left: `${m.width / 2}px`, transform: "translateX(-50%)" };
      }
    return {};
  };
  return {
    openOnTop: S,
    menuStyle: h,
    xCorrect: $,
    setMenuPosition: H,
    getScrollableParent: c,
    shadowRender: (m, u) => {
      var N, g, F;
      const y = document.createElement("div"), s = (N = Ae(a)) == null ? void 0 : N.getBoundingClientRect();
      y.setAttribute("id", "dp--temp-container");
      const _ = (g = t.value) != null && g.clientWidth ? t.value : document.body;
      _.append(y);
      const ee = document.getElementById("dp--temp-container"), r = V(s), U = Ba(
        m,
        {
          ...u,
          shadow: !0,
          style: { opacity: 0, position: "absolute", ...r }
        },
        Object.fromEntries(Object.keys(M).map((ae) => [ae, M[ae]]))
      );
      zn(U, ee), p.value = (F = U.el) == null ? void 0 : F.getBoundingClientRect(), zn(null, ee), _.removeChild(ee);
    }
  };
}, st = [
  { name: "clock-icon", use: ["time", "calendar", "shared"] },
  { name: "arrow-left", use: ["month-year", "calendar", "shared"] },
  { name: "arrow-right", use: ["month-year", "calendar", "shared"] },
  { name: "arrow-up", use: ["time", "calendar", "month-year", "shared"] },
  { name: "arrow-down", use: ["time", "calendar", "month-year", "shared"] },
  { name: "calendar-icon", use: ["month-year", "time", "calendar", "shared"] },
  { name: "day", use: ["calendar", "shared"] },
  { name: "month-overlay-value", use: ["calendar", "month-year", "shared"] },
  { name: "year-overlay-value", use: ["calendar", "month-year", "shared"] },
  { name: "year-overlay", use: ["month-year", "shared"] },
  { name: "month-overlay", use: ["month-year", "shared"] },
  { name: "month-overlay-header", use: ["month-year", "shared"] },
  { name: "year-overlay-header", use: ["month-year", "shared"] },
  { name: "hours-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "minutes-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "seconds-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "hours", use: ["calendar", "time", "shared"] },
  { name: "minutes", use: ["calendar", "time", "shared"] },
  { name: "month", use: ["calendar", "month-year", "shared"] },
  { name: "year", use: ["calendar", "month-year", "shared"] },
  { name: "action-buttons", use: ["action"] },
  { name: "action-preview", use: ["action"] },
  { name: "calendar-header", use: ["calendar", "shared"] },
  { name: "marker-tooltip", use: ["calendar", "shared"] },
  { name: "action-extra", use: ["menu"] },
  { name: "time-picker-overlay", use: ["calendar", "time", "shared"] },
  { name: "am-pm-button", use: ["calendar", "time", "shared"] },
  { name: "left-sidebar", use: ["menu"] },
  { name: "right-sidebar", use: ["menu"] },
  { name: "month-year", use: ["month-year", "shared"] },
  { name: "time-picker", use: ["menu", "shared"] },
  { name: "action-row", use: ["action"] },
  { name: "marker", use: ["calendar", "shared"] }
], Gr = [{ name: "trigger" }, { name: "input-icon" }, { name: "clear-icon" }, { name: "dp-input" }], Zr = {
  all: () => st,
  monthYear: () => st.filter((e) => e.use.includes("month-year")),
  input: () => Gr,
  timePicker: () => st.filter((e) => e.use.includes("time")),
  action: () => st.filter((e) => e.use.includes("action")),
  calendar: () => st.filter((e) => e.use.includes("calendar")),
  menu: () => st.filter((e) => e.use.includes("menu")),
  shared: () => st.filter((e) => e.use.includes("shared"))
}, je = (e, n, a) => {
  const t = [];
  return Zr[n]().forEach((o) => {
    e[o.name] && t.push(o.name);
  }), a != null && a.length && a.forEach((o) => {
    o.slot && t.push(o.slot);
  }), t;
}, Bt = (e) => {
  const n = L(() => (t) => e.value ? t ? e.value.open : e.value.close : ""), a = L(() => (t) => e.value ? t ? e.value.menuAppearTop : e.value.menuAppearBottom : "");
  return { transitionName: n, showTransition: !!e.value, menuTransition: a };
}, qt = (e, n) => {
  const a = z([{ month: ge(P()), year: me(P()) }]), t = Ot({
    hours: e.range ? [Je(P()), Je(P())] : Je(P()),
    minutes: e.range ? [Xe(P()), Xe(P())] : Xe(P()),
    seconds: e.range ? [0, 0] : 0
  }), o = L({
    get: () => e.internalModelValue,
    set: (M) => {
      !e.readonly && !e.disabled && n("update:internal-model-value", M);
    }
  }), l = L(
    () => (M) => a.value[M] ? a.value[M].month : 0
  ), d = L(
    () => (M) => a.value[M] ? a.value[M].year : 0
  );
  return {
    calendars: a,
    time: t,
    modelValue: o,
    month: l,
    year: d
  };
}, qr = (e, n) => {
  const { defaultedMultiCalendars: a } = Re(n), { isDisabled: t, matchDate: o } = Et(n), l = z(null), d = z(P()), M = (s) => {
    !s.current && n.hideOffsetDates || (l.value = s.value);
  }, p = () => {
    l.value = null;
  }, $ = (s) => Array.isArray(e.value) && n.range && e.value[0] && l.value ? s ? Ne(l.value, e.value[0]) : Pe(l.value, e.value[0]) : !0, h = (s, _) => {
    const ee = () => e.value ? _ ? e.value[0] || null : e.value[1] : null, r = e.value && Array.isArray(e.value) ? ee() : null;
    return ye(P(s.value), r);
  }, S = (s) => {
    const _ = Array.isArray(e.value) ? e.value[0] : null;
    return s ? !Pe(l.value ?? null, _) : !0;
  }, R = (s, _ = !0) => (n.range || n.weekPicker) && Array.isArray(e.value) && e.value.length === 2 ? n.hideOffsetDates && !s.current ? !1 : ye(P(s.value), e.value[_ ? 0 : 1]) : n.range ? h(s, _) && S(_) || ye(s.value, Array.isArray(e.value) ? e.value[0] : null) && $(_) : !1, J = (s, _, ee) => Array.isArray(e.value) && e.value[0] && e.value.length === 1 ? s ? !1 : ee ? Ne(e.value[0], _.value) : Pe(e.value[0], _.value) : !1, W = (s) => !e.value || n.hideOffsetDates && !s.current ? !1 : n.range ? n.modelAuto && Array.isArray(e.value) ? ye(s.value, e.value[0] ? e.value[0] : d.value) : !1 : n.multiDates && Array.isArray(e.value) ? e.value.some((_) => ye(_, s.value)) : ye(s.value, e.value ? e.value : d.value), Q = (s) => {
    if (n.autoRange || n.weekPicker) {
      if (l.value) {
        if (n.hideOffsetDates && !s.current)
          return !1;
        const _ = it(l.value, +n.autoRange), ee = Kt(P(l.value), n.timezone, n.weekStart);
        return n.weekPicker ? ye(ee[1], P(s.value)) : ye(_, P(s.value));
      }
      return !1;
    }
    return !1;
  }, Z = (s) => {
    if (n.autoRange || n.weekPicker) {
      if (l.value) {
        const _ = it(l.value, +n.autoRange);
        if (n.hideOffsetDates && !s.current)
          return !1;
        const ee = Kt(P(l.value), n.timezone, n.weekStart);
        return n.weekPicker ? Ne(s.value, ee[0]) && Pe(s.value, ee[1]) : Ne(s.value, l.value) && Pe(s.value, _);
      }
      return !1;
    }
    return !1;
  }, k = (s) => {
    if (n.autoRange || n.weekPicker) {
      if (l.value) {
        if (n.hideOffsetDates && !s.current)
          return !1;
        const _ = Kt(P(l.value), n.timezone, n.weekStart);
        return n.weekPicker ? ye(_[0], s.value) : ye(l.value, s.value);
      }
      return !1;
    }
    return !1;
  }, T = (s) => Hn(e.value, l.value, s.value), I = () => n.modelAuto && Array.isArray(n.internalModelValue) ? !!n.internalModelValue[0] : !1, H = () => n.modelAuto ? Ma(n.internalModelValue) : !0, A = (s) => {
    if (Array.isArray(e.value) && e.value.length || n.weekPicker)
      return !1;
    const _ = n.range ? !R(s) && !R(s, !1) : !0;
    return !t(s.value) && !W(s) && !(!s.current && n.hideOffsetDates) && _;
  }, q = (s) => n.range ? n.modelAuto ? I() && W(s) : !1 : W(s), j = (s) => {
    var _;
    return n.highlight ? o(
      s.value,
      (_ = n.arrMapValues) != null && _.highlightedDates ? n.arrMapValues.highlightedDates : n.highlight
    ) : !1;
  }, le = (s) => t(s.value) && n.highlightDisabledDays === !1, f = (s) => {
    var _;
    return (_ = n.highlightWeekDays) == null ? void 0 : _.includes(s.value.getDay());
  }, w = (s) => (n.range || n.weekPicker) && (!(a.value.count > 0) || s.current) && H() && !(!s.current && n.hideOffsetDates) && !W(s) ? T(s) : !1, C = (s) => {
    const { isRangeStart: _, isRangeEnd: ee } = V(s), r = n.range ? _ || ee : !1;
    return {
      dp__cell_offset: !s.current,
      dp__pointer: !n.disabled && !(!s.current && n.hideOffsetDates) && !t(s.value),
      dp__cell_disabled: t(s.value),
      dp__cell_highlight: !le(s) && (j(s) || f(s)) && !q(s) && !r,
      dp__cell_highlight_active: !le(s) && (j(s) || f(s)) && q(s),
      dp__today: !n.noToday && ye(s.value, d.value) && s.current
    };
  }, K = (s) => ({
    dp__active_date: q(s),
    dp__date_hover: A(s)
  }), c = (s) => ({
    ...b(s),
    ...m(s),
    dp__range_between_week: w(s) && n.weekPicker
  }), V = (s) => {
    const _ = a.value.count > 0 ? s.current && R(s) && H() : R(s) && H(), ee = a.value.count > 0 ? s.current && R(s, !1) && H() : R(s, !1) && H();
    return { isRangeStart: _, isRangeEnd: ee };
  }, b = (s) => {
    const { isRangeStart: _, isRangeEnd: ee } = V(s);
    return {
      dp__range_start: _,
      dp__range_end: ee,
      dp__range_between: w(s) && !n.weekPicker,
      dp__date_hover_start: J(A(s), s, !0),
      dp__date_hover_end: J(A(s), s, !1)
    };
  }, m = (s) => ({
    ...b(s),
    dp__cell_auto_range: Z(s),
    dp__cell_auto_range_start: k(s),
    dp__cell_auto_range_end: Q(s)
  }), u = (s) => n.range ? n.autoRange ? m(s) : n.modelAuto ? { ...K(s), ...b(s) } : b(s) : n.weekPicker ? c(s) : K(s);
  return {
    setHoverDate: M,
    clearHoverDate: p,
    getDayClassData: (s) => n.hideOffsetDates && !s.current ? {} : {
      ...C(s),
      ...u(s),
      [n.dayClass ? n.dayClass(s.value) : ""]: !0,
      [n.calendarCellClassName]: !!n.calendarCellClassName
    }
  };
}, Et = (e) => {
  const { defaultedFilters: n } = Re(e), a = (f) => {
    const w = Le(t(P(f))).toISOString(), [C] = w.split("T");
    return C;
  }, t = (f) => Ze(f, e.timezone), o = (f) => {
    var s;
    const w = e.maxDate ? Ne(t(f), t(P(e.maxDate))) : !1, C = e.minDate ? Pe(t(f), t(P(e.minDate))) : !1, K = p(
      f,
      (s = e.arrMapValues) != null && s.disabledDates ? e.arrMapValues.disabledDates : e.disabledDates
    ), V = n.value.months.map((_) => +_).includes(ge(f)), b = e.disabledWeekDays.length ? e.disabledWeekDays.some((_) => +_ === ja(f)) : !1, m = h(f), u = me(f), y = u < +e.yearRange[0] || u > +e.yearRange[1];
    return !(w || C || K || V || y || b || m);
  }, l = (f, w) => Pe(...tt(e.minDate, f, w)) || ye(...tt(e.minDate, f, w)), d = (f, w) => Ne(...tt(e.maxDate, f, w)) || ye(...tt(e.maxDate, f, w)), M = (f, w, C) => {
    let K = !1;
    return e.maxDate && C && d(f, w) && (K = !0), e.minDate && !C && l(f, w) && (K = !0), K;
  }, p = (f, w) => f ? w instanceof Map ? !!w.get(a(f)) : Array.isArray(w) ? w.some((C) => ye(t(P(C)), t(f))) : w ? w(P(JSON.parse(JSON.stringify(f)))) : !1 : !0, $ = (f, w, C, K) => {
    let c = !1;
    return K ? e.minDate && e.maxDate ? c = M(f, w, C) : (e.minDate && l(f, w) || e.maxDate && d(f, w)) && (c = !0) : c = !0, c;
  }, h = (f) => {
    var w, C, K, c, V;
    return Array.isArray(e.allowedDates) && !((w = e.allowedDates) != null && w.length) ? !0 : (C = e.arrMapValues) != null && C.allowedDates ? !p(f, (K = e.arrMapValues) == null ? void 0 : K.allowedDates) : (c = e.allowedDates) != null && c.length ? !((V = e.allowedDates) != null && V.some((b) => ye(t(P(b)), t(f)))) : !1;
  }, S = (f) => !o(f), R = (f) => !va({ start: f[0], end: f[1] }).some((C) => S(C)), J = (f, w, C = 0) => {
    if (Array.isArray(w) && w[C]) {
      const K = Ka(f, w[C]), c = Aa(w[C], f), V = c.length === 1 ? 0 : c.filter((m) => S(m)).length, b = Math.abs(K) - V;
      if (e.minRange && e.maxRange)
        return b >= +e.minRange && b <= +e.maxRange;
      if (e.minRange)
        return b >= +e.minRange;
      if (e.maxRange)
        return b <= +e.maxRange;
    }
    return !0;
  }, W = (f) => new Map(f.map((w) => [a(w), !0])), Q = (f) => Array.isArray(f) && f.length > 0, Z = () => {
    const f = {
      disabledDates: null,
      allowedDates: null,
      highlightedDates: null
    };
    return Q(e.allowedDates) && (f.allowedDates = W(e.allowedDates)), Q(e.highlight) && (f.highlightedDates = W(e.highlight)), Q(e.disabledDates) && (f.disabledDates = W(e.disabledDates)), f;
  }, k = () => !e.enableTimePicker || e.monthPicker || e.yearPicker || e.ignoreTimeValidation, T = (f) => Array.isArray(f) ? [f[0] ? mn(f[0]) : null, f[1] ? mn(f[1]) : null] : mn(f), I = (f, w, C) => f.find(
    (K) => +K.hours === Je(w) && K.minutes === "*" ? !0 : +K.minutes === Xe(w)
  ) && C, H = (f, w, C) => {
    const [K, c] = f, [V, b] = w;
    return !I(K, V, C) && !I(c, b, C) && C;
  }, A = (f, w) => {
    const C = Array.isArray(w) ? w : [w];
    return Array.isArray(e.disabledTimes) ? Array.isArray(e.disabledTimes[0]) ? H(e.disabledTimes, C, f) : !C.some((K) => I(e.disabledTimes, K, f)) : f;
  }, q = (f, w) => {
    const C = Array.isArray(w) ? [vt(w[0]), w[1] ? vt(w[1]) : void 0] : vt(w), K = !e.disabledTimes(C);
    return f && K;
  }, j = (f, w) => e.disabledTimes ? Array.isArray(e.disabledTimes) ? A(w, f) : q(w, f) : w;
  return {
    isDisabled: S,
    validateDate: o,
    validateMonthYearInRange: $,
    isDateRangeAllowed: R,
    checkMinMaxRange: J,
    matchDate: p,
    mapDatesArrToMap: Z,
    isValidTime: (f) => {
      let w = !0;
      if (!f || k())
        return !0;
      const C = !e.minDate && !e.maxDate ? T(f) : f;
      return (e.maxTime || e.maxDate) && (w = la(e.maxTime, e.maxDate, "max", Te(C), w)), (e.minTime || e.minDate) && (w = la(e.minTime, e.minDate, "min", Te(C), w)), j(f, w);
    }
  };
}, Jt = () => {
  const e = L(() => (t, o) => t == null ? void 0 : t.includes(o)), n = L(() => (t, o) => t.count ? t.solo ? !0 : o === 0 : !0), a = L(() => (t, o) => t.count ? t.solo ? !0 : o === t.count - 1 : !0);
  return { hideNavigationButtons: e, showLeftIcon: n, showRightIcon: a };
}, Jr = (e, n, a) => {
  const t = z(0), o = Ot({
    // monthYearInput: !!props.timePicker,
    [mt.timePicker]: !e.enableTimePicker || e.timePicker || e.monthPicker,
    [mt.calendar]: !1,
    [mt.header]: !1
  }), l = (h) => {
    var S;
    (S = e.flow) != null && S.length && (o[h] = !0, Object.keys(o).filter((R) => !o[R]).length || $());
  }, d = () => {
    var h;
    (h = e.flow) != null && h.length && t.value !== -1 && (t.value += 1, n("flow-step", t.value), $());
  }, M = () => {
    t.value = -1;
  }, p = (h, S, ...R) => {
    e.flow[t.value] === h && a.value && a.value[S](...R);
  }, $ = () => {
    p(Ke.month, "toggleMonthPicker", !0), p(Ke.year, "toggleYearPicker", !0), p(Ke.calendar, "toggleTimePicker", !1, !0), p(Ke.time, "toggleTimePicker", !0, !0);
    const h = e.flow[t.value];
    (h === Ke.hours || h === Ke.minutes || h === Ke.seconds) && p(h, "toggleTimePicker", !0, !0, h);
  };
  return { childMount: l, updateFlowStep: d, resetFlow: M, flowStep: t };
}, Xt = {
  multiCalendars: { type: [Boolean, Number, String, Object], default: void 0 },
  modelValue: { type: [String, Date, Array, Object, Number], default: null },
  modelType: { type: String, default: null },
  position: { type: String, default: "center" },
  dark: { type: Boolean, default: !1 },
  format: {
    type: [String, Function],
    default: () => null
  },
  closeOnScroll: { type: Boolean, default: !1 },
  autoPosition: { type: Boolean, default: !0 },
  closeOnAutoApply: { type: Boolean, default: !0 },
  altPosition: { type: Function, default: null },
  transitions: { type: [Boolean, Object], default: !0 },
  formatLocale: { type: Object, default: null },
  utc: { type: [Boolean, String], default: !1 },
  ariaLabels: { type: Object, default: () => ({}) },
  offset: { type: [Number, String], default: 10 },
  hideNavigation: { type: Array, default: () => [] },
  timezone: { type: String, default: null },
  emitTimezone: { type: String, default: null },
  vertical: { type: Boolean, default: !1 },
  disableMonthYearSelect: { type: Boolean, default: !1 },
  disableYearSelect: { type: Boolean, default: !1 },
  menuClassName: { type: String, default: null },
  dayClass: { type: Function, default: null },
  yearRange: { type: Array, default: () => [1900, 2100] },
  calendarCellClassName: { type: String, default: null },
  enableTimePicker: { type: Boolean, default: !0 },
  autoApply: { type: Boolean, default: !1 },
  disabledDates: { type: [Array, Function], default: () => [] },
  monthNameFormat: { type: String, default: "short" },
  startDate: { type: [Date, String], default: null },
  startTime: { type: [Object, Array], default: null },
  hideOffsetDates: { type: Boolean, default: !1 },
  autoRange: { type: [Number, String], default: null },
  noToday: { type: Boolean, default: !1 },
  disabledWeekDays: { type: Array, default: () => [] },
  allowedDates: { type: Array, default: null },
  nowButtonLabel: { type: String, default: "Now" },
  markers: { type: Array, default: () => [] },
  modeHeight: { type: [Number, String], default: 255 },
  escClose: { type: Boolean, default: !0 },
  spaceConfirm: { type: Boolean, default: !0 },
  monthChangeOnArrows: { type: Boolean, default: !0 },
  presetDates: { type: Array, default: () => [] },
  flow: { type: Array, default: () => [] },
  partialFlow: { type: Boolean, default: !1 },
  preventMinMaxNavigation: { type: Boolean, default: !1 },
  minRange: { type: [Number, String], default: null },
  maxRange: { type: [Number, String], default: null },
  multiDatesLimit: { type: [Number, String], default: null },
  reverseYears: { type: Boolean, default: !1 },
  keepActionRow: { type: Boolean, default: !1 },
  weekPicker: { type: Boolean, default: !1 },
  filters: { type: Object, default: () => ({}) },
  arrowNavigation: { type: Boolean, default: !1 },
  disableTimeRangeValidation: { type: Boolean, default: !1 },
  highlight: {
    type: [Array, Function],
    default: null
  },
  highlightWeekDays: {
    type: Array,
    default: null
  },
  highlightDisabledDays: { type: Boolean, default: !1 },
  teleport: { type: [String, Boolean], default: null },
  teleportCenter: { type: Boolean, default: !1 },
  locale: { type: String, default: "en-Us" },
  weekNumName: { type: String, default: "W" },
  weekStart: { type: [Number, String], default: 1 },
  weekNumbers: {
    type: [String, Function],
    default: null
  },
  calendarClassName: { type: String, default: null },
  noSwipe: { type: Boolean, default: !1 },
  monthChangeOnScroll: { type: [Boolean, String], default: !0 },
  dayNames: {
    type: [Function, Array],
    default: null
  },
  monthPicker: { type: Boolean, default: !1 },
  customProps: { type: Object, default: null },
  yearPicker: { type: Boolean, default: !1 },
  modelAuto: { type: Boolean, default: !1 },
  selectText: { type: String, default: "Select" },
  cancelText: { type: String, default: "Cancel" },
  previewFormat: {
    type: [String, Function],
    default: () => ""
  },
  multiDates: { type: Boolean, default: !1 },
  partialRange: { type: Boolean, default: !0 },
  ignoreTimeValidation: { type: Boolean, default: !1 },
  minDate: { type: [Date, String], default: null },
  maxDate: { type: [Date, String], default: null },
  minTime: { type: Object, default: null },
  maxTime: { type: Object, default: null },
  name: { type: String, default: null },
  placeholder: { type: String, default: "" },
  hideInputIcon: { type: Boolean, default: !1 },
  clearable: { type: Boolean, default: !0 },
  state: { type: Boolean, default: null },
  required: { type: Boolean, default: !1 },
  autocomplete: { type: String, default: "off" },
  inputClassName: { type: String, default: null },
  fixedStart: { type: Boolean, default: !1 },
  fixedEnd: { type: Boolean, default: !1 },
  timePicker: { type: Boolean, default: !1 },
  enableSeconds: { type: Boolean, default: !1 },
  is24: { type: Boolean, default: !0 },
  noHoursOverlay: { type: Boolean, default: !1 },
  noMinutesOverlay: { type: Boolean, default: !1 },
  noSecondsOverlay: { type: Boolean, default: !1 },
  hoursGridIncrement: { type: [String, Number], default: 1 },
  minutesGridIncrement: { type: [String, Number], default: 5 },
  secondsGridIncrement: { type: [String, Number], default: 5 },
  hoursIncrement: { type: [Number, String], default: 1 },
  minutesIncrement: { type: [Number, String], default: 1 },
  secondsIncrement: { type: [Number, String], default: 1 },
  range: { type: Boolean, default: !1 },
  uid: { type: String, default: null },
  disabled: { type: Boolean, default: !1 },
  readonly: { type: Boolean, default: !1 },
  inline: { type: [Boolean, Object], default: !1 },
  textInput: { type: [Boolean, Object], default: !1 },
  onClickOutside: { type: Function, default: null },
  noDisabledRange: { type: Boolean, default: !1 },
  sixWeeks: { type: [Boolean, String], default: !1 },
  actionRow: { type: Object, default: () => ({}) },
  allowPreventDefault: { type: Boolean, default: !1 },
  closeOnClearValue: { type: Boolean, default: !0 },
  focusStartDate: { type: Boolean, default: !1 },
  disabledTimes: { type: [Function, Array], default: void 0 },
  showLastInRange: { type: Boolean, default: !0 },
  timePickerInline: { type: Boolean, default: !1 },
  calendar: { type: Function, default: null }
}, Qe = {
  ...Xt,
  shadow: { type: Boolean, default: !1 },
  flowStep: { type: Number, default: 0 },
  internalModelValue: { type: [Date, Array], default: null },
  arrMapValues: { type: Object, default: () => ({}) }
}, Xr = {
  key: 1,
  class: "dp__input_wrap"
}, xr = ["id", "name", "inputmode", "placeholder", "disabled", "readonly", "required", "value", "autocomplete", "aria-label", "aria-disabled", "aria-invalid", "onKeydown"], Qr = {
  key: 2,
  class: "dp__clear_icon"
}, el = /* @__PURE__ */ Ee({
  compatConfig: {
    MODE: 3
  },
  __name: "DatepickerInput",
  props: {
    isMenuOpen: { type: Boolean, default: !1 },
    inputValue: { type: String, default: "" },
    ...Xt
  },
  emits: [
    "clear",
    "open",
    "update:input-value",
    "set-input-date",
    "close",
    "select-date",
    "set-empty-date",
    "toggle",
    "focus-prev",
    "focus",
    "blur",
    "real-blur"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, { defaultedTextInput: o, defaultedAriaLabels: l, defaultedInline: d, getDefaultPattern: M, getDefaultStartTime: p } = Re(t), $ = z(), h = z(null), S = z(!1), R = z(!1), J = L(
      () => ({
        dp__pointer: !t.disabled && !t.readonly && !o.value.enabled,
        dp__disabled: t.disabled,
        dp__input_readonly: !o.value.enabled,
        dp__input: !0,
        dp__input_icon_pad: !t.hideInputIcon,
        dp__input_valid: !!t.state,
        dp__input_invalid: t.state === !1,
        dp__input_focus: S.value || t.isMenuOpen,
        dp__input_reg: !o.value.enabled,
        [t.inputClassName]: !!t.inputClassName
      })
    ), W = () => {
      a("set-input-date", null), t.autoApply && (a("set-empty-date"), $.value = null);
    }, Q = (c) => {
      const V = p();
      return _r(
        c,
        o.value.format ?? M(),
        V ?? Sa({}, t.enableSeconds),
        t.inputValue,
        R.value
      );
    }, Z = (c) => {
      const { rangeSeparator: V } = o.value, [b, m] = c.split(`${V}`);
      if (b) {
        const u = Q(b.trim()), y = m ? Q(m.trim()) : null, s = u && y ? [u, y] : [u];
        $.value = u ? s : null;
      }
    }, k = () => {
      R.value = !0;
    }, T = (c) => {
      if (t.range)
        Z(c);
      else if (t.multiDates) {
        const V = c.split(";");
        $.value = V.map((b) => Q(b.trim())).filter((b) => b);
      } else
        $.value = Q(c);
    }, I = (c) => {
      var b;
      const V = typeof c == "string" ? c : (b = c.target) == null ? void 0 : b.value;
      V !== "" ? (o.value.openMenu && !t.isMenuOpen && a("open"), T(V), a("set-input-date", $.value)) : W(), R.value = !1, a("update:input-value", V);
    }, H = (c) => {
      o.value.enabled ? (T(c.target.value), o.value.enterSubmit && Sn($.value) && t.inputValue !== "" ? (a("set-input-date", $.value, !0), $.value = null) : o.value.enterSubmit && t.inputValue === "" && ($.value = null, a("clear"))) : j(c);
    }, A = (c) => {
      o.value.enabled && o.value.tabSubmit && T(c.target.value), o.value.tabSubmit && Sn($.value) && t.inputValue !== "" ? (a("set-input-date", $.value, !0), $.value = null) : o.value.tabSubmit && t.inputValue === "" && ($.value = null, a("clear"));
    }, q = () => {
      S.value = !0, a("focus");
    }, j = (c) => {
      c.preventDefault(), c.stopImmediatePropagation(), c.stopPropagation(), o.value.enabled && o.value.openMenu && !d.value.input && !t.isMenuOpen ? a("open") : o.value.enabled || a("toggle");
    }, le = () => {
      a("real-blur"), S.value = !1, (!t.isMenuOpen || d.value.enabled && d.value.input) && a("blur"), t.autoApply && o.value.enabled && $.value && !t.isMenuOpen && (a("set-input-date", $.value), a("select-date"), $.value = null);
    }, f = () => {
      a("clear");
    }, w = (c) => {
      if (!o.value.enabled) {
        if (c.code === "Tab")
          return;
        c.preventDefault();
      }
    };
    return n({
      focusInput: () => {
        var c;
        (c = h.value) == null || c.focus({ preventScroll: !0 });
      },
      setParsedDate: (c) => {
        $.value = c;
      }
    }), (c, V) => {
      var b;
      return D(), Y("div", { onClick: j }, [
        c.$slots.trigger && !c.$slots["dp-input"] && !v(d).enabled ? te(c.$slots, "trigger", { key: 0 }) : B("", !0),
        !c.$slots.trigger && (!v(d).enabled || v(d).input) ? (D(), Y("div", Xr, [
          c.$slots["dp-input"] && !c.$slots.trigger && !v(d).enabled ? te(c.$slots, "dp-input", {
            key: 0,
            value: e.inputValue,
            isMenuOpen: e.isMenuOpen,
            onInput: I,
            onEnter: H,
            onTab: A,
            onClear: f,
            onBlur: le,
            onKeypress: w,
            onPaste: k
          }) : B("", !0),
          c.$slots["dp-input"] ? B("", !0) : (D(), Y("input", {
            key: 1,
            ref_key: "inputRef",
            ref: h,
            id: c.uid ? `dp-input-${c.uid}` : void 0,
            name: c.name,
            class: he(J.value),
            inputmode: v(o).enabled ? "text" : "none",
            placeholder: c.placeholder,
            disabled: c.disabled,
            readonly: c.readonly,
            required: c.required,
            value: e.inputValue,
            autocomplete: c.autocomplete,
            "aria-label": (b = v(l)) == null ? void 0 : b.input,
            "aria-disabled": c.disabled || void 0,
            "aria-invalid": c.state === !1 ? !0 : void 0,
            onInput: I,
            onKeydown: [
              oe(H, ["enter"]),
              oe(A, ["tab"]),
              w
            ],
            onBlur: le,
            onFocus: q,
            onKeypress: w,
            onPaste: k
          }, null, 42, xr)),
          ue("div", {
            onClick: V[2] || (V[2] = (m) => a("toggle"))
          }, [
            c.$slots["input-icon"] && !c.hideInputIcon ? (D(), Y("span", {
              key: 0,
              class: "dp__input_icon",
              onClick: V[0] || (V[0] = (m) => a("toggle"))
            }, [
              te(c.$slots, "input-icon")
            ])) : B("", !0),
            !c.$slots["input-icon"] && !c.hideInputIcon && !c.$slots["dp-input"] ? (D(), ve(v(Yt), {
              key: 1,
              onClick: V[1] || (V[1] = (m) => a("toggle")),
              class: "dp__input_icon dp__input_icons"
            })) : B("", !0)
          ]),
          c.$slots["clear-icon"] && e.inputValue && c.clearable && !c.disabled && !c.readonly ? (D(), Y("span", Qr, [
            te(c.$slots, "clear-icon", { clear: f })
          ])) : B("", !0),
          c.clearable && !c.$slots["clear-icon"] && e.inputValue && !c.disabled && !c.readonly ? (D(), ve(v(pa), {
            key: 3,
            class: "dp__clear_icon dp__input_icons",
            onClick: pe(f, ["stop", "prevent"])
          }, null, 8, ["onClick"])) : B("", !0)
        ])) : B("", !0)
      ]);
    };
  }
}), tl = ["title"], nl = { class: "dp__action_buttons" }, al = ["onKeydown", "disabled"], rl = /* @__PURE__ */ Ee({
  compatConfig: {
    MODE: 3
  },
  __name: "ActionRow",
  props: {
    menuMount: { type: Boolean, default: !1 },
    calendarWidth: { type: Number, default: 0 },
    ...Qe
  },
  emits: ["close-picker", "select-date", "select-now", "invalid-select"],
  setup(e, { emit: n }) {
    const a = e, {
      defaultedActionRow: t,
      defaultedPreviewFormat: o,
      defaultedMultiCalendars: l,
      defaultedTextInput: d,
      defaultedInline: M,
      getDefaultPattern: p
    } = Re(a), { isValidTime: $ } = Et(a), { buildMatrix: h } = lt(), S = z(null), R = z(null);
    Ue(() => {
      a.arrowNavigation && h([Ae(S), Ae(R)], "actionRow");
    });
    const J = L(() => a.range && !a.partialRange && a.internalModelValue ? a.internalModelValue.length === 2 : !0), W = L(() => !Q.value || !Z.value || !J.value), Q = L(() => !a.enableTimePicker || a.ignoreTimeValidation ? !0 : $(a.internalModelValue)), Z = L(() => a.monthPicker ? a.range && Array.isArray(a.internalModelValue) ? !a.internalModelValue.filter((w) => !j(w)).length : j(a.internalModelValue) : !0), k = () => {
      const f = o.value;
      return a.timePicker || a.monthPicker, f(Te(a.internalModelValue));
    }, T = () => {
      const f = a.internalModelValue;
      return l.value.count > 0 ? `${I(f[0])} - ${I(f[1])}` : [I(f[0]), I(f[1])];
    }, I = (f) => Pa(
      f,
      o.value,
      a.formatLocale,
      d.value.rangeSeparator,
      a.modelAuto,
      p()
    ), H = L(() => !a.internalModelValue || !a.menuMount ? "" : typeof o.value == "string" ? Array.isArray(a.internalModelValue) ? a.internalModelValue.length === 2 && a.internalModelValue[1] ? T() : a.multiDates ? a.internalModelValue.map((f) => `${I(f)}`) : a.modelAuto ? `${I(a.internalModelValue[0])}` : `${I(a.internalModelValue[0])} -` : I(a.internalModelValue) : k()), A = () => a.multiDates ? "; " : " - ", q = L(
      () => Array.isArray(H.value) ? H.value.join(A()) : H.value
    ), j = (f) => {
      if (!a.monthPicker)
        return !0;
      let w = !0;
      const C = P(ze(f));
      if (a.minDate && a.maxDate) {
        const K = P(ze(a.minDate)), c = P(ze(a.maxDate));
        return Ne(C, K) && Pe(C, c) || ye(C, K) || ye(C, c);
      }
      if (a.minDate) {
        const K = P(ze(a.minDate));
        w = Ne(C, K) || ye(C, K);
      }
      if (a.maxDate) {
        const K = P(ze(a.maxDate));
        w = Pe(C, K) || ye(C, K);
      }
      return w;
    }, le = () => {
      Q.value && Z.value && J.value ? n("select-date") : n("invalid-select");
    };
    return (f, w) => (D(), Y("div", {
      class: "dp__action_row",
      style: Ge(e.calendarWidth ? { width: `${e.calendarWidth}px` } : {})
    }, [
      f.$slots["action-row"] ? te(f.$slots, "action-row", Ce(Be({ key: 0 }, {
        internalModelValue: f.internalModelValue,
        disabled: W.value,
        selectDate: () => f.$emit("select-date"),
        closePicker: () => f.$emit("close-picker")
      }))) : (D(), Y(fe, { key: 1 }, [
        v(t).showPreview ? (D(), Y("div", {
          key: 0,
          class: "dp__selection_preview",
          title: q.value
        }, [
          f.$slots["action-preview"] ? te(f.$slots, "action-preview", {
            key: 0,
            value: f.internalModelValue
          }) : B("", !0),
          f.$slots["action-preview"] ? B("", !0) : (D(), Y(fe, { key: 1 }, [
            at(Ie(q.value), 1)
          ], 64))
        ], 8, tl)) : B("", !0),
        ue("div", nl, [
          f.$slots["action-buttons"] ? te(f.$slots, "action-buttons", {
            key: 0,
            value: f.internalModelValue
          }) : B("", !0),
          f.$slots["action-buttons"] ? B("", !0) : (D(), Y(fe, { key: 1 }, [
            !v(M).enabled && v(t).showCancel ? (D(), Y("button", {
              key: 0,
              type: "button",
              ref_key: "cancelButtonRef",
              ref: S,
              class: "dp__action_button dp__action_cancel",
              onClick: w[0] || (w[0] = (C) => f.$emit("close-picker")),
              onKeydown: [
                w[1] || (w[1] = oe((C) => f.$emit("close-picker"), ["enter"])),
                w[2] || (w[2] = oe((C) => f.$emit("close-picker"), ["space"]))
              ]
            }, Ie(f.cancelText), 545)) : B("", !0),
            v(t).showNow ? (D(), Y("button", {
              key: 1,
              type: "button",
              ref_key: "cancelButtonRef",
              ref: S,
              class: "dp__action_button dp__action_cancel",
              onClick: w[3] || (w[3] = (C) => f.$emit("select-now")),
              onKeydown: [
                w[4] || (w[4] = oe((C) => f.$emit("select-now"), ["enter"])),
                w[5] || (w[5] = oe((C) => f.$emit("select-now"), ["space"]))
              ]
            }, Ie(f.nowButtonLabel), 545)) : B("", !0),
            v(t).showSelect ? (D(), Y("button", {
              key: 2,
              type: "button",
              class: "dp__action_button dp__action_select",
              onKeydown: [
                oe(le, ["enter"]),
                oe(le, ["space"])
              ],
              onClick: le,
              disabled: W.value,
              ref_key: "selectButtonRef",
              ref: R
            }, Ie(f.selectText), 41, al)) : B("", !0)
          ], 64))
        ])
      ], 64))
    ], 4));
  }
}), ll = ["onKeydown"], ol = { class: "dp__selection_grid_header" }, sl = ["aria-selected", "aria-disabled", "onClick", "onKeydown", "onMouseover"], ul = ["aria-label", "onKeydown"], Nt = /* @__PURE__ */ Ee({
  __name: "SelectionOverlay",
  props: {
    items: {},
    type: {},
    isLast: { type: Boolean },
    arrowNavigation: { type: Boolean },
    skipButtonRef: { type: Boolean },
    headerRefs: {},
    hideNavigation: {},
    escClose: { type: Boolean },
    useRelative: { type: Boolean },
    height: {},
    textInput: { type: [Boolean, Object] }
  },
  emits: ["selected", "toggle", "reset-flow", "hover-value"],
  setup(e, { expose: n, emit: a }) {
    const t = e, { setSelectionGrid: o, buildMultiLevelMatrix: l, setMonthPicker: d } = lt(), { defaultedAriaLabels: M, defaultedTextInput: p } = Re(t), { hideNavigationButtons: $ } = Jt(), h = z(!1), S = z(null), R = z(null), J = z([]), W = z(), Q = z(null), Z = z(0), k = z(null);
    Ea(() => {
      S.value = null;
    }), Ue(() => {
      rt().then(() => f()), I(), T(!0);
    }), _n(() => T(!1));
    const T = (u) => {
      var y;
      t.arrowNavigation && ((y = t.headerRefs) != null && y.length ? d(u) : o(u));
    }, I = () => {
      var y;
      const u = Ae(R);
      u && (p.value.enabled || (S.value ? (y = S.value) == null || y.focus({ preventScroll: !0 }) : u.focus({ preventScroll: !0 })), h.value = u.clientHeight < u.scrollHeight);
    }, H = L(
      () => ({
        dp__overlay: !0,
        "dp--overlay-absolute": !t.useRelative,
        "dp--overlay-relative": t.useRelative
      })
    ), A = L(
      () => t.useRelative ? { height: `${t.height}px`, width: "260px" } : void 0
    ), q = L(() => ({
      dp__overlay_col: !0
    })), j = L(
      () => ({
        dp__btn: !0,
        dp__button: !0,
        dp__overlay_action: !0,
        dp__over_action_scroll: h.value,
        dp__button_bottom: t.isLast
      })
    ), le = L(() => {
      var u, y;
      return {
        dp__overlay_container: !0,
        dp__container_flex: ((u = t.items) == null ? void 0 : u.length) <= 6,
        dp__container_block: ((y = t.items) == null ? void 0 : y.length) > 6
      };
    }), f = () => {
      rt().then(() => {
        const u = Ae(S), y = Ae(R), s = Ae(Q), _ = Ae(k), ee = s ? s.getBoundingClientRect().height : 0;
        y && (Z.value = y.getBoundingClientRect().height - ee), u && _ && (_.scrollTop = u.offsetTop - _.offsetTop - (Z.value / 2 - u.getBoundingClientRect().height) - ee);
      });
    }, w = (u) => {
      u.disabled || a("selected", u.value);
    }, C = () => {
      a("toggle"), a("reset-flow");
    }, K = () => {
      t.escClose && C();
    }, c = (u, y, s, _) => {
      u && (y.active && (S.value = u), t.arrowNavigation && (Array.isArray(J.value[s]) ? J.value[s][_] = u : J.value[s] = [u], V()));
    }, V = () => {
      var y, s;
      const u = (y = t.headerRefs) != null && y.length ? [t.headerRefs].concat(J.value) : J.value.concat([t.skipButtonRef ? [] : [Q.value]]);
      l(Te(u), (s = t.headerRefs) != null && s.length ? "monthPicker" : "selectionGrid");
    }, b = (u) => {
      t.arrowNavigation || u.stopImmediatePropagation();
    }, m = (u) => {
      W.value = u, a("hover-value", u);
    };
    return n({ focusGrid: I }), (u, y) => {
      var s;
      return D(), Y("div", {
        ref_key: "gridWrapRef",
        ref: R,
        class: he(H.value),
        style: Ge(A.value),
        role: "dialog",
        tabindex: "0",
        onKeydown: [
          oe(pe(K, ["prevent"]), ["esc"]),
          y[0] || (y[0] = oe(pe((_) => b(_), ["prevent"]), ["left"])),
          y[1] || (y[1] = oe(pe((_) => b(_), ["prevent"]), ["up"])),
          y[2] || (y[2] = oe(pe((_) => b(_), ["prevent"]), ["down"])),
          y[3] || (y[3] = oe(pe((_) => b(_), ["prevent"]), ["right"]))
        ]
      }, [
        ue("div", {
          class: he(le.value),
          ref_key: "containerRef",
          ref: k,
          role: "grid",
          style: Ge({ height: `${Z.value}px` })
        }, [
          ue("div", ol, [
            te(u.$slots, "header")
          ]),
          u.$slots.overlay ? te(u.$slots, "overlay", { key: 0 }) : (D(!0), Y(fe, { key: 1 }, Me(u.items, (_, ee) => (D(), Y("div", {
            class: he(["dp__overlay_row", { dp__flex_row: u.items.length >= 3 }]),
            key: ee,
            role: "row"
          }, [
            (D(!0), Y(fe, null, Me(_, (r, U) => (D(), Y("div", {
              role: "gridcell",
              class: he(q.value),
              key: r.value,
              "aria-selected": r.active,
              "aria-disabled": r.disabled || void 0,
              ref_for: !0,
              ref: (N) => c(N, r, ee, U),
              tabindex: "0",
              onClick: (N) => w(r),
              onKeydown: [
                oe(pe((N) => w(r), ["prevent"]), ["enter"]),
                oe(pe((N) => w(r), ["prevent"]), ["space"])
              ],
              onMouseover: (N) => m(r.value)
            }, [
              ue("div", {
                class: he(r.className)
              }, [
                u.$slots.item ? te(u.$slots, "item", {
                  key: 0,
                  item: r
                }) : B("", !0),
                u.$slots.item ? B("", !0) : (D(), Y(fe, { key: 1 }, [
                  at(Ie(r.text), 1)
                ], 64))
              ], 2)
            ], 42, sl))), 128))
          ], 2))), 128))
        ], 6),
        u.$slots["button-icon"] ? Wt((D(), Y("button", {
          key: 0,
          type: "button",
          "aria-label": (s = v(M)) == null ? void 0 : s.toggleOverlay,
          class: he(j.value),
          tabindex: "0",
          ref_key: "toggleButton",
          ref: Q,
          onClick: C,
          onKeydown: [
            oe(C, ["enter"]),
            oe(C, ["tab"])
          ]
        }, [
          te(u.$slots, "button-icon")
        ], 42, ul)), [
          [zt, !v($)(u.hideNavigation, u.type)]
        ]) : B("", !0)
      ], 46, ll);
    };
  }
}), Ln = /* @__PURE__ */ Ee({
  __name: "InstanceWrap",
  props: {
    multiCalendars: {},
    stretch: { type: Boolean }
  },
  setup(e) {
    const n = e, a = L(
      () => n.multiCalendars > 0 ? [...Array(n.multiCalendars).keys()] : [0]
    ), t = L(() => ({
      dp__instance_calendar: n.multiCalendars > 0
    }));
    return (o, l) => (D(), Y("div", {
      class: he({
        dp__menu_inner: !o.stretch,
        "dp--menu--inner-stretched": o.stretch,
        dp__flex_display: o.multiCalendars > 0
      })
    }, [
      (D(!0), Y(fe, null, Me(a.value, (d, M) => (D(), Y("div", {
        key: d,
        class: he(t.value)
      }, [
        te(o.$slots, "default", {
          instance: d,
          index: M
        })
      ], 2))), 128))
    ], 2));
  }
}), il = ["aria-label", "aria-disabled"], St = /* @__PURE__ */ Ee({
  compatConfig: {
    MODE: 3
  },
  __name: "ArrowBtn",
  props: {
    ariaLabel: {},
    disabled: { type: Boolean }
  },
  emits: ["activate", "set-ref"],
  setup(e, { emit: n }) {
    const a = z(null);
    return Ue(() => n("set-ref", a)), (t, o) => (D(), Y("button", {
      type: "button",
      class: "dp__btn dp--arrow-btn-nav",
      onClick: o[0] || (o[0] = (l) => t.$emit("activate")),
      onKeydown: [
        o[1] || (o[1] = oe(pe((l) => t.$emit("activate"), ["prevent"]), ["enter"])),
        o[2] || (o[2] = oe(pe((l) => t.$emit("activate"), ["prevent"]), ["space"]))
      ],
      tabindex: "0",
      "aria-label": t.ariaLabel,
      "aria-disabled": t.disabled || void 0,
      ref_key: "elRef",
      ref: a
    }, [
      ue("span", {
        class: he(["dp__inner_nav", { dp__inner_nav_disabled: t.disabled }])
      }, [
        te(t.$slots, "default")
      ], 2)
    ], 40, il));
  }
}), Un = (e, n, a) => {
  if (n.value && Array.isArray(n.value))
    if (n.value.some((t) => ye(e, t))) {
      const t = n.value.filter((o) => !ye(o, e));
      n.value = t.length ? t : null;
    } else
      (a && +a > n.value.length || !a) && n.value.push(e);
  else
    n.value = [e];
}, Ra = (e, n, a) => {
  let t = e.value ? e.value.slice() : [];
  return t.length === 2 && t[1] !== null && (t = []), t.length ? Pe(n, t[0]) ? (t.unshift(n), a("range-start", t[0]), a("range-start", t[1])) : (t[1] = n, a("range-end", n)) : (t = [n], a("range-start", n)), e.value = t, t;
}, Wn = (e, n, a, t) => {
  e[0] && e[1] && a && n("auto-apply"), e[0] && !e[1] && t && a && n("auto-apply");
}, dl = (e, n) => {
  const { defaultedMultiCalendars: a, defaultedAriaLabels: t, defaultedTransitions: o } = Re(e), { modelValue: l, year: d, month: M, calendars: p } = qt(e, n), $ = L(() => Da(e.formatLocale, e.locale, e.monthNameFormat)), h = L(() => Vn(e.yearRange, e.reverseYears)), S = z(null), R = () => {
    for (let b = 0; b < a.value.count; b++)
      if (b === 0)
        p.value[b] = p.value[0];
      else {
        const m = ke(P(), p.value[b - 1]);
        p.value[b] = { month: ge(m), year: me(ga(m, b)) };
      }
  }, J = (b) => {
    if (!b)
      return R();
    const m = ke(P(), p.value[b]);
    return p.value[0].year = me(ya(m, a.value.count - 1)), R();
  }, W = (b) => e.focusStartDate ? b[0] : b[1] ? b[1] : b[0], Q = () => {
    if (l.value) {
      const b = Array.isArray(l.value) ? W(l.value) : l.value;
      p.value[0] = { month: ge(b), year: me(b) };
    }
  };
  Ue(() => {
    Q(), a.value.count && R();
  });
  const Z = L(() => (b, m) => {
    const u = ke(ze(/* @__PURE__ */ new Date()), {
      month: M.value(b),
      year: d.value(b)
    });
    return _a(u, e.maxDate, e.minDate, e.preventMinMaxNavigation, m);
  }), k = (b) => b ? { month: ge(b), year: me(b) } : { month: null, year: null }, T = () => l.value ? Array.isArray(l.value) ? l.value.map((b) => k(b)) : k(l.value) : k(), I = (b, m) => {
    const u = p.value[b], y = T();
    return Array.isArray(y) ? y.some((s) => s.year === (u == null ? void 0 : u.year) && s.month === m) : (u == null ? void 0 : u.year) === y.year && m === y.month;
  }, H = (b, m, u) => {
    var s, _;
    const y = T();
    return Array.isArray(y) ? d.value(m) === ((s = y[u]) == null ? void 0 : s.year) && b === ((_ = y[u]) == null ? void 0 : _.month) : !1;
  }, A = (b, m) => {
    if (e.range) {
      const u = T();
      if (Array.isArray(l.value) && Array.isArray(u)) {
        const y = H(b, m, 0) || H(b, m, 1), s = xe(ze(P()), b, d.value(m));
        return Hn(l.value, S.value, s) && !y;
      }
      return !1;
    }
    return !1;
  }, q = L(() => (b) => kt($.value, (m) => {
    const u = I(b, m.value), y = Rt(
      m.value,
      $a(d.value(b), e.minDate),
      Ta(d.value(b), e.maxDate)
    ) || Yr(e.disabledDates, d.value(b)).includes(m.value), s = A(m.value, b);
    return { active: u, disabled: y, isBetween: s };
  })), j = L(() => (b) => kt(h.value, (m) => {
    const u = d.value(b) === m.value, y = Rt(m.value, wt(e.minDate), wt(e.maxDate));
    return { active: u, disabled: y };
  })), le = (b, m) => xe(ze(P()), b, d.value(m)), f = (b, m) => {
    const u = l.value ? l.value : ze(/* @__PURE__ */ new Date());
    l.value = xe(u, b, d.value(m)), n("auto-apply");
  }, w = (b, m) => {
    const u = Ra(l, le(b, m), n);
    Wn(u, n, e.autoApply, e.modelAuto);
  }, C = (b, m) => {
    Un(le(b, m), l, e.multiDatesLimit), n("auto-apply", !0);
  };
  return {
    groupedMonths: q,
    groupedYears: j,
    year: d,
    isDisabled: Z,
    defaultedMultiCalendars: a,
    defaultedAriaLabels: t,
    defaultedTransitions: o,
    setHoverDate: (b, m) => {
      S.value = le(b, m);
    },
    selectMonth: (b, m) => (p.value[m].month = b, e.multiDates ? C(b, m) : e.range ? w(b, m) : f(b, m)),
    selectYear: (b, m) => {
      p.value[m].year = b, a.value.count && !a.value.solo && J(m);
    }
  };
}, cl = { class: "dp__month_picker_header" }, fl = ["aria-label", "onClick", "onKeydown"], vl = /* @__PURE__ */ Ee({
  compatConfig: {
    MODE: 3
  },
  __name: "MonthPicker",
  props: {
    ...Qe
  },
  emits: [
    "update:internal-model-value",
    "overlay-closed",
    "reset-flow",
    "range-start",
    "range-end",
    "auto-apply"
  ],
  setup(e, { emit: n }) {
    const a = e, {
      groupedMonths: t,
      groupedYears: o,
      year: l,
      isDisabled: d,
      defaultedMultiCalendars: M,
      defaultedAriaLabels: p,
      defaultedTransitions: $,
      setHoverDate: h,
      selectMonth: S,
      selectYear: R
    } = dl(a, n), { transitionName: J, showTransition: W } = Bt($), { showRightIcon: Q, showLeftIcon: Z } = Jt(), k = z([!1]), T = (A, q) => {
      R(A, q), H(q);
    }, I = (A, q = !1) => {
      if (!d.value(A, q)) {
        const j = q ? l.value(A) + 1 : l.value(A) - 1;
        R(j, A);
      }
    }, H = (A, q = !1, j) => {
      q || n("reset-flow"), j !== void 0 ? k.value[A] = j : k.value[A] = !k.value[A], k.value || n("overlay-closed");
    };
    return (A, q) => (D(), ve(Ln, {
      "multi-calendars": v(M).count,
      stretch: ""
    }, {
      default: ce(({ instance: j }) => [
        A.$slots["month-year"] ? te(A.$slots, "month-year", Ce(Be({ key: 0 }, {
          year: v(l),
          months: v(t)(j),
          years: v(o)(j),
          selectMonth: v(S),
          selectYear: v(R),
          instance: j
        }))) : (D(), ve(Nt, {
          key: 1,
          items: v(t)(j),
          "arrow-navigation": A.arrowNavigation,
          "is-last": A.autoApply && !A.keepActionRow,
          "esc-close": A.escClose,
          height: A.modeHeight,
          onSelected: (le) => v(S)(le, j),
          onHoverValue: (le) => v(h)(le, j),
          "use-relative": "",
          type: "month"
        }, {
          header: ce(() => {
            var le, f, w;
            return [
              ue("div", cl, [
                v(Z)(v(M), j) ? (D(), ve(St, {
                  key: 0,
                  ref: "mpPrevIconRef",
                  "aria-label": (le = v(p)) == null ? void 0 : le.prevYear,
                  disabled: v(d)(j, !1),
                  onActivate: (C) => I(j, !1)
                }, {
                  default: ce(() => [
                    A.$slots["arrow-left"] ? te(A.$slots, "arrow-left", { key: 0 }) : B("", !0),
                    A.$slots["arrow-left"] ? B("", !0) : (D(), ve(v(Rn), { key: 1 }))
                  ]),
                  _: 2
                }, 1032, ["aria-label", "disabled", "onActivate"])) : B("", !0),
                ue("div", {
                  class: "dp--year-select",
                  role: "button",
                  ref: "mpYearButtonRef",
                  "aria-label": (f = v(p)) == null ? void 0 : f.openYearsOverlay,
                  tabindex: "0",
                  onClick: () => H(j, !1),
                  onKeydown: oe(() => H(j, !1), ["enter"])
                }, [
                  A.$slots.year ? te(A.$slots, "year", {
                    key: 0,
                    year: v(l)(j)
                  }) : B("", !0),
                  A.$slots.year ? B("", !0) : (D(), Y(fe, { key: 1 }, [
                    at(Ie(v(l)(j)), 1)
                  ], 64))
                ], 40, fl),
                v(Q)(v(M), j) ? (D(), ve(St, {
                  key: 1,
                  ref: "mpNextIconRef",
                  "aria-label": (w = v(p)) == null ? void 0 : w.nextYear,
                  disabled: v(d)(j, !1),
                  onActivate: (C) => I(j, !0)
                }, {
                  default: ce(() => [
                    A.$slots["arrow-right"] ? te(A.$slots, "arrow-right", { key: 0 }) : B("", !0),
                    A.$slots["arrow-right"] ? B("", !0) : (D(), ve(v(Nn), { key: 1 }))
                  ]),
                  _: 2
                }, 1032, ["aria-label", "disabled", "onActivate"])) : B("", !0),
                qe(Dt, {
                  name: v(J)(k.value[j]),
                  css: v(W)
                }, {
                  default: ce(() => [
                    k.value[j] ? (D(), ve(Nt, {
                      key: 0,
                      items: v(o)(j),
                      "text-input": A.textInput,
                      "esc-close": A.escClose,
                      onToggle: (C) => H(j),
                      onSelected: (C) => T(C, j),
                      "is-last": A.autoApply && !A.keepActionRow,
                      type: "year"
                    }, Fe({
                      "button-icon": ce(() => [
                        A.$slots["calendar-icon"] ? te(A.$slots, "calendar-icon", { key: 0 }) : B("", !0),
                        A.$slots["calendar-icon"] ? B("", !0) : (D(), ve(v(Yt), { key: 1 }))
                      ]),
                      _: 2
                    }, [
                      A.$slots["year-overlay-value"] ? {
                        name: "item",
                        fn: ce(({ item: C }) => [
                          te(A.$slots, "year-overlay-value", {
                            text: C.text,
                            value: C.value
                          })
                        ]),
                        key: "0"
                      } : void 0
                    ]), 1032, ["items", "text-input", "esc-close", "onToggle", "onSelected", "is-last"])) : B("", !0)
                  ]),
                  _: 2
                }, 1032, ["name", "css"])
              ])
            ];
          }),
          _: 2
        }, 1032, ["items", "arrow-navigation", "is-last", "esc-close", "height", "onSelected", "onHoverValue"]))
      ]),
      _: 3
    }, 8, ["multi-calendars"]));
  }
}), ml = (e, n) => {
  const { modelValue: a } = qt(e, n), t = z(null), o = (h) => Array.isArray(a.value) ? a.value.some((S) => me(S) === h) : a.value ? me(a.value) === h : !1, l = (h) => e.range && Array.isArray(a.value) ? Hn(a.value, t.value, M(h)) : !1, d = L(() => kt(Vn(e.yearRange, e.reverseYears), (h) => {
    const S = o(h.value), R = Rt(h.value, wt(e.minDate), wt(e.maxDate)), J = l(h.value);
    return { active: S, disabled: R, isBetween: J };
  })), M = (h) => ct(ze(/* @__PURE__ */ new Date()), h);
  return {
    groupedYears: d,
    setHoverValue: (h) => {
      t.value = ct(ze(/* @__PURE__ */ new Date()), h);
    },
    selectYear: (h) => {
      if (e.multiDates)
        return Un(M(h), a, e.multiDatesLimit), n("auto-apply", !0);
      if (e.range) {
        const S = Ra(a, M(h), n);
        return Wn(S, n, e.autoApply, e.modelAuto);
      }
      a.value = M(h), n("auto-apply");
    }
  };
}, gl = /* @__PURE__ */ Ee({
  compatConfig: {
    MODE: 3
  },
  __name: "YearPicker",
  props: {
    ...Qe
  },
  emits: ["update:internal-model-value", "reset-flow", "range-start", "range-end", "auto-apply"],
  setup(e, { emit: n }) {
    const a = e, { groupedYears: t, selectYear: o, setHoverValue: l } = ml(a, n);
    return (d, M) => (D(), Y("div", null, [
      d.$slots["month-year"] ? te(d.$slots, "month-year", Ce(Be({ key: 0 }, {
        years: v(t),
        selectYear: v(o)
      }))) : (D(), ve(Nt, {
        key: 1,
        items: v(t),
        "is-last": d.autoApply && !d.keepActionRow,
        height: d.modeHeight,
        type: "year",
        "use-relative": "",
        onSelected: v(o),
        onHoverValue: v(l)
      }, Fe({ _: 2 }, [
        d.$slots["year-overlay-value"] ? {
          name: "item",
          fn: ce(({ item: p }) => [
            te(d.$slots, "year-overlay-value", {
              text: p.text,
              value: p.value
            })
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["items", "is-last", "height", "onSelected", "onHoverValue"]))
    ]));
  }
}), yl = {
  key: 0,
  class: "dp__time_input"
}, hl = ["aria-label", "onKeydown", "onClick"], pl = /* @__PURE__ */ ue("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_l" }, null, -1), bl = /* @__PURE__ */ ue("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_r" }, null, -1), kl = ["aria-label", "disabled", "onKeydown", "onClick"], wl = ["aria-label", "onKeydown", "onClick"], Dl = /* @__PURE__ */ ue("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_l" }, null, -1), Ml = /* @__PURE__ */ ue("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_r" }, null, -1), $l = { key: 0 }, Tl = ["aria-label", "onKeydown"], Al = /* @__PURE__ */ Ee({
  compatConfig: {
    MODE: 3
  },
  __name: "TimeInput",
  props: {
    hours: { type: Number, default: 0 },
    minutes: { type: Number, default: 0 },
    seconds: { type: Number, default: 0 },
    closeTimePickerBtn: { type: Object, default: null },
    order: { type: Number, default: 0 },
    disabledTimesConfig: { type: Function, default: null },
    ...Qe
  },
  emits: [
    "set-hours",
    "set-minutes",
    "update:hours",
    "update:minutes",
    "update:seconds",
    "reset-flow",
    "mounted",
    "overlay-closed",
    "am-pm-change"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, { setTimePickerElements: o, setTimePickerBackRef: l } = lt(), { defaultedAriaLabels: d, defaultedTransitions: M, defaultedFilters: p } = Re(t), { transitionName: $, showTransition: h } = Bt(M), S = Ot({
      hours: !1,
      minutes: !1,
      seconds: !1
    }), R = z("AM"), J = z(null), W = z([]);
    Ue(() => {
      a("mounted");
    });
    const Q = (r) => ke(/* @__PURE__ */ new Date(), {
      hours: r.hours,
      minutes: r.minutes,
      seconds: t.enableSeconds ? r.seconds : 0,
      milliseconds: 0
    }), Z = L(() => (r) => w(r, t[r])), k = L(() => ({ hours: t.hours, minutes: t.minutes, seconds: t.seconds })), T = L(() => (r) => !K(+t[r] + +t[`${r}Increment`], r)), I = L(() => (r) => !K(+t[r] - +t[`${r}Increment`], r)), H = (r, U) => ha(ke(P(), r), U), A = (r, U) => Ga(ke(P(), r), U), q = L(
      () => ({
        dp__time_col: !0,
        dp__time_col_block: !t.timePickerInline,
        dp__time_col_reg_block: !t.enableSeconds && t.is24 && !t.timePickerInline,
        dp__time_col_reg_inline: !t.enableSeconds && t.is24 && t.timePickerInline,
        dp__time_col_reg_with_button: !t.enableSeconds && !t.is24,
        dp__time_col_sec: t.enableSeconds && t.is24,
        dp__time_col_sec_with_button: t.enableSeconds && !t.is24
      })
    ), j = L(() => {
      const r = [{ type: "hours" }, { type: "", separator: !0 }, { type: "minutes" }];
      return t.enableSeconds ? r.concat([{ type: "", separator: !0 }, { type: "seconds" }]) : r;
    }), le = L(() => j.value.filter((r) => !r.separator)), f = L(() => (r) => {
      if (r === "hours") {
        const U = u(+t.hours);
        return { text: U < 10 ? `0${U}` : `${U}`, value: U };
      }
      return { text: t[r] < 10 ? `0${t[r]}` : `${t[r]}`, value: t[r] };
    }), w = (r, U) => {
      var g;
      if (!t.disabledTimesConfig)
        return !1;
      const N = t.disabledTimesConfig(t.order, r === "hours" ? U : void 0);
      return N[r] ? !!((g = N[r]) != null && g.includes(U)) : !0;
    }, C = (r) => {
      const U = t.is24 ? 24 : 12, N = r === "hours" ? U : 60, g = +t[`${r}GridIncrement`], F = r === "hours" && !t.is24 ? g : 0, ae = [];
      for (let G = F; G < N; G += g)
        ae.push({ value: G, text: G < 10 ? `0${G}` : `${G}` });
      return r === "hours" && !t.is24 && ae.push({ value: 0, text: "12" }), kt(ae, (G) => ({ active: !1, disabled: p.value.times[r].includes(G.value) || !K(G.value, r) || w(r, G.value) }));
    }, K = (r, U) => {
      const N = t.minTime ? Q(fn(t.minTime)) : null, g = t.maxTime ? Q(fn(t.maxTime)) : null, F = Q(fn(k.value, U, r));
      return N && g ? (_t(F, g) || pt(F, g)) && (Pt(F, N) || pt(F, N)) : N ? Pt(F, N) || pt(F, N) : g ? _t(F, g) || pt(F, g) : !0;
    }, c = (r) => t[`no${r[0].toUpperCase() + r.slice(1)}Overlay`], V = (r) => {
      c(r) || (S[r] = !S[r], S[r] || a("overlay-closed"));
    }, b = (r) => r === "hours" ? Je : r === "minutes" ? Xe : bt, m = (r, U = !0) => {
      const N = U ? H : A, g = U ? +t[`${r}Increment`] : -+t[`${r}Increment`];
      K(+t[r] + g, r) && a(
        `update:${r}`,
        b(r)(N({ [r]: +t[r] }, { [r]: +t[`${r}Increment`] }))
      );
    }, u = (r) => t.is24 ? r : (r >= 12 ? R.value = "PM" : R.value = "AM", $r(r)), y = () => {
      R.value === "PM" ? (R.value = "AM", a("update:hours", t.hours - 12)) : (R.value = "PM", a("update:hours", t.hours + 12)), a("am-pm-change", R.value);
    }, s = (r) => {
      S[r] = !0;
    }, _ = (r, U, N) => {
      if (r && t.arrowNavigation) {
        Array.isArray(W.value[U]) ? W.value[U][N] = r : W.value[U] = [r];
        const g = W.value.reduce(
          (F, ae) => ae.map((G, we) => [...F[we] || [], ae[we]]),
          []
        );
        l(t.closeTimePickerBtn), J.value && (g[1] = g[1].concat(J.value)), o(g, t.order);
      }
    }, ee = (r, U) => (V(r), r === "hours" && !t.is24 ? a(`update:${r}`, R.value === "PM" ? U + 12 : U) : a(`update:${r}`, U));
    return n({ openChildCmp: s }), (r, U) => {
      var N;
      return r.disabled ? B("", !0) : (D(), Y("div", yl, [
        (D(!0), Y(fe, null, Me(j.value, (g, F) => {
          var ae, G, we;
          return D(), Y("div", {
            key: F,
            class: he(q.value)
          }, [
            g.separator ? (D(), Y(fe, { key: 0 }, [
              at(" : ")
            ], 64)) : (D(), Y(fe, { key: 1 }, [
              ue("button", {
                type: "button",
                class: he({
                  dp__btn: !0,
                  dp__inc_dec_button: !t.timePickerInline,
                  dp__inc_dec_button_inline: t.timePickerInline,
                  dp__tp_inline_btn_top: t.timePickerInline,
                  dp__inc_dec_button_disabled: T.value(g.type)
                }),
                "aria-label": (ae = v(d)) == null ? void 0 : ae.incrementValue(g.type),
                tabindex: "0",
                onKeydown: [
                  oe(pe((se) => m(g.type), ["prevent"]), ["enter"]),
                  oe(pe((se) => m(g.type), ["prevent"]), ["space"])
                ],
                onClick: (se) => m(g.type),
                ref_for: !0,
                ref: (se) => _(se, F, 0)
              }, [
                t.timePickerInline ? (D(), Y(fe, { key: 1 }, [
                  pl,
                  bl
                ], 64)) : (D(), Y(fe, { key: 0 }, [
                  r.$slots["arrow-up"] ? te(r.$slots, "arrow-up", { key: 0 }) : B("", !0),
                  r.$slots["arrow-up"] ? B("", !0) : (D(), ve(v(In), { key: 1 }))
                ], 64))
              ], 42, hl),
              ue("button", {
                type: "button",
                "aria-label": (G = v(d)) == null ? void 0 : G.openTpOverlay(g.type),
                class: he({
                  dp__time_display: !0,
                  dp__time_display_block: !t.timePickerInline,
                  dp__time_display_inline: t.timePickerInline,
                  "dp--time-invalid": Z.value(g.type),
                  "dp--time-overlay-btn": !Z.value(g.type)
                }),
                disabled: c(g.type),
                tabindex: "0",
                onKeydown: [
                  oe(pe((se) => V(g.type), ["prevent"]), ["enter"]),
                  oe(pe((se) => V(g.type), ["prevent"]), ["space"])
                ],
                onClick: (se) => V(g.type),
                ref_for: !0,
                ref: (se) => _(se, F, 1)
              }, [
                r.$slots[g.type] ? te(r.$slots, g.type, {
                  key: 0,
                  text: f.value(g.type).text,
                  value: f.value(g.type).value
                }) : B("", !0),
                r.$slots[g.type] ? B("", !0) : (D(), Y(fe, { key: 1 }, [
                  at(Ie(f.value(g.type).text), 1)
                ], 64))
              ], 42, kl),
              ue("button", {
                type: "button",
                class: he({
                  dp__btn: !0,
                  dp__inc_dec_button: !t.timePickerInline,
                  dp__inc_dec_button_inline: t.timePickerInline,
                  dp__tp_inline_btn_bottom: t.timePickerInline,
                  dp__inc_dec_button_disabled: I.value(g.type)
                }),
                "aria-label": (we = v(d)) == null ? void 0 : we.decrementValue(g.type),
                tabindex: "0",
                onKeydown: [
                  oe(pe((se) => m(g.type, !1), ["prevent"]), ["enter"]),
                  oe(pe((se) => m(g.type, !1), ["prevent"]), ["space"])
                ],
                onClick: (se) => m(g.type, !1),
                ref_for: !0,
                ref: (se) => _(se, F, 2)
              }, [
                t.timePickerInline ? (D(), Y(fe, { key: 1 }, [
                  Dl,
                  Ml
                ], 64)) : (D(), Y(fe, { key: 0 }, [
                  r.$slots["arrow-down"] ? te(r.$slots, "arrow-down", { key: 0 }) : B("", !0),
                  r.$slots["arrow-down"] ? B("", !0) : (D(), ve(v(Yn), { key: 1 }))
                ], 64))
              ], 42, wl)
            ], 64))
          ], 2);
        }), 128)),
        r.is24 ? B("", !0) : (D(), Y("div", $l, [
          r.$slots["am-pm-button"] ? te(r.$slots, "am-pm-button", {
            key: 0,
            toggle: y,
            value: R.value
          }) : B("", !0),
          r.$slots["am-pm-button"] ? B("", !0) : (D(), Y("button", {
            key: 1,
            ref_key: "amPmButton",
            ref: J,
            type: "button",
            class: "dp__pm_am_button",
            role: "button",
            "aria-label": (N = v(d)) == null ? void 0 : N.amPmButton,
            tabindex: "0",
            onClick: y,
            onKeydown: [
              oe(pe(y, ["prevent"]), ["enter"]),
              oe(pe(y, ["prevent"]), ["space"])
            ]
          }, Ie(R.value), 41, Tl))
        ])),
        (D(!0), Y(fe, null, Me(le.value, (g, F) => (D(), ve(Dt, {
          key: F,
          name: v($)(S[g.type]),
          css: v(h)
        }, {
          default: ce(() => [
            S[g.type] ? (D(), ve(Nt, {
              key: 0,
              items: C(g.type),
              "is-last": r.autoApply && !r.keepActionRow,
              "esc-close": r.escClose,
              type: g.type,
              "text-input": r.textInput,
              "arrow-navigation": r.arrowNavigation,
              onSelected: (ae) => ee(g.type, ae),
              onToggle: (ae) => V(g.type),
              onResetFlow: U[0] || (U[0] = (ae) => r.$emit("reset-flow"))
            }, Fe({
              "button-icon": ce(() => [
                r.$slots["clock-icon"] ? te(r.$slots, "clock-icon", { key: 0 }) : B("", !0),
                r.$slots["clock-icon"] ? B("", !0) : (D(), ve(v(On), { key: 1 }))
              ]),
              _: 2
            }, [
              r.$slots[`${g.type}-overlay-value`] ? {
                name: "item",
                fn: ce(({ item: ae }) => [
                  te(r.$slots, `${g.type}-overlay-value`, {
                    text: ae.text,
                    value: ae.value
                  })
                ]),
                key: "0"
              } : void 0
            ]), 1032, ["items", "is-last", "esc-close", "type", "text-input", "arrow-navigation", "onSelected", "onToggle"])) : B("", !0)
          ]),
          _: 2
        }, 1032, ["name", "css"]))), 128))
      ]));
    };
  }
}), Sl = ["aria-label"], _l = ["tabindex"], Pl = ["aria-label"], Na = /* @__PURE__ */ Ee({
  compatConfig: {
    MODE: 3
  },
  __name: "TimePicker",
  props: {
    hours: { type: [Number, Array], default: 0 },
    minutes: { type: [Number, Array], default: 0 },
    seconds: { type: [Number, Array], default: 0 },
    disabledTimesConfig: { type: Function, default: null },
    ...Qe
  },
  emits: [
    "update:hours",
    "update:minutes",
    "update:seconds",
    "mount",
    "reset-flow",
    "overlay-opened",
    "overlay-closed",
    "am-pm-change"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, { buildMatrix: o, setTimePicker: l } = lt(), d = It(), { defaultedTransitions: M, defaultedAriaLabels: p, defaultedTextInput: $ } = Re(t), { transitionName: h, showTransition: S } = Bt(M), { hideNavigationButtons: R } = Jt(), J = z(null), W = z(null), Q = z([]), Z = z(null);
    Ue(() => {
      a("mount"), !t.timePicker && t.arrowNavigation ? o([Ae(J.value)], "time") : l(!0, t.timePicker);
    });
    const k = L(() => t.range && t.modelAuto ? Ma(t.internalModelValue) : !0), T = z(!1), I = (c) => ({
      hours: Array.isArray(t.hours) ? t.hours[c] : t.hours,
      minutes: Array.isArray(t.minutes) ? t.minutes[c] : t.minutes,
      seconds: Array.isArray(t.seconds) ? t.seconds[c] : t.seconds
    }), H = L(() => {
      const c = [];
      if (t.range)
        for (let V = 0; V < 2; V++)
          c.push(I(V));
      else
        c.push(I(0));
      return c;
    }), A = (c, V = !1, b = "") => {
      V || a("reset-flow"), T.value = c, a(c ? "overlay-opened" : "overlay-closed"), t.arrowNavigation && l(c), rt(() => {
        b !== "" && Q.value[0] && Q.value[0].openChildCmp(b);
      });
    }, q = L(() => ({
      dp__btn: !0,
      dp__button: !0,
      dp__button_bottom: t.autoApply && !t.keepActionRow
    })), j = je(d, "timePicker"), le = (c, V, b) => t.range ? V === 0 ? [c, H.value[1][b]] : [H.value[0][b], c] : c, f = (c) => {
      a("update:hours", c);
    }, w = (c) => {
      a("update:minutes", c);
    }, C = (c) => {
      a("update:seconds", c);
    }, K = () => {
      if (Z.value && !$.value.enabled) {
        const c = Ar(Z.value);
        c && c.focus({ preventScroll: !0 });
      }
    };
    return n({ toggleTimePicker: A }), (c, V) => {
      var b;
      return D(), Y("div", null, [
        !c.timePicker && !c.timePickerInline ? Wt((D(), Y("button", {
          key: 0,
          type: "button",
          class: he(q.value),
          "aria-label": (b = v(p)) == null ? void 0 : b.openTimePicker,
          tabindex: "0",
          ref_key: "openTimePickerBtn",
          ref: J,
          onKeydown: [
            V[0] || (V[0] = oe((m) => A(!0), ["enter"])),
            V[1] || (V[1] = oe((m) => A(!0), ["space"]))
          ],
          onClick: V[2] || (V[2] = (m) => A(!0))
        }, [
          c.$slots["clock-icon"] ? te(c.$slots, "clock-icon", { key: 0 }) : B("", !0),
          c.$slots["clock-icon"] ? B("", !0) : (D(), ve(v(On), { key: 1 }))
        ], 42, Sl)), [
          [zt, !v(R)(c.hideNavigation, "time")]
        ]) : B("", !0),
        qe(Dt, {
          name: v(h)(T.value),
          css: v(S) && !c.timePickerInline
        }, {
          default: ce(() => {
            var m;
            return [
              T.value || c.timePicker || c.timePickerInline ? (D(), Y("div", {
                key: 0,
                class: he({
                  dp__overlay: !c.timePickerInline,
                  "dp--overlay-absolute": !t.timePicker && !c.timePickerInline,
                  "dp--overlay-relative": t.timePicker
                }),
                style: Ge(c.timePicker ? { height: `${c.modeHeight}px` } : void 0),
                ref_key: "overlayRef",
                ref: Z,
                tabindex: c.timePickerInline ? void 0 : 0
              }, [
                ue("div", {
                  class: he(
                    c.timePickerInline ? "dp__time_picker_inline_container" : "dp__overlay_container dp__container_flex dp__time_picker_overlay_container"
                  ),
                  style: { display: "flex" }
                }, [
                  c.$slots["time-picker-overlay"] ? te(c.$slots, "time-picker-overlay", {
                    key: 0,
                    hours: e.hours,
                    minutes: e.minutes,
                    seconds: e.seconds,
                    setHours: f,
                    setMinutes: w,
                    setSeconds: C
                  }) : B("", !0),
                  c.$slots["time-picker-overlay"] ? B("", !0) : (D(), Y("div", {
                    key: 1,
                    class: he(c.timePickerInline ? "dp__flex" : "dp__overlay_row dp__flex_row")
                  }, [
                    (D(!0), Y(fe, null, Me(H.value, (u, y) => Wt((D(), ve(Al, Be({ key: y }, {
                      ...c.$props,
                      order: y,
                      hours: u.hours,
                      minutes: u.minutes,
                      seconds: u.seconds,
                      closeTimePickerBtn: W.value,
                      disabledTimesConfig: e.disabledTimesConfig,
                      disabled: y === 0 ? c.fixedStart : c.fixedEnd
                    }, {
                      ref_for: !0,
                      ref_key: "timeInputRefs",
                      ref: Q,
                      "onUpdate:hours": (s) => f(le(s, y, "hours")),
                      "onUpdate:minutes": (s) => w(le(s, y, "minutes")),
                      "onUpdate:seconds": (s) => C(le(s, y, "seconds")),
                      onMounted: K,
                      onOverlayClosed: K,
                      onAmPmChange: V[3] || (V[3] = (s) => c.$emit("am-pm-change", s))
                    }), Fe({ _: 2 }, [
                      Me(v(j), (s, _) => ({
                        name: s,
                        fn: ce((ee) => [
                          te(c.$slots, s, Ce(He(ee)))
                        ])
                      }))
                    ]), 1040, ["onUpdate:hours", "onUpdate:minutes", "onUpdate:seconds"])), [
                      [zt, y === 0 ? !0 : k.value]
                    ])), 128))
                  ], 2)),
                  !c.timePicker && !c.timePickerInline ? Wt((D(), Y("button", {
                    key: 2,
                    type: "button",
                    ref_key: "closeTimePickerBtn",
                    ref: W,
                    class: he(q.value),
                    "aria-label": (m = v(p)) == null ? void 0 : m.closeTimePicker,
                    tabindex: "0",
                    onKeydown: [
                      V[4] || (V[4] = oe((u) => A(!1), ["enter"])),
                      V[5] || (V[5] = oe((u) => A(!1), ["space"]))
                    ],
                    onClick: V[6] || (V[6] = (u) => A(!1))
                  }, [
                    c.$slots["calendar-icon"] ? te(c.$slots, "calendar-icon", { key: 0 }) : B("", !0),
                    c.$slots["calendar-icon"] ? B("", !0) : (D(), ve(v(Yt), { key: 1 }))
                  ], 42, Pl)), [
                    [zt, !v(R)(c.hideNavigation, "time")]
                  ]) : B("", !0)
                ], 2)
              ], 14, _l)) : B("", !0)
            ];
          }),
          _: 3
        }, 8, ["name", "css"])
      ]);
    };
  }
}), Oa = (e, n, a, t) => {
  const o = (k, T) => Array.isArray(n[k]) ? n[k][T] : n[k], l = (k) => e.enableSeconds ? Array.isArray(n.seconds) ? n.seconds[k] : n.seconds : 0, d = (k, T) => k ? T !== void 0 ? nt(k, o("hours", T), o("minutes", T), l(T)) : nt(k, n.hours, n.minutes, l()) : P(), M = (k, T) => {
    n[k] = T;
  }, p = (k, T) => {
    const I = Object.fromEntries(
      Object.keys(n).map((H) => H === k ? [H, T] : [H, n[H]].slice())
    );
    if (e.range && !e.disableTimeRangeValidation) {
      const H = (q) => a.value ? nt(
        a.value[q],
        I.hours[q],
        I.minutes[q],
        I.seconds[q]
      ) : null, A = (q) => Cn(a.value[q], 0);
      return !(ye(H(0), H(1)) && (Pt(H(0), A(1)) || _t(H(1), A(0))));
    }
    return !0;
  }, $ = (k, T) => {
    p(k, T) && (M(k, T), t && t());
  }, h = (k) => {
    $("hours", k);
  }, S = (k) => {
    $("minutes", k);
  }, R = (k) => {
    $("seconds", k);
  }, J = (k, T, I, H) => {
    T && h(k), !T && !I && S(k), I && R(k), a.value && H(a.value);
  }, W = (k) => {
    if (k) {
      const T = Array.isArray(k), I = T ? [+k[0].hours, +k[1].hours] : +k.hours, H = T ? [+k[0].minutes, +k[1].minutes] : +k.minutes, A = T ? [+k[0].seconds, +k[1].seconds] : +k.seconds;
      M("hours", I), M("minutes", H), e.enableSeconds && M("seconds", A);
    }
  }, Q = (k, T) => {
    const I = {
      hours: Array.isArray(n.hours) ? n.hours[k] : n.hours,
      disabledArr: []
    };
    return (T || T === 0) && (I.hours = T), Array.isArray(e.disabledTimes) && (I.disabledArr = e.range && Array.isArray(e.disabledTimes[k]) ? e.disabledTimes[k] : e.disabledTimes), I;
  }, Z = L(() => (k, T) => {
    var I;
    if (Array.isArray(e.disabledTimes)) {
      const { disabledArr: H, hours: A } = Q(k, T), q = H.filter((j) => +j.hours === A);
      return ((I = q[0]) == null ? void 0 : I.minutes) === "*" ? { hours: [A], minutes: void 0, seconds: void 0 } : {
        hours: [],
        minutes: (q == null ? void 0 : q.map((j) => +j.minutes)) ?? [],
        seconds: (q == null ? void 0 : q.map((j) => j.seconds ? +j.seconds : void 0)) ?? []
      };
    }
    return { hours: [], minutes: [], seconds: [] };
  });
  return {
    setTime: M,
    updateHours: h,
    updateMinutes: S,
    updateSeconds: R,
    getSetDateTime: d,
    updateTimeValues: J,
    getSecondsValue: l,
    assignStartTime: W,
    disabledTimesConfig: Z
  };
}, Cl = (e, n) => {
  const { modelValue: a, time: t } = qt(e, n), { defaultedStartTime: o } = Re(e), { updateTimeValues: l, getSetDateTime: d, setTime: M, assignStartTime: p, disabledTimesConfig: $ } = Oa(
    e,
    t,
    a
  ), h = (T) => {
    const { hours: I, minutes: H, seconds: A } = T;
    return { hours: +I, minutes: +H, seconds: A ? +A : 0 };
  }, S = () => {
    if (e.startTime) {
      if (Array.isArray(e.startTime)) {
        const I = h(e.startTime[0]), H = h(e.startTime[1]);
        return [ke(P(), I), ke(P(), H)];
      }
      const T = h(e.startTime);
      return ke(P(), T);
    }
    return e.range ? [null, null] : null;
  }, R = () => {
    if (e.range) {
      const [T, I] = S();
      a.value = [d(T, 0), d(I, 1)];
    } else
      a.value = d(S());
  }, J = (T) => Array.isArray(T) ? [vt(P(T[0])), vt(P(T[1]))] : [vt(T ?? P())], W = (T, I, H) => {
    M("hours", T), M("minutes", I), e.enableSeconds && M("seconds", H);
  }, Q = () => {
    const [T, I] = J(a.value);
    return e.range ? W(
      [T.hours, I.hours],
      [T.minutes, I.minutes],
      [T.seconds, I.minutes]
    ) : W(T.hours, T.minutes, T.seconds);
  };
  Ue(() => {
    if (!e.shadow)
      return p(o.value), a.value ? Q() : R();
  });
  const Z = () => {
    Array.isArray(a.value) ? a.value = a.value.map((T, I) => T && d(T, I)) : a.value = d(a.value), n("time-update");
  };
  return {
    time: t,
    disabledTimesConfig: $,
    updateTime: (T, I = !0, H = !1) => {
      l(T, I, H, Z);
    }
  };
}, Rl = /* @__PURE__ */ Ee({
  compatConfig: {
    MODE: 3
  },
  __name: "TimePickerSolo",
  props: {
    ...Qe
  },
  emits: ["update:internal-model-value", "time-update", "am-pm-change"],
  setup(e, { emit: n }) {
    const a = e, t = It(), o = je(t, "timePicker"), { time: l, disabledTimesConfig: d, updateTime: M } = Cl(a, n);
    return (p, $) => (D(), ve(Ln, {
      "multi-calendars": 0,
      stretch: ""
    }, {
      default: ce(() => [
        qe(Na, Be(p.$props, {
          hours: v(l).hours,
          minutes: v(l).minutes,
          seconds: v(l).seconds,
          "internal-model-value": p.internalModelValue,
          "disabled-times-config": v(d),
          "onUpdate:hours": $[0] || ($[0] = (h) => v(M)(h)),
          "onUpdate:minutes": $[1] || ($[1] = (h) => v(M)(h, !1)),
          "onUpdate:seconds": $[2] || ($[2] = (h) => v(M)(h, !1, !0)),
          onAmPmChange: $[3] || ($[3] = (h) => p.$emit("am-pm-change", h))
        }), Fe({ _: 2 }, [
          Me(v(o), (h, S) => ({
            name: h,
            fn: ce((R) => [
              te(p.$slots, h, Ce(He(R)))
            ])
          }))
        ]), 1040, ["hours", "minutes", "seconds", "internal-model-value", "disabled-times-config"])
      ]),
      _: 3
    }));
  }
}), Nl = { class: "dp__month_year_row" }, Ol = ["aria-label", "onClick", "onKeydown"], Il = /* @__PURE__ */ Ee({
  compatConfig: {
    MODE: 3
  },
  __name: "DpHeader",
  props: {
    month: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    instance: { type: Number, default: 0 },
    years: { type: Array, default: () => [] },
    months: { type: Array, default: () => [] },
    ...Qe
  },
  emits: ["update-month-year", "mount", "reset-flow", "overlay-closed"],
  setup(e, { expose: n, emit: a }) {
    const t = e, { defaultedTransitions: o, defaultedAriaLabels: l, defaultedMultiCalendars: d, defaultedFilters: M } = Re(t), { transitionName: p, showTransition: $ } = Bt(o), { buildMatrix: h } = lt(), { handleMonthYearChange: S, isDisabled: R, updateMonthYear: J } = jr(t, a), { showLeftIcon: W, showRightIcon: Q } = Jt(), Z = z(!1), k = z(!1), T = z([null, null, null, null]);
    Ue(() => {
      a("mount");
    });
    const I = (u) => ({
      get: () => t[u],
      set: (y) => {
        const s = u === We.month ? We.year : We.month;
        a("update-month-year", { [u]: y, [s]: t[s] }), u === We.month ? C(!0) : K(!0);
      }
    }), H = L(I(We.month)), A = L(I(We.year)), q = L(() => (u) => ({
      month: t.month,
      year: t.year,
      items: u === We.month ? t.months : t.years,
      instance: t.instance,
      updateMonthYear: J,
      toggle: u === We.month ? C : K
    })), j = L(() => {
      const u = t.months.find((y) => y.value === t.month);
      return u || { text: "", value: 0 };
    }), le = L(() => kt(t.months, (u) => {
      const y = t.month === u.value, s = Rt(
        u.value,
        $a(t.year, t.minDate),
        Ta(t.year, t.maxDate)
      ) || M.value.months.includes(u.value);
      return { active: y, disabled: s };
    })), f = L(() => kt(t.years, (u) => {
      const y = t.year === u.value, s = Rt(u.value, wt(t.minDate), wt(t.maxDate)) || M.value.years.includes(u.value);
      return { active: y, disabled: s };
    })), w = (u, y) => {
      y !== void 0 ? u.value = y : u.value = !u.value, u.value || a("overlay-closed");
    }, C = (u = !1, y) => {
      c(u), w(Z, y);
    }, K = (u = !1, y) => {
      c(u), w(k, y);
    }, c = (u) => {
      u || a("reset-flow");
    }, V = (u, y) => {
      t.arrowNavigation && (T.value[y] = Ae(u), h(T.value, "monthYear"));
    }, b = L(() => {
      var u, y;
      return [
        {
          type: We.month,
          index: 1,
          toggle: C,
          modelValue: H.value,
          updateModelValue: (s) => H.value = s,
          text: j.value.text,
          showSelectionGrid: Z.value,
          items: le.value,
          ariaLabel: (u = l.value) == null ? void 0 : u.openMonthsOverlay
        },
        {
          type: We.year,
          index: 2,
          toggle: K,
          modelValue: A.value,
          updateModelValue: (s) => A.value = s,
          text: t.year,
          showSelectionGrid: k.value,
          items: f.value,
          ariaLabel: (y = l.value) == null ? void 0 : y.openYearsOverlay
        }
      ];
    }), m = L(
      () => t.disableYearSelect ? [b.value[0]] : b.value
    );
    return n({
      toggleMonthPicker: C,
      toggleYearPicker: K,
      handleMonthYearChange: S
    }), (u, y) => {
      var s, _, ee;
      return D(), Y("div", Nl, [
        u.$slots["month-year"] ? te(u.$slots, "month-year", Ce(Be({ key: 0 }, { month: e.month, year: e.year, months: e.months, years: e.years, updateMonthYear: v(J), handleMonthYearChange: v(S), instance: e.instance }))) : (D(), Y(fe, { key: 1 }, [
          v(W)(v(d), e.instance) && !u.vertical ? (D(), ve(St, {
            key: 0,
            "aria-label": (s = v(l)) == null ? void 0 : s.prevMonth,
            disabled: v(R)(!1),
            onActivate: y[0] || (y[0] = (r) => v(S)(!1, !0)),
            onSetRef: y[1] || (y[1] = (r) => V(r, 0))
          }, {
            default: ce(() => [
              u.$slots["arrow-left"] ? te(u.$slots, "arrow-left", { key: 0 }) : B("", !0),
              u.$slots["arrow-left"] ? B("", !0) : (D(), ve(v(Rn), { key: 1 }))
            ]),
            _: 3
          }, 8, ["aria-label", "disabled"])) : B("", !0),
          ue("div", {
            class: he(["dp__month_year_wrap", {
              dp__year_disable_select: u.disableYearSelect
            }])
          }, [
            (D(!0), Y(fe, null, Me(m.value, (r, U) => (D(), Y(fe, {
              key: r.type
            }, [
              ue("button", {
                type: "button",
                class: "dp__btn dp__month_year_select",
                tabindex: "0",
                "aria-label": r.ariaLabel,
                ref_for: !0,
                ref: (N) => V(N, U + 1),
                onClick: r.toggle,
                onKeydown: [
                  oe(pe(r.toggle, ["prevent"]), ["enter"]),
                  oe(pe(r.toggle, ["prevent"]), ["space"])
                ]
              }, [
                u.$slots[r.type] ? te(u.$slots, r.type, {
                  key: 0,
                  text: r.text,
                  value: t[r.type]
                }) : B("", !0),
                u.$slots[r.type] ? B("", !0) : (D(), Y(fe, { key: 1 }, [
                  at(Ie(r.text), 1)
                ], 64))
              ], 40, Ol),
              qe(Dt, {
                name: v(p)(r.showSelectionGrid),
                css: v($)
              }, {
                default: ce(() => [
                  r.showSelectionGrid ? (D(), ve(Nt, {
                    key: 0,
                    items: r.items,
                    "arrow-navigation": u.arrowNavigation,
                    "hide-navigation": u.hideNavigation,
                    "is-last": u.autoApply && !u.keepActionRow,
                    "skip-button-ref": !1,
                    type: r.type,
                    "header-refs": [],
                    "esc-close": u.escClose,
                    "text-input": u.textInput,
                    onSelected: r.updateModelValue,
                    onToggle: r.toggle
                  }, Fe({
                    "button-icon": ce(() => [
                      u.$slots["calendar-icon"] ? te(u.$slots, "calendar-icon", { key: 0 }) : B("", !0),
                      u.$slots["calendar-icon"] ? B("", !0) : (D(), ve(v(Yt), { key: 1 }))
                    ]),
                    _: 2
                  }, [
                    u.$slots[`${r.type}-overlay-val`] ? {
                      name: "item",
                      fn: ce(({ item: N }) => [
                        te(u.$slots, `${r.type}-overlay-val`, {
                          text: N.text,
                          value: N.value
                        })
                      ]),
                      key: "0"
                    } : void 0,
                    u.$slots[`${r.type}-overlay`] ? {
                      name: "overlay",
                      fn: ce(() => [
                        te(u.$slots, `${r.type}-overlay`, Ce(He(q.value(r.type))))
                      ]),
                      key: "1"
                    } : void 0,
                    u.$slots[`${r.type}-overlay-header`] ? {
                      name: "header",
                      fn: ce(() => [
                        te(u.$slots, `${r.type}-overlay-header`, {
                          toggle: r.toggle
                        })
                      ]),
                      key: "2"
                    } : void 0
                  ]), 1032, ["items", "arrow-navigation", "hide-navigation", "is-last", "type", "esc-close", "text-input", "onSelected", "onToggle"])) : B("", !0)
                ]),
                _: 2
              }, 1032, ["name", "css"])
            ], 64))), 128))
          ], 2),
          v(W)(v(d), e.instance) && u.vertical ? (D(), ve(St, {
            key: 1,
            "aria-label": (_ = v(l)) == null ? void 0 : _.prevMonth,
            disabled: v(R)(!1),
            onActivate: y[2] || (y[2] = (r) => v(S)(!1, !0))
          }, {
            default: ce(() => [
              u.$slots["arrow-up"] ? te(u.$slots, "arrow-up", { key: 0 }) : B("", !0),
              u.$slots["arrow-up"] ? B("", !0) : (D(), ve(v(In), { key: 1 }))
            ]),
            _: 3
          }, 8, ["aria-label", "disabled"])) : B("", !0),
          v(Q)(v(d), e.instance) ? (D(), ve(St, {
            key: 2,
            ref: "rightIcon",
            disabled: v(R)(!0),
            "aria-label": (ee = v(l)) == null ? void 0 : ee.nextMonth,
            onActivate: y[3] || (y[3] = (r) => v(S)(!0, !0)),
            onSetRef: y[4] || (y[4] = (r) => V(r, u.disableYearSelect ? 2 : 3))
          }, {
            default: ce(() => [
              u.$slots[u.vertical ? "arrow-down" : "arrow-right"] ? te(u.$slots, u.vertical ? "arrow-down" : "arrow-right", { key: 0 }) : B("", !0),
              u.$slots[u.vertical ? "arrow-down" : "arrow-right"] ? B("", !0) : (D(), ve(Pn(u.vertical ? v(Yn) : v(Nn)), { key: 1 }))
            ]),
            _: 3
          }, 8, ["disabled", "aria-label"])) : B("", !0)
        ], 64))
      ]);
    };
  }
}), Yl = ["aria-label"], Bl = {
  class: "dp__calendar_header",
  role: "row"
}, El = {
  key: 0,
  class: "dp__calendar_header_item",
  role: "gridcell"
}, Fl = /* @__PURE__ */ ue("div", { class: "dp__calendar_header_separator" }, null, -1), Vl = ["aria-label"], Hl = {
  key: 0,
  role: "gridcell",
  class: "dp__calendar_item dp__week_num"
}, Ll = { class: "dp__cell_inner" }, Ul = ["aria-selected", "aria-disabled", "aria-label", "onClick", "onKeydown", "onMouseenter", "onMouseleave"], Wl = /* @__PURE__ */ Ee({
  compatConfig: {
    MODE: 3
  },
  __name: "DpCalendar",
  props: {
    mappedDates: { type: Array, default: () => [] },
    instance: { type: Number, default: 0 },
    month: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    ...Qe
  },
  emits: [
    "select-date",
    "set-hover-date",
    "handle-scroll",
    "mount",
    "handle-swipe",
    "handle-space",
    "tooltip-open",
    "tooltip-close"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, { buildMultiLevelMatrix: o } = lt(), { defaultedTransitions: l, defaultedAriaLabels: d, defaultedMultiCalendars: M } = Re(t), p = z(null), $ = z({
      bottom: "",
      left: "",
      transform: ""
    }), h = z([]), S = z(null), R = z(!0), J = z(""), W = z({ startX: 0, endX: 0, startY: 0, endY: 0 }), Q = z([]), Z = z({ left: "50%" }), k = L(() => t.calendar ? t.calendar(t.mappedDates) : t.mappedDates), T = L(() => t.dayNames ? Array.isArray(t.dayNames) ? t.dayNames : t.dayNames(t.locale, +t.weekStart) : Mr(t.formatLocale, t.locale, +t.weekStart));
    Ue(() => {
      a("mount", { cmp: "calendar", refs: h }), t.noSwipe || S.value && (S.value.addEventListener("touchstart", K, { passive: !1 }), S.value.addEventListener("touchend", c, { passive: !1 }), S.value.addEventListener("touchmove", V, { passive: !1 })), t.monthChangeOnScroll && S.value && S.value.addEventListener("wheel", u, { passive: !1 });
    });
    const I = (s) => s ? t.vertical ? "vNext" : "next" : t.vertical ? "vPrevious" : "previous", H = (s, _) => {
      if (t.transitions) {
        const ee = Le(xe(P(), t.month, t.year));
        J.value = Ne(Le(xe(P(), s, _)), ee) ? l.value[I(!0)] : l.value[I(!1)], R.value = !1, rt(() => {
          R.value = !0;
        });
      }
    }, A = L(
      () => ({
        [t.calendarClassName]: !!t.calendarClassName
      })
    ), q = L(() => (s) => {
      const _ = Tr(s);
      return {
        dp__marker_dot: _.type === "dot",
        dp__marker_line: _.type === "line"
      };
    }), j = L(() => (s) => ye(s, p.value)), le = L(() => ({
      dp__calendar: !0,
      dp__calendar_next: M.value.count > 0 && t.instance !== 0
    })), f = L(() => (s) => t.hideOffsetDates ? s.current : !0), w = async (s, _, ee) => {
      var r, U;
      if (a("set-hover-date", s), (U = (r = s.marker) == null ? void 0 : r.tooltip) != null && U.length) {
        const N = Ae(h.value[_][ee]);
        if (N) {
          const { width: g, height: F } = N.getBoundingClientRect();
          p.value = s.value;
          let ae = { left: `${g / 2}px` }, G = -50;
          if (await rt(), Q.value[0]) {
            const { left: we, width: se } = Q.value[0].getBoundingClientRect();
            we < 0 && (ae = { left: "0" }, G = 0, Z.value.left = `${g / 2}px`), window.innerWidth < we + se && (ae = { right: "0" }, G = 0, Z.value.left = `${se - g / 2}px`);
          }
          $.value = {
            bottom: `${F}px`,
            ...ae,
            transform: `translateX(${G}%)`
          }, a("tooltip-open", s.marker);
        }
      }
    }, C = (s) => {
      p.value && (p.value = null, $.value = JSON.parse(JSON.stringify({ bottom: "", left: "", transform: "" })), a("tooltip-close", s.marker));
    }, K = (s) => {
      W.value.startX = s.changedTouches[0].screenX, W.value.startY = s.changedTouches[0].screenY;
    }, c = (s) => {
      W.value.endX = s.changedTouches[0].screenX, W.value.endY = s.changedTouches[0].screenY, b();
    }, V = (s) => {
      t.vertical && !t.inline && s.preventDefault();
    }, b = () => {
      const s = t.vertical ? "Y" : "X";
      Math.abs(W.value[`start${s}`] - W.value[`end${s}`]) > 10 && a("handle-swipe", W.value[`start${s}`] > W.value[`end${s}`] ? "right" : "left");
    }, m = (s, _, ee) => {
      s && (Array.isArray(h.value[_]) ? h.value[_][ee] = s : h.value[_] = [s]), t.arrowNavigation && o(h.value, "calendar");
    }, u = (s) => {
      t.monthChangeOnScroll && (s.preventDefault(), a("handle-scroll", s));
    }, y = (s) => {
      const _ = s[0];
      return t.weekNumbers === "local" ? Za(_.value, { weekStartsOn: +t.weekStart }) : t.weekNumbers === "iso" ? qa(_.value) : typeof t.weekNumbers == "function" ? t.weekNumbers(_.value) : "";
    };
    return n({ triggerTransition: H }), (s, _) => {
      var ee;
      return D(), Y("div", {
        class: he(le.value)
      }, [
        ue("div", {
          ref_key: "calendarWrapRef",
          ref: S,
          role: "grid",
          class: he(A.value),
          "aria-label": (ee = v(d)) == null ? void 0 : ee.calendarWrap
        }, [
          (D(), Y(fe, { key: 0 }, [
            ue("div", Bl, [
              s.weekNumbers ? (D(), Y("div", El, Ie(s.weekNumName), 1)) : B("", !0),
              (D(!0), Y(fe, null, Me(T.value, (r, U) => (D(), Y("div", {
                class: "dp__calendar_header_item",
                role: "gridcell",
                key: U
              }, [
                s.$slots["calendar-header"] ? te(s.$slots, "calendar-header", {
                  key: 0,
                  day: r,
                  index: U
                }) : B("", !0),
                s.$slots["calendar-header"] ? B("", !0) : (D(), Y(fe, { key: 1 }, [
                  at(Ie(r), 1)
                ], 64))
              ]))), 128))
            ]),
            Fl,
            qe(Dt, {
              name: J.value,
              css: !!s.transitions
            }, {
              default: ce(() => {
                var r;
                return [
                  R.value ? (D(), Y("div", {
                    key: 0,
                    class: "dp__calendar",
                    role: "grid",
                    "aria-label": ((r = v(d)) == null ? void 0 : r.calendarDays) || void 0
                  }, [
                    (D(!0), Y(fe, null, Me(k.value, (U, N) => (D(), Y("div", {
                      class: "dp__calendar_row",
                      role: "row",
                      key: N
                    }, [
                      s.weekNumbers ? (D(), Y("div", Hl, [
                        ue("div", Ll, Ie(y(U.days)), 1)
                      ])) : B("", !0),
                      (D(!0), Y(fe, null, Me(U.days, (g, F) => {
                        var ae, G, we;
                        return D(), Y("div", {
                          role: "gridcell",
                          class: "dp__calendar_item",
                          ref_for: !0,
                          ref: (se) => m(se, N, F),
                          key: F + N,
                          "aria-selected": g.classData.dp__active_date || g.classData.dp__range_start || g.classData.dp__range_start,
                          "aria-disabled": g.classData.dp__cell_disabled || void 0,
                          "aria-label": (G = (ae = v(d)) == null ? void 0 : ae.day) == null ? void 0 : G.call(ae, g),
                          tabindex: "0",
                          onClick: pe((se) => s.$emit("select-date", g), ["stop", "prevent"]),
                          onKeydown: [
                            oe((se) => s.$emit("select-date", g), ["enter"]),
                            oe((se) => s.$emit("handle-space", g), ["space"])
                          ],
                          onMouseenter: (se) => w(g, N, F),
                          onMouseleave: (se) => C(g)
                        }, [
                          ue("div", {
                            class: he(["dp__cell_inner", g.classData])
                          }, [
                            s.$slots.day && f.value(g) ? te(s.$slots, "day", {
                              key: 0,
                              day: +g.text,
                              date: g.value
                            }) : B("", !0),
                            s.$slots.day ? B("", !0) : (D(), Y(fe, { key: 1 }, [
                              at(Ie(g.text), 1)
                            ], 64)),
                            g.marker && f.value(g) ? (D(), Y(fe, { key: 2 }, [
                              s.$slots.marker ? te(s.$slots, "marker", {
                                key: 0,
                                marker: g.marker,
                                day: +g.text,
                                date: g.value
                              }) : (D(), Y("div", {
                                key: 1,
                                class: he(q.value(g.marker)),
                                style: Ge(g.marker.color ? { backgroundColor: g.marker.color } : {})
                              }, null, 6))
                            ], 64)) : B("", !0),
                            j.value(g.value) ? (D(), Y("div", {
                              key: 3,
                              class: "dp__marker_tooltip",
                              ref_for: !0,
                              ref_key: "activeTooltip",
                              ref: Q,
                              style: Ge($.value)
                            }, [
                              (we = g.marker) != null && we.tooltip ? (D(), Y("div", {
                                key: 0,
                                class: "dp__tooltip_content",
                                onClick: _[0] || (_[0] = pe(() => {
                                }, ["stop"]))
                              }, [
                                (D(!0), Y(fe, null, Me(g.marker.tooltip, (se, O) => (D(), Y("div", {
                                  key: O,
                                  class: "dp__tooltip_text"
                                }, [
                                  s.$slots["marker-tooltip"] ? te(s.$slots, "marker-tooltip", {
                                    key: 0,
                                    tooltip: se,
                                    day: g.value
                                  }) : B("", !0),
                                  s.$slots["marker-tooltip"] ? B("", !0) : (D(), Y(fe, { key: 1 }, [
                                    ue("div", {
                                      class: "dp__tooltip_mark",
                                      style: Ge(se.color ? { backgroundColor: se.color } : {})
                                    }, null, 4),
                                    ue("div", null, Ie(se.text), 1)
                                  ], 64))
                                ]))), 128)),
                                ue("div", {
                                  class: "dp__arrow_bottom_tp",
                                  style: Ge(Z.value)
                                }, null, 4)
                              ])) : B("", !0)
                            ], 4)) : B("", !0)
                          ], 2)
                        ], 40, Ul);
                      }), 128))
                    ]))), 128))
                  ], 8, Vl)) : B("", !0)
                ];
              }),
              _: 3
            }, 8, ["name", "css"])
          ], 64))
        ], 10, Yl)
      ], 2);
    };
  }
}), ua = (e) => Array.isArray(e), zl = (e, n, a, t) => {
  const o = z([]), { modelValue: l, calendars: d, time: M } = qt(e, n), { defaultedMultiCalendars: p, defaultedStartTime: $ } = Re(e), { validateMonthYearInRange: h, isDisabled: S, isDateRangeAllowed: R, checkMinMaxRange: J } = Et(e), { updateTimeValues: W, getSetDateTime: Q, setTime: Z, assignStartTime: k, disabledTimesConfig: T } = Oa(
    e,
    M,
    l,
    t
  ), I = L(
    () => (i) => d.value[i] ? d.value[i].month : 0
  ), H = L(
    () => (i) => d.value[i] ? d.value[i].year : 0
  ), A = (i, E, ne) => {
    var de, De;
    d.value[i] || (d.value[i] = { month: 0, year: 0 }), d.value[i].month = na(E) ? (de = d.value[i]) == null ? void 0 : de.month : E, d.value[i].year = na(ne) ? (De = d.value[i]) == null ? void 0 : De.year : ne;
  }, q = () => {
    e.autoApply && n("select-date");
  };
  gt(l, (i, E) => {
    JSON.stringify(i) !== JSON.stringify(E) && f();
  }), Ue(() => {
    e.shadow || (l.value || (s(), $.value && k($.value)), f(!0), e.focusStartDate && e.startDate && s());
  });
  const j = L(() => {
    var i;
    return (i = e.flow) != null && i.length && !e.partialFlow ? e.flowStep === e.flow.length : !0;
  }), le = () => {
    e.autoApply && j.value && n("auto-apply", e.partialFlow);
  }, f = (i = !1) => {
    if (l.value)
      return Array.isArray(l.value) ? (o.value = l.value, b(i)) : C(l.value, i);
    if (p.value.count && i && !e.startDate)
      return w(P(), i);
  }, w = (i, E = !1) => {
    if ((!p.value.count || !p.value.static || E) && A(0, ge(i), me(i)), p.value.count)
      for (let ne = 1; ne < p.value.count; ne++) {
        const de = ke(P(), { month: I.value(ne - 1), year: H.value(ne - 1) }), De = ha(de, { months: 1 });
        d.value[ne] = { month: ge(De), year: me(De) };
      }
  }, C = (i, E) => {
    w(i), Z("hours", Je(i)), Z("minutes", Xe(i)), Z("seconds", bt(i)), p.value.count && E && y();
  }, K = (i) => {
    if (p.value.count) {
      if (p.value.solo)
        return 0;
      const E = ge(i[0]), ne = ge(i[1]);
      return Math.abs(ne - E) < p.value.count ? 0 : 1;
    }
    return 1;
  }, c = (i, E) => {
    i[1] && e.showLastInRange ? w(i[K(i)], E) : w(i[0], E);
    const ne = (de, De) => [
      de(i[0]),
      i[1] ? de(i[1]) : M[De][1]
    ];
    Z("hours", ne(Je, "hours")), Z("minutes", ne(Xe, "minutes")), Z("seconds", ne(bt, "seconds"));
  }, V = (i, E) => {
    if ((e.range || e.weekPicker) && !e.multiDates)
      return c(i, E);
    if (e.multiDates && E) {
      const ne = i[i.length - 1];
      return C(ne, E);
    }
  }, b = (i) => {
    const E = l.value;
    V(E, i), p.value.count && p.value.solo && y();
  }, m = (i, E) => {
    const ne = ke(P(), { month: I.value(E), year: H.value(E) }), de = i < 0 ? ft(ne, 1) : Ct(ne, 1);
    h(ge(de), me(de), i < 0, e.preventMinMaxNavigation) && (A(E, ge(de), me(de)), p.value.count && !p.value.solo && u(E), a());
  }, u = (i) => {
    for (let E = i - 1; E >= 0; E--) {
      const ne = Ct(ke(P(), { month: I.value(E + 1), year: H.value(E + 1) }), 1);
      A(E, ge(ne), me(ne));
    }
    for (let E = i + 1; E <= p.value.count - 1; E++) {
      const ne = ft(ke(P(), { month: I.value(E - 1), year: H.value(E - 1) }), 1);
      A(E, ge(ne), me(ne));
    }
  }, y = () => {
    if (Array.isArray(l.value) && l.value.length === 2) {
      const i = P(
        P(l.value[1] ? l.value[1] : ft(l.value[0], 1))
      ), [E, ne] = [ge(l.value[0]), me(l.value[0])], [de, De] = [ge(l.value[1]), me(l.value[1])];
      (E !== de || E === de && ne !== De) && p.value.solo && A(1, ge(i), me(i));
    } else
      l.value && !Array.isArray(l.value) && (A(0, ge(l.value), me(l.value)), w(P()));
  }, s = () => {
    e.startDate && (A(0, ge(P(e.startDate)), me(P(e.startDate))), p.value.count && u(0));
  }, _ = (i, E) => {
    e.monthChangeOnScroll && m(e.monthChangeOnScroll !== "inverse" ? -i.deltaY : i.deltaY, E);
  }, ee = (i, E, ne = !1) => {
    e.monthChangeOnArrows && e.vertical === ne && r(i, E);
  }, r = (i, E) => {
    m(i === "right" ? -1 : 1, E);
  }, U = (i) => e.markers.find((E) => ye(ra(i.value), ra(E.date))), N = (i, E) => {
    switch (e.sixWeeks === !0 ? "append" : e.sixWeeks) {
      case "prepend":
        return [!0, !1];
      case "center":
        return [i == 0, !0];
      case "fair":
        return [i == 0 || E > i, !0];
      case "append":
        return [!1, !1];
      default:
        return [!1, !1];
    }
  }, g = (i, E, ne, de) => {
    if (e.sixWeeks && i.length < 6) {
      const De = 6 - i.length, et = (E.getDay() + 7 - de) % 7, Vt = 6 - (ne.getDay() + 7 - de) % 7, [Tt, ln] = N(et, Vt);
      for (let ot = 1; ot <= De; ot++)
        if (ln ? !!(ot % 2) == Tt : Tt) {
          const Ht = i[0].days[0], on = F(it(Ht.value, -7), ge(E));
          i.unshift({ days: on });
        } else {
          const Ht = i[i.length - 1], on = Ht.days[Ht.days.length - 1], Ya = F(it(on.value, 1), ge(E));
          i.push({ days: Ya });
        }
    }
    return i;
  }, F = (i, E) => {
    const ne = P(JSON.parse(JSON.stringify(i))), de = [];
    for (let De = 0; De < 7; De++) {
      const et = it(ne, De), $t = ge(et) !== E;
      de.push({
        text: e.hideOffsetDates && $t ? "" : et.getDate(),
        value: et,
        current: !$t,
        classData: {}
      });
    }
    return de;
  }, ae = (i, E) => {
    const ne = [], de = P(Ze(new Date(E, i), e.timezone)), De = P(Ze(new Date(E, i + 1, 0), e.timezone)), et = e.weekStart, $t = ma(de, { weekStartsOn: et }), Vt = (Tt) => {
      const ln = F(Tt, i);
      if (ne.push({ days: ln }), !ne[ne.length - 1].days.some(
        (ot) => ye(Le(ot.value), Le(De))
      )) {
        const ot = it(Tt, 7);
        Vt(ot);
      }
    };
    return Vt($t), g(ne, de, De, et);
  }, G = (i) => (l.value = Kt(P(i.value), e.timezone, e.weekStart), le()), we = (i) => {
    const E = nt(P(i.value), M.hours, M.minutes, Ft());
    e.multiDates ? Un(E, l, e.multiDatesLimit) : l.value = E, t(), rt().then(() => {
      le();
    });
  }, se = (i) => e.noDisabledRange ? Aa(o.value[0], i).some((ne) => S(ne)) : !1, O = () => {
    o.value = l.value ? l.value.slice() : [], o.value.length === 2 && !(e.fixedStart || e.fixedEnd) && (o.value = []);
  }, X = (i, E) => {
    const ne = [P(i.value), it(P(i.value), +e.autoRange)];
    R(ne) && (E && $e(i.value), o.value = ne);
  }, $e = (i) => {
    const E = ge(P(i)), ne = me(P(i));
    if (A(0, E, ne), p.value.count > 0)
      for (let de = 1; de < p.value.count; de++) {
        const De = Rr(
          ke(P(i), { year: I.value(de - 1), month: H.value(de - 1) })
        );
        A(de, De.month, De.year);
      }
  }, x = (i) => Array.isArray(l.value) && l.value.length === 2 ? e.fixedStart && (Ne(i, l.value[0]) || ye(i, l.value[0])) ? [l.value[0], i] : e.fixedEnd && (Pe(i, l.value[1]) || ye(i, l.value[1])) ? [i, l.value[1]] : (n("invalid-fixed-range", i), l.value) : [], Ve = (i) => {
    se(i.value) || !J(i.value, l.value, e.fixedStart ? 0 : 1) || (o.value = x(P(i.value)));
  }, Se = (i, E) => {
    if (O(), e.autoRange)
      return X(i, E);
    if (e.fixedStart || e.fixedEnd)
      return Ve(i);
    o.value[0] ? J(P(i.value), l.value) && !se(i.value) && (Pe(P(i.value), P(o.value[0])) ? (o.value.unshift(P(i.value)), n("range-end", o.value[0])) : (o.value[1] = P(i.value), n("range-end", o.value[1]))) : (o.value[0] = P(i.value), n("range-start", o.value[0]));
  }, Ft = (i = !0) => e.enableSeconds ? Array.isArray(M.seconds) ? i ? M.seconds[0] : M.seconds[1] : M.seconds : 0, Mt = (i) => {
    o.value[i] = nt(
      o.value[i],
      M.hours[i],
      M.minutes[i],
      Ft(i !== 1)
    );
  }, xt = () => {
    var i, E;
    o.value[0] && o.value[1] && +((i = o.value) == null ? void 0 : i[0]) > +((E = o.value) == null ? void 0 : E[1]) && (o.value.reverse(), n("range-start", o.value[0]), n("range-end", o.value[1]));
  }, Qt = () => {
    o.value.length && (o.value[0] && !o.value[1] ? Mt(0) : (Mt(0), Mt(1), t()), xt(), l.value = o.value.slice(), Wn(o.value, n, e.autoApply, e.modelAuto));
  }, en = (i, E = !1) => {
    if (!(S(i.value) || !i.current && e.hideOffsetDates)) {
      if (e.weekPicker)
        return G(i);
      if (!e.range)
        return we(i);
      ua(M.hours) && ua(M.minutes) && !e.multiDates && (Se(i, E), Qt());
    }
  }, tn = (i, E) => {
    var de;
    A(i, E.month, E.year), p.value.count && !p.value.solo && u(i), n("update-month-year", { instance: i, month: E.month, year: E.year }), a(p.value.solo ? i : void 0);
    const ne = (de = e.flow) != null && de.length ? e.flow[e.flowStep] : void 0;
    !E.fromNav && (ne === Ke.month || ne === Ke.year) && t();
  }, nn = (i, E) => {
    Array.isArray(i) && i.length <= 2 && e.range ? l.value = i.map((ne) => Ze(P(ne), E ? void 0 : e.timezone)) : Array.isArray(i) || (l.value = Ze(P(i), E ? void 0 : e.timezone)), q(), e.multiCalendars && rt().then(() => f(!0));
  }, an = () => {
    e.range ? l.value && Array.isArray(l.value) && l.value[0] ? l.value = Pe(P(), l.value[0]) ? [P(), l.value[0]] : [l.value[0], P()] : l.value = [P()] : l.value = P(), q();
  }, rn = () => {
    if (Array.isArray(l.value))
      if (e.multiDates) {
        const i = re();
        l.value[l.value.length - 1] = Q(i);
      } else
        l.value = l.value.map((i, E) => i && Q(i, E));
    else
      l.value = Q(l.value);
    n("time-update");
  }, re = () => Array.isArray(l.value) && l.value.length ? l.value[l.value.length - 1] : null;
  return {
    calendars: d,
    modelValue: l,
    month: I,
    year: H,
    time: M,
    disabledTimesConfig: T,
    getCalendarDays: ae,
    getMarker: U,
    handleScroll: _,
    handleSwipe: r,
    handleArrow: ee,
    selectDate: en,
    updateMonthYear: tn,
    presetDate: nn,
    selectCurrentDate: an,
    updateTime: (i, E = !0, ne = !1) => {
      W(i, E, ne, rn);
    }
  };
}, jl = { key: 0 }, Kl = /* @__PURE__ */ Ee({
  __name: "DatePicker",
  props: {
    ...Qe
  },
  emits: [
    "tooltip-open",
    "tooltip-close",
    "mount",
    "update:internal-model-value",
    "update-flow-step",
    "reset-flow",
    "auto-apply",
    "focus-menu",
    "select-date",
    "range-start",
    "range-end",
    "invalid-fixed-range",
    "time-update",
    "am-pm-change",
    "time-picker-open",
    "time-picker-close",
    "recalculate-position",
    "update-month-year"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, {
      calendars: o,
      month: l,
      year: d,
      modelValue: M,
      time: p,
      disabledTimesConfig: $,
      getCalendarDays: h,
      getMarker: S,
      handleArrow: R,
      handleScroll: J,
      handleSwipe: W,
      selectDate: Q,
      updateMonthYear: Z,
      presetDate: k,
      selectCurrentDate: T,
      updateTime: I
    } = zl(t, a, u, y), H = It(), { setHoverDate: A, getDayClassData: q, clearHoverDate: j } = qr(M, t), { defaultedMultiCalendars: le } = Re(t), f = z([]), w = z([]), C = z(null), K = je(H, "calendar"), c = je(H, "monthYear"), V = je(H, "timePicker"), b = (N) => {
      t.shadow || a("mount", N);
    };
    gt(
      o,
      () => {
        t.shadow || setTimeout(() => {
          a("recalculate-position");
        }, 0);
      },
      { deep: !0 }
    );
    const m = L(() => (N) => h(l.value(N), d.value(N)).map((g) => ({
      ...g,
      days: g.days.map((F) => (F.marker = S(F), F.classData = q(F), F))
    })));
    function u(N) {
      var g;
      N || N === 0 ? (g = w.value[N]) == null || g.triggerTransition(l.value(N), d.value(N)) : w.value.forEach((F, ae) => F.triggerTransition(l.value(ae), d.value(ae)));
    }
    function y() {
      a("update-flow-step");
    }
    const s = (N, g = !1) => {
      Q(N, g), t.spaceConfirm && a("select-date");
    };
    return n({
      clearHoverDate: j,
      presetDate: k,
      selectCurrentDate: T,
      toggleMonthPicker: (N, g, F = 0) => {
        var ae;
        (ae = f.value[F]) == null || ae.toggleMonthPicker(N, g);
      },
      toggleYearPicker: (N, g, F = 0) => {
        var ae;
        (ae = f.value[F]) == null || ae.toggleYearPicker(N, g);
      },
      toggleTimePicker: (N, g, F) => {
        var ae;
        (ae = C.value) == null || ae.toggleTimePicker(N, g, F);
      },
      handleArrow: R,
      updateMonthYear: Z,
      getSidebarProps: () => ({
        modelValue: M,
        month: l,
        year: d,
        time: p,
        updateTime: I,
        updateMonthYear: Z,
        selectDate: Q,
        presetDate: k
      })
    }), (N, g) => (D(), Y(fe, null, [
      qe(Ln, {
        "multi-calendars": v(le).count
      }, {
        default: ce(({ instance: F, index: ae }) => [
          N.disableMonthYearSelect ? B("", !0) : (D(), ve(Il, Be({
            key: 0,
            ref: (G) => {
              G && (f.value[ae] = G);
            },
            months: v(Da)(N.formatLocale, N.locale, N.monthNameFormat),
            years: v(Vn)(N.yearRange, N.reverseYears),
            month: v(l)(F),
            year: v(d)(F),
            instance: F
          }, N.$props, {
            onMount: g[0] || (g[0] = (G) => b(v(mt).header)),
            onResetFlow: g[1] || (g[1] = (G) => N.$emit("reset-flow")),
            onUpdateMonthYear: (G) => v(Z)(F, G),
            onOverlayClosed: g[2] || (g[2] = (G) => N.$emit("focus-menu"))
          }), Fe({ _: 2 }, [
            Me(v(c), (G, we) => ({
              name: G,
              fn: ce((se) => [
                te(N.$slots, G, Ce(He(se)))
              ])
            }))
          ]), 1040, ["months", "years", "month", "year", "instance", "onUpdateMonthYear"])),
          qe(Wl, Be({
            ref: (G) => {
              G && (w.value[ae] = G);
            },
            "mapped-dates": m.value(F),
            month: v(l)(F),
            year: v(d)(F)
          }, N.$props, {
            onSelectDate: (G) => v(Q)(G, F !== 1),
            onHandleSpace: (G) => s(G, F !== 1),
            onSetHoverDate: g[3] || (g[3] = (G) => v(A)(G)),
            onHandleScroll: (G) => v(J)(G, F),
            onHandleSwipe: (G) => v(W)(G, F),
            onMount: g[4] || (g[4] = (G) => b(v(mt).calendar)),
            onResetFlow: g[5] || (g[5] = (G) => N.$emit("reset-flow")),
            onTooltipOpen: g[6] || (g[6] = (G) => N.$emit("tooltip-open", G)),
            onTooltipClose: g[7] || (g[7] = (G) => N.$emit("tooltip-close", G))
          }), Fe({ _: 2 }, [
            Me(v(K), (G, we) => ({
              name: G,
              fn: ce((se) => [
                te(N.$slots, G, Ce(He({ ...se })))
              ])
            }))
          ]), 1040, ["mapped-dates", "month", "year", "onSelectDate", "onHandleSpace", "onHandleScroll", "onHandleSwipe"])
        ]),
        _: 3
      }, 8, ["multi-calendars"]),
      N.enableTimePicker ? (D(), Y("div", jl, [
        N.$slots["time-picker"] ? te(N.$slots, "time-picker", Ce(Be({ key: 0 }, { time: v(p), updateTime: v(I) }))) : (D(), ve(Na, Be({
          key: 1,
          ref_key: "timePickerRef",
          ref: C
        }, N.$props, {
          hours: v(p).hours,
          minutes: v(p).minutes,
          seconds: v(p).seconds,
          "internal-model-value": N.internalModelValue,
          "disabled-times-config": v($),
          onMount: g[8] || (g[8] = (F) => b(v(mt).timePicker)),
          "onUpdate:hours": g[9] || (g[9] = (F) => v(I)(F)),
          "onUpdate:minutes": g[10] || (g[10] = (F) => v(I)(F, !1)),
          "onUpdate:seconds": g[11] || (g[11] = (F) => v(I)(F, !1, !0)),
          onResetFlow: g[12] || (g[12] = (F) => N.$emit("reset-flow")),
          onOverlayClosed: g[13] || (g[13] = (F) => N.$emit("time-picker-close")),
          onOverlayOpened: g[14] || (g[14] = (F) => N.$emit("time-picker-open", F)),
          onAmPmChange: g[15] || (g[15] = (F) => N.$emit("am-pm-change", F))
        }), Fe({ _: 2 }, [
          Me(v(V), (F, ae) => ({
            name: F,
            fn: ce((G) => [
              te(N.$slots, F, Ce(He(G)))
            ])
          }))
        ]), 1040, ["hours", "minutes", "seconds", "internal-model-value", "disabled-times-config"]))
      ])) : B("", !0)
    ], 64));
  }
}), Gl = ["id", "onKeydown"], Zl = {
  key: 0,
  class: "dp__sidebar_left"
}, ql = {
  key: 1,
  class: "dp--preset-dates"
}, Jl = ["onClick", "onKeydown"], Xl = {
  key: 2,
  class: "dp__sidebar_right"
}, xl = {
  key: 3,
  class: "dp__action_extra"
}, ia = /* @__PURE__ */ Ee({
  compatConfig: {
    MODE: 3
  },
  __name: "DatepickerMenu",
  props: {
    ...Xt,
    shadow: { type: Boolean, default: !1 },
    openOnTop: { type: Boolean, default: !1 },
    internalModelValue: { type: [Date, Array], default: null },
    arrMapValues: { type: Object, default: () => ({}) }
  },
  emits: [
    "close-picker",
    "select-date",
    "auto-apply",
    "time-update",
    "flow-step",
    "update-month-year",
    "invalid-select",
    "update:internal-model-value",
    "recalculate-position",
    "invalid-fixed-range",
    "tooltip-open",
    "tooltip-close",
    "time-picker-open",
    "time-picker-close",
    "am-pm-change",
    "range-start",
    "range-end"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, o = L(() => {
      const { openOnTop: O, ...X } = t;
      return {
        ...X,
        flowStep: q.value
      };
    }), { setMenuFocused: l, setShiftKey: d, control: M } = Ca(), p = It(), { defaultedTextInput: $, defaultedInline: h } = Re(t), S = z(null), R = z(0), J = z(null), W = z(null), Q = z(!1), Z = z(null);
    Ue(() => {
      if (!t.shadow) {
        Q.value = !0, k(), window.addEventListener("resize", k);
        const O = Ae(J);
        if (O && !$.value.enabled && !h.value.enabled && (l(!0), C()), O) {
          const X = ($e) => {
            t.allowPreventDefault && $e.preventDefault(), $e.stopImmediatePropagation(), $e.stopPropagation();
          };
          O.addEventListener("pointerdown", X), O.addEventListener("mousedown", X);
        }
      }
    }), _n(() => {
      window.removeEventListener("resize", k);
    });
    const k = () => {
      const O = Ae(W);
      O && (R.value = O.getBoundingClientRect().width);
    }, { arrowRight: T, arrowLeft: I, arrowDown: H, arrowUp: A } = lt(), { flowStep: q, updateFlowStep: j, childMount: le, resetFlow: f } = Jr(t, a, Z), w = L(() => t.monthPicker ? vl : t.yearPicker ? gl : t.timePicker ? Rl : Kl), C = () => {
      const O = Ae(J);
      O && O.focus({ preventScroll: !0 });
    }, K = L(() => {
      var O;
      return ((O = Z.value) == null ? void 0 : O.getSidebarProps()) || {};
    }), c = () => {
      t.openOnTop && a("recalculate-position");
    }, V = je(p, "action"), b = L(() => t.monthPicker || t.yearPicker ? je(p, "monthYear") : t.timePicker ? je(p, "timePicker") : je(p, "shared")), m = L(() => t.openOnTop ? "dp__arrow_bottom" : "dp__arrow_top"), u = L(() => ({
      dp__menu_disabled: t.disabled,
      dp__menu_readonly: t.readonly
    })), y = L(
      () => ({
        dp__menu: !0,
        dp__menu_index: !h.value.enabled,
        dp__relative: h.value.enabled,
        [t.menuClassName]: !!t.menuClassName
      })
    ), s = (O) => {
      O.stopPropagation(), O.stopImmediatePropagation();
    }, _ = () => {
      t.escClose && a("close-picker");
    }, ee = (O) => {
      if (t.arrowNavigation) {
        if (O === "up")
          return A();
        if (O === "down")
          return H();
        if (O === "left")
          return I();
        if (O === "right")
          return T();
      } else
        O === "left" || O === "up" ? F("handleArrow", "left", 0, O === "up") : F("handleArrow", "right", 0, O === "down");
    }, r = (O) => {
      d(O.shiftKey), !t.disableMonthYearSelect && O.code === "Tab" && O.target.classList.contains("dp__menu") && M.value.shiftKeyInMenu && (O.preventDefault(), O.stopImmediatePropagation(), a("close-picker"));
    }, U = () => {
      C(), a("time-picker-close");
    }, N = (O) => {
      var X, $e, x;
      (X = Z.value) == null || X.toggleTimePicker(!1, !1), ($e = Z.value) == null || $e.toggleMonthPicker(!1, !1, O), (x = Z.value) == null || x.toggleYearPicker(!1, !1, O);
    }, g = (O, X = 0) => {
      var $e, x, Ve;
      return O === "month" ? ($e = Z.value) == null ? void 0 : $e.toggleMonthPicker(!1, !0, X) : O === "year" ? (x = Z.value) == null ? void 0 : x.toggleYearPicker(!1, !0, X) : O === "time" ? (Ve = Z.value) == null ? void 0 : Ve.toggleTimePicker(!0, !1) : N(X);
    }, F = (O, ...X) => {
      var $e, x;
      ($e = Z.value) != null && $e[O] && ((x = Z.value) == null || x[O](...X));
    }, ae = () => {
      F("selectCurrentDate");
    }, G = (O, X) => {
      F("presetDate", O, X);
    }, we = () => {
      F("clearHoverDate");
    };
    return n({
      updateMonthYear: (O, X) => {
        F("updateMonthYear", O, X);
      },
      switchView: g
    }), (O, X) => {
      var $e;
      return D(), Y("div", {
        id: O.uid ? `dp-menu-${O.uid}` : void 0,
        tabindex: "0",
        ref_key: "dpMenuRef",
        ref: J,
        role: "dialog",
        class: he(y.value),
        onMouseleave: we,
        onClick: s,
        onKeydown: [
          oe(_, ["esc"]),
          X[15] || (X[15] = oe(pe((x) => ee("left"), ["prevent"]), ["left"])),
          X[16] || (X[16] = oe(pe((x) => ee("up"), ["prevent"]), ["up"])),
          X[17] || (X[17] = oe(pe((x) => ee("down"), ["prevent"]), ["down"])),
          X[18] || (X[18] = oe(pe((x) => ee("right"), ["prevent"]), ["right"])),
          r
        ]
      }, [
        (O.disabled || O.readonly) && v(h).enabled ? (D(), Y("div", {
          key: 0,
          class: he(u.value)
        }, null, 2)) : B("", !0),
        !v(h).enabled && !O.teleportCenter ? (D(), Y("div", {
          key: 1,
          class: he(m.value)
        }, null, 2)) : B("", !0),
        ue("div", {
          ref_key: "innerMenuRef",
          ref: W,
          class: he({
            dp__menu_content_wrapper: (($e = O.presetDates) == null ? void 0 : $e.length) || !!O.$slots["left-sidebar"] || !!O.$slots["right-sidebar"]
          }),
          style: Ge({ "--dp-menu-width": `${R.value}px` })
        }, [
          O.$slots["left-sidebar"] ? (D(), Y("div", Zl, [
            te(O.$slots, "left-sidebar", Ce(He(K.value)))
          ])) : B("", !0),
          O.presetDates.length ? (D(), Y("div", ql, [
            (D(!0), Y(fe, null, Me(O.presetDates, (x, Ve) => (D(), Y("div", {
              key: Ve,
              style: Ge(x.style || {}),
              class: "dp--preset-range"
            }, [
              x.slot ? te(O.$slots, x.slot, {
                key: 0,
                presetDate: G,
                label: x.label,
                value: x.value
              }) : (D(), Y("div", {
                key: 1,
                role: "button",
                tabindex: "0",
                onClick: (Se) => G(x.value, x.noTz),
                onKeydown: [
                  oe(pe((Se) => G(x.value, x.noTz), ["prevent"]), ["enter"]),
                  oe(pe((Se) => G(x.value, x.noTz), ["prevent"]), ["space"])
                ]
              }, Ie(x.label), 41, Jl))
            ], 4))), 128))
          ])) : B("", !0),
          ue("div", {
            class: "dp__instance_calendar",
            ref_key: "calendarWrapperRef",
            ref: S,
            role: "document"
          }, [
            (D(), ve(Pn(w.value), Be({
              ref_key: "dynCmpRef",
              ref: Z
            }, o.value, {
              "flow-step": v(q),
              onMount: v(le),
              onUpdateFlowStep: v(j),
              onResetFlow: v(f),
              onFocusMenu: C,
              onSelectDate: X[0] || (X[0] = (x) => O.$emit("select-date")),
              onTooltipOpen: X[1] || (X[1] = (x) => O.$emit("tooltip-open", x)),
              onTooltipClose: X[2] || (X[2] = (x) => O.$emit("tooltip-close", x)),
              onAutoApply: X[3] || (X[3] = (x) => O.$emit("auto-apply", x)),
              onRangeStart: X[4] || (X[4] = (x) => O.$emit("range-start", x)),
              onRangeEnd: X[5] || (X[5] = (x) => O.$emit("range-end", x)),
              onInvalidFixedRange: X[6] || (X[6] = (x) => O.$emit("invalid-fixed-range", x)),
              onTimeUpdate: X[7] || (X[7] = (x) => O.$emit("time-update")),
              onAmPmChange: X[8] || (X[8] = (x) => O.$emit("am-pm-change", x)),
              onTimePickerOpen: X[9] || (X[9] = (x) => O.$emit("time-picker-open", x)),
              onTimePickerClose: U,
              onRecalculatePosition: c,
              onUpdateMonthYear: X[10] || (X[10] = (x) => O.$emit("update-month-year", x)),
              "onUpdate:internalModelValue": X[11] || (X[11] = (x) => O.$emit("update:internal-model-value", x))
            }), Fe({ _: 2 }, [
              Me(b.value, (x, Ve) => ({
                name: x,
                fn: ce((Se) => [
                  te(O.$slots, x, Ce(He({ ...Se })))
                ])
              }))
            ]), 1040, ["flow-step", "onMount", "onUpdateFlowStep", "onResetFlow"]))
          ], 512),
          O.$slots["right-sidebar"] ? (D(), Y("div", Xl, [
            te(O.$slots, "right-sidebar", Ce(He(K.value)))
          ])) : B("", !0),
          O.$slots["action-extra"] ? (D(), Y("div", xl, [
            O.$slots["action-extra"] ? te(O.$slots, "action-extra", {
              key: 0,
              selectCurrentDate: ae
            }) : B("", !0)
          ])) : B("", !0)
        ], 6),
        !O.autoApply || O.keepActionRow ? (D(), ve(rl, Be({
          key: 2,
          "menu-mount": Q.value
        }, o.value, {
          "calendar-width": R.value,
          onClosePicker: X[12] || (X[12] = (x) => O.$emit("close-picker")),
          onSelectDate: X[13] || (X[13] = (x) => O.$emit("select-date")),
          onInvalidSelect: X[14] || (X[14] = (x) => O.$emit("invalid-select")),
          onSelectNow: ae
        }), Fe({ _: 2 }, [
          Me(v(V), (x, Ve) => ({
            name: x,
            fn: ce((Se) => [
              te(O.$slots, x, Ce(He({ ...Se })))
            ])
          }))
        ]), 1040, ["menu-mount", "calendar-width"])) : B("", !0)
      ], 42, Gl);
    };
  }
}), Ql = typeof window < "u" ? window : void 0, bn = () => {
}, eo = (e) => Fa() ? (Va(e), !0) : !1, to = (e, n, a, t) => {
  if (!e)
    return bn;
  let o = bn;
  const l = gt(
    () => v(e),
    (M) => {
      o(), M && (M.addEventListener(n, a, t), o = () => {
        M.removeEventListener(n, a, t), o = bn;
      });
    },
    { immediate: !0, flush: "post" }
  ), d = () => {
    l(), o();
  };
  return eo(d), d;
}, no = (e, n, a, t = {}) => {
  const { window: o = Ql, event: l = "pointerdown" } = t;
  return o ? to(o, l, (M) => {
    const p = Ae(e), $ = Ae(n);
    !p || !$ || p === M.target || M.composedPath().includes(p) || M.composedPath().includes($) || a(M);
  }, { passive: !0 }) : void 0;
}, ao = /* @__PURE__ */ Ee({
  compatConfig: {
    MODE: 3
  },
  __name: "VueDatePicker",
  props: {
    ...Xt
  },
  emits: [
    "update:model-value",
    "update:model-timezone-value",
    "text-submit",
    "closed",
    "cleared",
    "open",
    "focus",
    "blur",
    "internal-model-change",
    "recalculate-position",
    "flow-step",
    "update-month-year",
    "invalid-select",
    "invalid-fixed-range",
    "tooltip-open",
    "tooltip-close",
    "time-picker-open",
    "time-picker-close",
    "am-pm-change",
    "range-start",
    "range-end"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, o = It(), l = z(!1), d = Gt(t, "modelValue"), M = Gt(t, "timezone"), p = z(null), $ = z(null), h = z(null), S = z(!1), R = z(null), { setMenuFocused: J, setShiftKey: W } = Ca(), { clearArrowNav: Q } = lt(), { mapDatesArrToMap: Z, validateDate: k, isValidTime: T } = Et(t), { defaultedTransitions: I, defaultedTextInput: H, defaultedInline: A } = Re(t), { menuTransition: q, showTransition: j } = Bt(I);
    Ue(() => {
      s(t.modelValue), rt().then(() => {
        A.value.enabled || (b(R.value).addEventListener("scroll", F), window.addEventListener("resize", ae));
      }), A.value.enabled && (l.value = !0);
    });
    const le = L(() => Z());
    _n(() => {
      if (!A.value.enabled) {
        const re = b(R.value);
        re && re.removeEventListener("scroll", F), window.removeEventListener("resize", ae);
      }
    });
    const f = je(o, "all", t.presetDates), w = je(o, "input");
    gt(
      [d, M],
      () => {
        s(d.value);
      },
      { deep: !0 }
    );
    const { openOnTop: C, menuStyle: K, xCorrect: c, setMenuPosition: V, getScrollableParent: b, shadowRender: m } = Kr({
      menuRef: p,
      menuRefInner: $,
      inputRef: h,
      pickerWrapperRef: R,
      inline: A,
      emit: a,
      props: t,
      slots: o
    }), {
      inputValue: u,
      internalModelValue: y,
      parseExternalModelValue: s,
      emitModelValue: _,
      formatInputValue: ee,
      checkBeforeEmit: r
    } = zr(a, t, S), U = L(
      () => ({
        dp__main: !0,
        dp__theme_dark: t.dark,
        dp__theme_light: !t.dark,
        dp__flex_display: A.value.enabled,
        dp__flex_display_with_input: A.value.input
      })
    ), N = L(() => t.dark ? "dp__theme_dark" : "dp__theme_light"), g = L(() => t.teleport ? {
      to: typeof t.teleport == "boolean" ? "body" : t.teleport,
      disabled: A.value.enabled
    } : { class: "dp__outer_menu_wrap" }), F = () => {
      l.value && (t.closeOnScroll ? Se() : V());
    }, ae = () => {
      l.value && V();
    }, G = () => {
      !t.disabled && !t.readonly && (m(ia, t), V(!1), l.value = !0, l.value && a("open"), l.value || Ve(), s(t.modelValue));
    }, we = () => {
      u.value = "", Ve(), a("update:model-value", null), a("update:model-timezone-value", null), a("cleared"), t.closeOnClearValue && Se();
    }, se = () => {
      const re = y.value;
      return !re || !Array.isArray(re) && k(re) ? !0 : Array.isArray(re) ? re.length === 2 && k(re[0]) && k(re[1]) ? !0 : t.partialRange && !t.timePicker ? k(re[0]) : !1 : !1;
    }, O = () => {
      r() && se() ? (_(), Se()) : a("invalid-select", y.value);
    }, X = (re) => {
      $e(), _(), t.closeOnAutoApply && !re && Se();
    }, $e = () => {
      h.value && H.value.enabled && h.value.setParsedDate(y.value);
    }, x = (re = !1) => {
      t.autoApply && T(y.value) && se() && (t.range && Array.isArray(y.value) ? (t.partialRange || y.value.length === 2) && X(re) : X(re));
    }, Ve = () => {
      H.value.enabled || (y.value = null);
    }, Se = () => {
      A.value.enabled || (l.value && (l.value = !1, c.value = !1, J(!1), W(!1), Q(), a("closed"), u.value && s(d.value)), Ve(), a("blur"));
    }, Ft = (re, ie) => {
      if (!re) {
        y.value = null;
        return;
      }
      y.value = re, ie && (O(), a("text-submit"));
    }, Mt = () => {
      t.autoApply && T(y.value) && _(), $e();
    }, xt = () => l.value ? Se() : G(), Qt = (re) => {
      y.value = re;
    }, en = () => {
      H.value.enabled && (S.value = !0, ee()), a("focus");
    }, tn = () => {
      H.value.enabled && (S.value = !1, s(t.modelValue)), a("blur");
    }, nn = (re) => {
      $.value && $.value.updateMonthYear(0, {
        month: ta(re.month),
        year: ta(re.year)
      });
    }, an = (re) => {
      s(re ?? t.modelValue);
    }, rn = (re, ie) => {
      var i;
      (i = $.value) == null || i.switchView(re, ie);
    };
    return no(
      p,
      h,
      t.onClickOutside ? () => t.onClickOutside(se) : Se
    ), n({
      closeMenu: Se,
      selectDate: O,
      clearValue: we,
      openMenu: G,
      onScroll: F,
      formatInputValue: ee,
      // exposed for testing purposes
      updateInternalModelValue: Qt,
      // modify internal modelValue
      setMonthYear: nn,
      parseModel: an,
      switchView: rn
    }), (re, ie) => (D(), Y("div", {
      class: he(U.value),
      ref_key: "pickerWrapperRef",
      ref: R
    }, [
      qe(el, Be({
        ref_key: "inputRef",
        ref: h,
        "is-menu-open": l.value,
        "input-value": v(u),
        "onUpdate:inputValue": ie[0] || (ie[0] = (i) => jn(u) ? u.value = i : null)
      }, re.$props, {
        onClear: we,
        onOpen: G,
        onSetInputDate: Ft,
        onSetEmptyDate: v(_),
        onSelectDate: O,
        onToggle: xt,
        onClose: Se,
        onFocus: en,
        onBlur: tn,
        onRealBlur: ie[1] || (ie[1] = (i) => S.value = !1)
      }), Fe({ _: 2 }, [
        Me(v(w), (i, E) => ({
          name: i,
          fn: ce((ne) => [
            te(re.$slots, i, Ce(He(ne)))
          ])
        }))
      ]), 1040, ["is-menu-open", "input-value", "onSetEmptyDate"]),
      qe(Dt, {
        name: v(q)(v(C)),
        css: v(j) && !v(A).enabled
      }, {
        default: ce(() => [
          l.value ? (D(), ve(Pn(re.teleport ? Ha : "div"), Be({
            key: 0,
            ref_key: "dpWrapMenuRef",
            ref: p
          }, g.value, {
            class: { "dp--menu-wrapper": !v(A).enabled },
            style: v(A).enabled ? void 0 : v(K)
          }), {
            default: ce(() => [
              qe(ia, Be({
                ref_key: "dpMenuRef",
                ref: $,
                class: { [N.value]: !0, "dp--menu-wrapper": re.teleport },
                style: re.teleport ? v(K) : void 0,
                "open-on-top": v(C),
                "arr-map-values": le.value
              }, re.$props, {
                "internal-model-value": v(y),
                "onUpdate:internalModelValue": ie[2] || (ie[2] = (i) => jn(y) ? y.value = i : null),
                onClosePicker: Se,
                onSelectDate: O,
                onAutoApply: x,
                onTimeUpdate: Mt,
                onFlowStep: ie[3] || (ie[3] = (i) => re.$emit("flow-step", i)),
                onUpdateMonthYear: ie[4] || (ie[4] = (i) => re.$emit("update-month-year", i)),
                onInvalidSelect: ie[5] || (ie[5] = (i) => re.$emit("invalid-select", v(y))),
                onInvalidFixedRange: ie[6] || (ie[6] = (i) => re.$emit("invalid-fixed-range", i)),
                onRecalculatePosition: v(V),
                onTooltipOpen: ie[7] || (ie[7] = (i) => re.$emit("tooltip-open", i)),
                onTooltipClose: ie[8] || (ie[8] = (i) => re.$emit("tooltip-close", i)),
                onTimePickerOpen: ie[9] || (ie[9] = (i) => re.$emit("time-picker-open", i)),
                onTimePickerClose: ie[10] || (ie[10] = (i) => re.$emit("time-picker-close", i)),
                onAmPmChange: ie[11] || (ie[11] = (i) => re.$emit("am-pm-change", i)),
                onRangeStart: ie[12] || (ie[12] = (i) => re.$emit("range-start", i)),
                onRangeEnd: ie[13] || (ie[13] = (i) => re.$emit("range-end", i))
              }), Fe({ _: 2 }, [
                Me(v(f), (i, E) => ({
                  name: i,
                  fn: ce((ne) => [
                    te(re.$slots, i, Ce(He({ ...ne })))
                  ])
                }))
              ]), 1040, ["class", "style", "open-on-top", "arr-map-values", "internal-model-value", "onRecalculatePosition"])
            ]),
            _: 3
          }, 16, ["class", "style"])) : B("", !0)
        ]),
        _: 3
      }, 8, ["name", "css"])
    ], 2));
  }
}), Ia = /* @__PURE__ */ (() => {
  const e = ao;
  return e.install = (n) => {
    n.component("Vue3DatePicker", e);
  }, e;
})(), ro = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Ia
}, Symbol.toStringTag, { value: "Module" }));
Object.entries(ro).forEach(([e, n]) => {
  e !== "default" && (Ia[e] = n);
});
export {
  Ia as default
};
